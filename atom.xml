<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>喂：一二三</title>
  
  <subtitle>低调、踏实、前行。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://guohuaden.com/"/>
  <updated>2018-11-02T08:04:14.448Z</updated>
  <id>http://guohuaden.com/</id>
  
  <author>
    <name>Wheat</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>读 SDWebImage 七 （SDWebImageTransition）</title>
    <link href="http://guohuaden.com/2018/10/30/Read-SDWebImage-SDWebImageTransition/"/>
    <id>http://guohuaden.com/2018/10/30/Read-SDWebImage-SDWebImageTransition/</id>
    <published>2018-10-30T13:32:19.000Z</published>
    <updated>2018-11-02T08:04:14.448Z</updated>
    
    <content type="html"><![CDATA[<p>该类用于在视图类别加载图像完成后提供过渡动画。 </p><ol><li><p>在<code>UIVit + WebCache.h</code> 中的 <code>sd_imageTransition</code><br> 用于<code>UIKit(iOS和tvOS)</code>，使用<br> <code>+ [UIView transitionWithView：duration：options：animations：completion]</code> 进行过渡动画。 </p></li><li><p>对于<code>AppKit(macOS)</code><br>使用 <code>+ [NSAnimationContext runAnimationGroup：completionHandler：]</code>进行过渡动画。 我们可以调用<code>+ [NSAnimationContext currentContext]</code>来获取动画块中的上下文。 提供这些转换以用于基本用途。 </p></li></ol><ol start="3"><li>如果需要复杂的动画，可以考虑直接使用<code>Core Animation</code>或使用<code>SDWebImageAvoidAutoSetImage</code>并实现自己的后映像加载完成。<a id="more"></a></li></ol><h3 id="动画选项"><a href="#动画选项" class="headerlink" title="动画选项"></a>动画选项</h3><p>分两种情况，如果是 SD_UIKIT 类型，就直接使用系统的动画选项，否则定义的枚举类型只有一种隐式动画</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SD_UIKIT</span></span><br><span class="line"><span class="keyword">typedef</span> UIViewAnimationOptions SDWebImageAnimationOptions;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NS_OPTIONS</span><span class="params">(NSUInteger, SDWebImageAnimationOptions)</span> </span>&#123;</span><br><span class="line">    SDWebImageAnimationOptionAllowsImplicitAnimation = <span class="number">1</span> &lt;&lt; <span class="number">0</span>, <span class="comment">// specify `allowsImplicitAnimation` for the `NSAnimationContext`</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="三个block代码块"><a href="#三个block代码块" class="headerlink" title="三个block代码块"></a>三个block代码块</h3><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//用于动画开始之前要执行的代码块</span><br><span class="line">typedef void (^<span class="type">SDWebImageTransitionPreparesBlock</span>)(__kindof <span class="type">UIView</span> * _Nonnull view, <span class="type">UIImage</span> * _Nullable image, <span class="type">NSData</span> * _Nullable imageData, <span class="type">SDImageCacheType</span> cacheType, <span class="type">NSURL</span> * _Nullable imageURL);</span><br><span class="line"></span><br><span class="line">//用于控制展示动画的代码块</span><br><span class="line">typedef void (^<span class="type">SDWebImageTransitionAnimationsBlock</span>)(__kindof <span class="type">UIView</span> * _Nonnull view, <span class="type">UIImage</span> * _Nullable image);</span><br><span class="line"></span><br><span class="line">//用于动画结束后要执行的代码块</span><br><span class="line">typedef void (^<span class="type">SDWebImageTransitionCompletionBlock</span>)(<span class="type">BOOL</span> finished);</span><br></pre></td></tr></table></figure><h3 id="属性声明"><a href="#属性声明" class="headerlink" title="属性声明"></a>属性声明</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认情况下，我们将图像设置为动画开头的视图。 您可以禁用此功能并提供自定义设置图像处理</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> avoidAutoSetImage;</span><br><span class="line"></span><br><span class="line"><span class="comment">//过渡动画的持续时间，以秒为单位。 默认为0.5。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSTimeInterval</span> duration;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于此过渡动画（macOS）中所有动画的计时功能。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="built_in">CAMediaTimingFunction</span> *timingFunction <span class="built_in">NS_AVAILABLE_MAC</span>(<span class="number">10</span>_7);</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个动画选项</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) SDWebImageAnimationOptions animationOptions;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动画开始前所要执行的代码块</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) SDWebImageTransitionPreparesBlock prepares;</span><br><span class="line"></span><br><span class="line">动画代码块</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) SDWebImageTransitionAnimationsBlock animations;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动画结束时要执行的代码块。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) SDWebImageTransitionCompletionBlock completion;</span><br></pre></td></tr></table></figure><h3 id="Conveniences分类"><a href="#Conveniences分类" class="headerlink" title="Conveniences分类"></a>Conveniences分类</h3><p>创建过渡的便捷方式 如果需要，请记住指定持续时间。 对于UIKit，这些转换只使用对应的<code>animationOptions</code>。 默认情况下，我们启用<code>UIViewAnimationOptionAllowUserInteraction</code>以允许用户在转换期间进行交互。 对于AppKit，这些过渡在“动画”中使用了Core Animation。 因此，您的视图必须是图层支持的。 在应用之前设置<code>wantsLayer = YES</code>。</p><h4 id="公共属性和方法"><a href="#公共属性和方法" class="headerlink" title="公共属性和方法"></a>公共属性和方法</h4><p>调用不同的类属性获取不同的动画效果，如果类属性不可用，就调用类方法类获取不同的动画效果</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#if __has_feature(objc_class_property)</span></span><br><span class="line"><span class="comment">/// 淡出过渡。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">class</span>, <span class="keyword">nonnull</span>, <span class="keyword">readonly</span>) SDWebImageTransition *fadeTransition;</span><br><span class="line"><span class="comment">/// 从左转换翻转。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">class</span>, <span class="keyword">nonnull</span>, <span class="keyword">readonly</span>) SDWebImageTransition *flipFromLeftTransition;</span><br><span class="line"><span class="comment">/// 从右转换翻转。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">class</span>, <span class="keyword">nonnull</span>, <span class="keyword">readonly</span>) SDWebImageTransition *flipFromRightTransition;</span><br><span class="line"><span class="comment">/// 从顶部过渡翻转。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">class</span>, <span class="keyword">nonnull</span>, <span class="keyword">readonly</span>) SDWebImageTransition *flipFromTopTransition;</span><br><span class="line"><span class="comment">/// 从底部过渡翻转。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">class</span>, <span class="keyword">nonnull</span>, <span class="keyword">readonly</span>) SDWebImageTransition *flipFromBottomTransition;</span><br><span class="line"><span class="comment">/// 卷起过渡。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">class</span>, <span class="keyword">nonnull</span>, <span class="keyword">readonly</span>) SDWebImageTransition *curlUpTransition;</span><br><span class="line"><span class="comment">/// 向下弯曲过渡。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">class</span>, <span class="keyword">nonnull</span>, <span class="keyword">readonly</span>) SDWebImageTransition *curlDownTransition;</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)fadeTransition;</span><br><span class="line">+ (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)flipFromLeftTransition;</span><br><span class="line">+ (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)flipFromRightTransition;</span><br><span class="line">+ (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)flipFromTopTransition;</span><br><span class="line">+ (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)flipFromBottomTransition;</span><br><span class="line">+ (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)curlUpTransition;</span><br><span class="line">+ (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)curlDownTransition;</span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><h3 id="方法实现"><a href="#方法实现" class="headerlink" title="方法实现"></a>方法实现</h3><p><code>SDWebImageTransition</code> 只有一个初始化方法，设置了动画时间为0.5秒</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SDWebImageTransition</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.duration = <span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>SDWebImageTransition 分类中创建了不同的动画,这里区别了SD_UIKIT 和 其他。（即iOS 、tvOS、部分watchOS ）</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">+ (SDWebImageTransition *)fadeTransition &#123;</span><br><span class="line">    SDWebImageTransition *transition = [SDWebImageTransition new];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SD_UIKIT</span></span><br><span class="line">    transition.animationOptions = UIViewAnimationOptionTransitionCrossDissolve | UIViewAnimationOptionAllowUserInteraction;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    transition.animations = ^(<span class="variable">__kindof</span> NSView * <span class="variable">_Nonnull</span> view, NSImage * <span class="variable">_Nullable</span> <span class="built_in">image</span>) &#123;</span><br><span class="line">        CATransition *trans = [CATransition animation];</span><br><span class="line">        trans.<span class="built_in">type</span> = kCATransitionFade;</span><br><span class="line">        [view.layer addAnimation:trans forKey:kCATransition];</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    return transition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (SDWebImageTransition *)flipFromLeftTransition &#123;</span><br><span class="line">    SDWebImageTransition *transition = [SDWebImageTransition new];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SD_UIKIT</span></span><br><span class="line">    transition.animationOptions = UIViewAnimationOptionTransitionFlipFromLeft | UIViewAnimationOptionAllowUserInteraction;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    transition.animations = ^(<span class="variable">__kindof</span> NSView * <span class="variable">_Nonnull</span> view, NSImage * <span class="variable">_Nullable</span> <span class="built_in">image</span>) &#123;</span><br><span class="line">        CATransition *trans = [CATransition animation];</span><br><span class="line">        trans.<span class="built_in">type</span> = kCATransitionPush;</span><br><span class="line">        trans.subtype = kCATransitionFromLeft;</span><br><span class="line">        [view.layer addAnimation:trans forKey:kCATransition];</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    return transition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (SDWebImageTransition *)flipFromRightTransition &#123;</span><br><span class="line">    SDWebImageTransition *transition = [SDWebImageTransition new];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SD_UIKIT</span></span><br><span class="line">    transition.animationOptions = UIViewAnimationOptionTransitionFlipFromRight | UIViewAnimationOptionAllowUserInteraction;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    transition.animations = ^(<span class="variable">__kindof</span> NSView * <span class="variable">_Nonnull</span> view, NSImage * <span class="variable">_Nullable</span> <span class="built_in">image</span>) &#123;</span><br><span class="line">        CATransition *trans = [CATransition animation];</span><br><span class="line">        trans.<span class="built_in">type</span> = kCATransitionPush;</span><br><span class="line">        trans.subtype = kCATransitionFromRight;</span><br><span class="line">        [view.layer addAnimation:trans forKey:kCATransition];</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    return transition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (SDWebImageTransition *)flipFromTopTransition &#123;</span><br><span class="line">    SDWebImageTransition *transition = [SDWebImageTransition new];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SD_UIKIT</span></span><br><span class="line">    transition.animationOptions = UIViewAnimationOptionTransitionFlipFromTop | UIViewAnimationOptionAllowUserInteraction;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    transition.animations = ^(<span class="variable">__kindof</span> NSView * <span class="variable">_Nonnull</span> view, NSImage * <span class="variable">_Nullable</span> <span class="built_in">image</span>) &#123;</span><br><span class="line">        CATransition *trans = [CATransition animation];</span><br><span class="line">        trans.<span class="built_in">type</span> = kCATransitionPush;</span><br><span class="line">        trans.subtype = kCATransitionFromTop;</span><br><span class="line">        [view.layer addAnimation:trans forKey:kCATransition];</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    return transition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (SDWebImageTransition *)flipFromBottomTransition &#123;</span><br><span class="line">    SDWebImageTransition *transition = [SDWebImageTransition new];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SD_UIKIT</span></span><br><span class="line">    transition.animationOptions = UIViewAnimationOptionTransitionFlipFromBottom | UIViewAnimationOptionAllowUserInteraction;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    transition.animations = ^(<span class="variable">__kindof</span> NSView * <span class="variable">_Nonnull</span> view, NSImage * <span class="variable">_Nullable</span> <span class="built_in">image</span>) &#123;</span><br><span class="line">        CATransition *trans = [CATransition animation];</span><br><span class="line">        trans.<span class="built_in">type</span> = kCATransitionPush;</span><br><span class="line">        trans.subtype = kCATransitionFromBottom;</span><br><span class="line">        [view.layer addAnimation:trans forKey:kCATransition];</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    return transition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (SDWebImageTransition *)curlUpTransition &#123;</span><br><span class="line">    SDWebImageTransition *transition = [SDWebImageTransition new];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SD_UIKIT</span></span><br><span class="line">    transition.animationOptions = UIViewAnimationOptionTransitionCurlUp | UIViewAnimationOptionAllowUserInteraction;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    transition.animations = ^(<span class="variable">__kindof</span> NSView * <span class="variable">_Nonnull</span> view, NSImage * <span class="variable">_Nullable</span> <span class="built_in">image</span>) &#123;</span><br><span class="line">        CATransition *trans = [CATransition animation];</span><br><span class="line">        trans.<span class="built_in">type</span> = kCATransitionReveal;</span><br><span class="line">        trans.subtype = kCATransitionFromTop;</span><br><span class="line">        [view.layer addAnimation:trans forKey:kCATransition];</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    return transition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (SDWebImageTransition *)curlDownTransition &#123;</span><br><span class="line">    SDWebImageTransition *transition = [SDWebImageTransition new];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SD_UIKIT</span></span><br><span class="line">    transition.animationOptions = UIViewAnimationOptionTransitionCurlDown | UIViewAnimationOptionAllowUserInteraction;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    transition.animations = ^(<span class="variable">__kindof</span> NSView * <span class="variable">_Nonnull</span> view, NSImage * <span class="variable">_Nullable</span> <span class="built_in">image</span>) &#123;</span><br><span class="line">        CATransition *trans = [CATransition animation];</span><br><span class="line">        trans.<span class="built_in">type</span> = kCATransitionReveal;</span><br><span class="line">        trans.subtype = kCATransitionFromBottom;</span><br><span class="line">        [view.layer addAnimation:trans forKey:kCATransition];</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    return transition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;该类用于在视图类别加载图像完成后提供过渡动画。 &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在&lt;code&gt;UIVit + WebCache.h&lt;/code&gt; 中的 &lt;code&gt;sd_imageTransition&lt;/code&gt;&lt;br&gt; 用于&lt;code&gt;UIKit(iOS和tvOS)&lt;/code&gt;，使用&lt;br&gt; &lt;code&gt;+ [UIView transitionWithView：duration：options：animations：completion]&lt;/code&gt; 进行过渡动画。 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于&lt;code&gt;AppKit(macOS)&lt;/code&gt;&lt;br&gt;使用 &lt;code&gt;+ [NSAnimationContext runAnimationGroup：completionHandler：]&lt;/code&gt;进行过渡动画。 我们可以调用&lt;code&gt;+ [NSAnimationContext currentContext]&lt;/code&gt;来获取动画块中的上下文。 提供这些转换以用于基本用途。 &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;如果需要复杂的动画，可以考虑直接使用&lt;code&gt;Core Animation&lt;/code&gt;或使用&lt;code&gt;SDWebImageAvoidAutoSetImage&lt;/code&gt;并实现自己的后映像加载完成。
    
    </summary>
    
      <category term="读SDWebImage手札" scheme="http://guohuaden.com/categories/%E8%AF%BBSDWebImage%E6%89%8B%E6%9C%AD/"/>
    
    
      <category term="SDWebImage" scheme="http://guohuaden.com/tags/SDWebImage/"/>
    
  </entry>
  
  <entry>
    <title>读 SDWebImage 六 （SDWebImagePrefetcher）</title>
    <link href="http://guohuaden.com/2018/10/27/Read-SDWebImage-SDWebImagePrefetcher/"/>
    <id>http://guohuaden.com/2018/10/27/Read-SDWebImage-SDWebImagePrefetcher/</id>
    <published>2018-10-27T14:32:36.000Z</published>
    <updated>2018-11-02T08:04:38.551Z</updated>
    
    <content type="html"><![CDATA[<p><code>SDWebImagePrefetcher</code> 预先下载（预加载）图片，以方便后续使用，主要是用于部分图片需要先行下载并存储的情况。预先取出缓存中的一些URLs以供将来使用。 图像以低优先级下载。</p><p><code>SDWebImagePrefetcher</code> 设计了两种回调方式：</p><ol><li><p><code>SDWebImagePrefetcherDelegate</code><br>用来处理每一个预下载完成的回调，以及所有下载完成的回调 </p></li><li><p><code>block</code><br>用来处理整体进度的回调，返回的是下载完成的数量和总数量等</p></li></ol><a id="more"></a><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@protocol</span> SDWebImagePrefetcherDelegate &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line"><span class="variable">@optional</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在预加载图片时调用。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param imagePrefetcher 当前图片预加载类</span></span><br><span class="line"><span class="comment"> * @param imageURL       预加载的图片网址</span></span><br><span class="line"><span class="comment"> * @param finishedCount   预加载的图片总数（成功与否）</span></span><br><span class="line"><span class="comment"> * @param totalCount      预加载的图片总数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (void)<span class="attribute">imagePrefetcher</span>:(nonnull SDWebImagePrefetcher *)imagePrefetcher <span class="attribute">didPrefetchURL</span>:(nullable NSURL *)imageURL <span class="attribute">finishedCount</span>:(NSUInteger)finishedCount <span class="attribute">totalCount</span>:(NSUInteger)totalCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在预加载所有图像时调用。</span></span><br><span class="line"><span class="comment"> * @param imagePrefetcher 当前图片的预加载类</span></span><br><span class="line"><span class="comment"> * @param totalCount      预加载的图片总数（无论是否成功）</span></span><br><span class="line"><span class="comment"> * @param skippedCount    跳过的图片总数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">imagePrefetcher</span><span class="selector-pseudo">:(nonnull</span> <span class="selector-tag">SDWebImagePrefetcher</span> *)<span class="selector-tag">imagePrefetcher</span> <span class="selector-tag">didFinishWithTotalCount</span><span class="selector-pseudo">:(NSUInteger)totalCount</span> <span class="selector-tag">skippedCount</span><span class="selector-pseudo">:(NSUInteger)skippedCount</span>;</span><br><span class="line"></span><br><span class="line">@<span class="selector-tag">end</span></span><br></pre></td></tr></table></figure><h3 id="两个block代码块"><a href="#两个block代码块" class="headerlink" title="两个block代码块"></a>两个block代码块</h3><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 预加载进度block</span><br><span class="line"> @param noOfFinishedUrls 已经完成的数量，无论成功失败</span><br><span class="line"> @param noOfTotalUrls    总数量</span><br><span class="line"> */</span><br><span class="line">typedef void(^<span class="type">SDWebImagePrefetcherProgressBlock</span>)(<span class="type">NSUInteger</span> noOfFinishedUrls, <span class="type">NSUInteger</span> noOfTotalUrls);</span><br><span class="line">/**</span><br><span class="line"> 预加载完成block</span><br><span class="line"></span><br><span class="line"> @param noOfFinishedUrls 已经完成的数量，无论成功失败</span><br><span class="line"> @param noOfSkippedUrls  跳过的数量</span><br><span class="line"> */</span><br><span class="line">typedef void(^<span class="type">SDWebImagePrefetcherCompletionBlock</span>)(<span class="type">NSUInteger</span> noOfFinishedUrls, <span class="type">NSUInteger</span> noOfSkippedUrls);</span><br></pre></td></tr></table></figure><h3 id="属性声明"><a href="#属性声明" class="headerlink" title="属性声明"></a>属性声明</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 网络图片管理器,只读</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">nonnull</span>) SDWebImageManager *manager;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *同时预加载的最大URL数。 默认为3。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSUInteger</span> maxConcurrentDownloads;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 预加载的SDWebImageOptions选项。 默认为SDWebImageLowPriority。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) SDWebImageOptions options;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Prefetcher的队列选项。 默认为主队列。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">dispatch_queue_t</span> prefetcherQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//协议</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="keyword">id</span> &lt;SDWebImagePrefetcherDelegate&gt; delegate;</span><br></pre></td></tr></table></figure><h3 id="方法声明"><a href="#方法声明" class="headerlink" title="方法声明"></a>方法声明</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回全局图像预加载实例。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)sharedImagePrefetcher;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 允许您使用任意图像管理器实例化预加载类。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)initWithImageManager:(<span class="keyword">nonnull</span> SDWebImageManager *)manager <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分配URL列表以让SDWebImagePrefetcher对预加载进行排队</span></span><br><span class="line"><span class="comment"> * 目前一次下载一张图片，并跳过下载失败的图像，然后进入列表中的下一个图像。任何先前运行的预加载操作都将被取消。</span></span><br><span class="line"><span class="comment"> * @param urls 预加载的URL列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)prefetchURLs:(<span class="keyword">nullable</span> <span class="built_in">NSArray</span>&lt;<span class="built_in">NSURL</span> *&gt; *)urls;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分配URL列表以让SDWebImagePrefetcher对预加载进行排队，目前一次下载一张图片，并跳过下载失败的图像，然后进入列表中的下一个图像。任何先前运行的预加载操作都将被取消。</span></span><br><span class="line"><span class="comment"> * currently one image is downloaded at a time,</span></span><br><span class="line"><span class="comment"> * and skips images for failed downloads and proceed to the next image in the list.</span></span><br><span class="line"><span class="comment"> * Any previously-running prefetch operations are canceled.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param urls           预加载的URL列表</span></span><br><span class="line"><span class="comment"> * @param progressBlock   block块在进度更新时被调用;</span></span><br><span class="line"><span class="comment"> *                        第一个参数是已完成（成功或未成功）请求的数量，</span></span><br><span class="line"><span class="comment"> *                        第二个参数是最初请求预加载的图像总数</span></span><br><span class="line"><span class="comment"> * @param completionBlock Block块在预加载完成时被调用</span></span><br><span class="line"><span class="comment"> *                       第一个参数是已完成（成功或未成功）请求的数量，</span></span><br><span class="line"><span class="comment"> *                        第二个参数是跳过的请求数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)prefetchURLs:(<span class="keyword">nullable</span> <span class="built_in">NSArray</span>&lt;<span class="built_in">NSURL</span> *&gt; *)urls</span><br><span class="line">            progress:(<span class="keyword">nullable</span> SDWebImagePrefetcherProgressBlock)progressBlock</span><br><span class="line">           completed:(<span class="keyword">nullable</span> SDWebImagePrefetcherCompletionBlock)completionBlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除并取消排队列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)cancelPrefetching;</span><br></pre></td></tr></table></figure><h3 id="私有属性声明"><a href="#私有属性声明" class="headerlink" title="私有属性声明"></a>私有属性声明</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.h文件manager管理器声明为只读，这里声明为读写类型。实现外部只能访问，内部可读写。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) SDWebImageManager *manager;</span><br><span class="line"><span class="comment">//可以从不同的队列访问</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, atomic, <span class="keyword">nullable</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSURL</span> *&gt; *prefetchURLs; </span><br><span class="line"></span><br><span class="line"><span class="comment">//已请求的数量</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> requestedCount;</span><br><span class="line"><span class="comment">//已跳过的数量</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> skippedCount;</span><br><span class="line"><span class="comment">//已完成的数量</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> finishedCount;</span><br><span class="line"><span class="comment">//已开始的时间</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSTimeInterval</span> startedTime;</span><br><span class="line"><span class="comment">//预加载图片完成代码块</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) SDWebImagePrefetcherCompletionBlock completionBlock;</span><br><span class="line"><span class="comment">//预加载图片进度代码块</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) SDWebImagePrefetcherProgressBlock progressBlock;</span><br></pre></td></tr></table></figure><h3 id="方法实现"><a href="#方法实现" class="headerlink" title="方法实现"></a>方法实现</h3><p>初始化</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)sharedImagePrefetcher &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> once;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">id</span> instance;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;once, ^&#123;</span><br><span class="line">        instance = [<span class="keyword">self</span> new];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithImageManager:[SDWebImageManager new]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)initWithImageManager:(SDWebImageManager *)manager &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) &#123;</span><br><span class="line">        <span class="comment">//图片管理器</span></span><br><span class="line">        _manager = manager;</span><br><span class="line">        </span><br><span class="line">        预加载的SDWebImageOptions选项。 默认为SDWebImageLowPriority。</span><br><span class="line">        _options = SDWebImageLowPriority;</span><br><span class="line">        <span class="comment">//Prefetcher的队列选项。 默认为主队列。</span></span><br><span class="line">        _prefetcherQueue = dispatch_get_main_queue();</span><br><span class="line">        <span class="comment">//同时预加载的最大URL数。 默认为3。</span></span><br><span class="line">        <span class="keyword">self</span>.maxConcurrentDownloads = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性get和set方法</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//同时预加载的最大数的<span class="built_in">set</span>方法</span><br><span class="line">- (void)<span class="built_in">set</span>MaxConcurrentDownloads:(NSUInteger)<span class="keyword">max</span>ConcurrentDownloads &#123;</span><br><span class="line">    <span class="literal">self</span>.manager.imageDownloader.<span class="keyword">max</span>ConcurrentDownloads = <span class="keyword">max</span>ConcurrentDownloads;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//同时预加载的最大数的get方法</span><br><span class="line">- (NSUInteger)<span class="keyword">max</span>ConcurrentDownloads &#123;</span><br><span class="line">    return <span class="literal">self</span>.manager.imageDownloader.<span class="keyword">max</span>ConcurrentDownloads;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>预加载图片实现方法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)startPrefetchingAtIndex:(<span class="built_in">NSUInteger</span>)index &#123;</span><br><span class="line">    <span class="comment">//创建临时变量，用于存储当前的URL</span></span><br><span class="line">    <span class="built_in">NSURL</span> *currentURL;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//同步锁，判断index是否越界，如果越界就返回，否则获取当前的URL，赋值给临时变量currentURL，已请求的数量+1</span></span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="keyword">self</span>.prefetchURLs.count) <span class="keyword">return</span>;</span><br><span class="line">        currentURL = <span class="keyword">self</span>.prefetchURLs[index];</span><br><span class="line">        <span class="keyword">self</span>.requestedCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//图片管理器加载当前URL的图片</span></span><br><span class="line">    [<span class="keyword">self</span>.manager loadImageWithURL:currentURL options:<span class="keyword">self</span>.options progress:<span class="literal">nil</span> completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="built_in">BOOL</span> finished, <span class="built_in">NSURL</span> *imageURL) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果已经完成，返回</span></span><br><span class="line">        <span class="keyword">if</span> (!finished) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//完成的记数+1</span></span><br><span class="line">        <span class="keyword">self</span>.finishedCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果需要过程回调，执行过程回调操作</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.progressBlock) &#123;</span><br><span class="line">            <span class="keyword">self</span>.progressBlock(<span class="keyword">self</span>.finishedCount,(<span class="keyword">self</span>.prefetchURLs).count);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果图片不存在，跳过的记数+1</span></span><br><span class="line">        <span class="keyword">if</span> (!image) &#123;</span><br><span class="line">            <span class="comment">// Add last failed</span></span><br><span class="line">            <span class="keyword">self</span>.skippedCount++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果delegate存在，执行delegate方法</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(imagePrefetcher:didPrefetchURL:finishedCount:totalCount:)]) &#123;</span><br><span class="line">            [<span class="keyword">self</span>.delegate imagePrefetcher:<span class="keyword">self</span></span><br><span class="line">                            didPrefetchURL:currentURL</span><br><span class="line">                             finishedCount:<span class="keyword">self</span>.finishedCount</span><br><span class="line">                                totalCount:<span class="keyword">self</span>.prefetchURLs.count</span><br><span class="line">             ];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果预下载的URLs数量大于已经下载的数量，就说明还有没下载完的任务，继续下载下一个。（这里是使用的递归方法）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.prefetchURLs.count &gt; <span class="keyword">self</span>.requestedCount) &#123;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.prefetcherQueue, ^&#123;</span><br><span class="line">                <span class="comment">// 我们需要调度来避免函数递归调用。 即使对于巨大的URL列表，这也可以防止堆栈溢出</span></span><br><span class="line">                [<span class="keyword">self</span> startPrefetchingAtIndex:<span class="keyword">self</span>.requestedCount];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">self</span>.finishedCount == <span class="keyword">self</span>.requestedCount) &#123; <span class="comment">//如果预下载的URLs数量等于已经下载的数量，说明已经下载完。</span></span><br><span class="line">        </span><br><span class="line">            <span class="comment">//执行预加载完成的delegate方法。</span></span><br><span class="line">            [<span class="keyword">self</span> reportStatus];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果有需要，执行完成block回调</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.completionBlock) &#123;</span><br><span class="line">                <span class="keyword">self</span>.completionBlock(<span class="keyword">self</span>.finishedCount, <span class="keyword">self</span>.skippedCount);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//将self.completionBlock 置空</span></span><br><span class="line">                <span class="keyword">self</span>.completionBlock = <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将self.progressBlock 置空</span></span><br><span class="line">            <span class="keyword">self</span>.progressBlock = <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//预加载完成状态的delegate方法</span></span><br><span class="line">- (<span class="keyword">void</span>)reportStatus &#123;</span><br><span class="line">    <span class="built_in">NSUInteger</span> total = (<span class="keyword">self</span>.prefetchURLs).count;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(imagePrefetcher:didFinishWithTotalCount:skippedCount:)]) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.delegate imagePrefetcher:<span class="keyword">self</span></span><br><span class="line">               didFinishWithTotalCount:(total - <span class="keyword">self</span>.skippedCount)</span><br><span class="line">                          skippedCount:<span class="keyword">self</span>.skippedCount</span><br><span class="line">         ];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分配URL列表使得SDWebImagePrefetcher来安排预加载队列，当前同一时间下载一张图片，忽略下载时间的图片并继续执行列表中的下一张图片。任何之前执行的预加载操作都会被取消。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//urls：预加载的URL列表。</span></span><br><span class="line">- (<span class="keyword">void</span>)prefetchURLs:(<span class="keyword">nullable</span> <span class="built_in">NSArray</span>&lt;<span class="built_in">NSURL</span> *&gt; *)urls &#123;</span><br><span class="line">    [<span class="keyword">self</span> prefetchURLs:urls progress:<span class="literal">nil</span> completed:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)prefetchURLs:(<span class="keyword">nullable</span> <span class="built_in">NSArray</span>&lt;<span class="built_in">NSURL</span> *&gt; *)urls</span><br><span class="line">            progress:(<span class="keyword">nullable</span> SDWebImagePrefetcherProgressBlock)progressBlock</span><br><span class="line">           completed:(<span class="keyword">nullable</span> SDWebImagePrefetcherCompletionBlock)completionBlock &#123;</span><br><span class="line">    <span class="comment">//防止重复的预加载请求</span></span><br><span class="line">    [<span class="keyword">self</span> cancelPrefetching]; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//CFAbsoluteTimeGetCurrent() 返回网络时间同步的时钟时间</span></span><br><span class="line">    <span class="keyword">self</span>.startedTime = <span class="built_in">CFAbsoluteTimeGetCurrent</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//预加载的URL列表</span></span><br><span class="line">    <span class="keyword">self</span>.prefetchURLs = urls;</span><br><span class="line">    </span><br><span class="line">    代码块</span><br><span class="line">    <span class="keyword">self</span>.completionBlock = completionBlock;</span><br><span class="line">    <span class="keyword">self</span>.progressBlock = progressBlock;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果预加载的URL列表为空，直接回调完成代码块，没有完成的urls和没有跳过的urls都传0</span></span><br><span class="line">    <span class="keyword">if</span> (urls.count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (completionBlock) &#123;</span><br><span class="line">            completionBlock(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 从具有最大允许并发性的列表中的第一个图像开始预加载，然后执行预加载操作</span></span><br><span class="line">        <span class="built_in">NSUInteger</span> listCount = <span class="keyword">self</span>.prefetchURLs.count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; <span class="keyword">self</span>.maxConcurrentDownloads &amp;&amp; <span class="keyword">self</span>.requestedCount &lt; listCount; i++) &#123;</span><br><span class="line">            [<span class="keyword">self</span> startPrefetchingAtIndex:i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>防止重复的预加载请求</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)cancelPrefetching &#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.prefetchURLs = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">self</span>.skippedCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">self</span>.requestedCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">self</span>.finishedCount = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.manager cancelAll];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;SDWebImagePrefetcher&lt;/code&gt; 预先下载（预加载）图片，以方便后续使用，主要是用于部分图片需要先行下载并存储的情况。预先取出缓存中的一些URLs以供将来使用。 图像以低优先级下载。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SDWebImagePrefetcher&lt;/code&gt; 设计了两种回调方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;SDWebImagePrefetcherDelegate&lt;/code&gt;&lt;br&gt;用来处理每一个预下载完成的回调，以及所有下载完成的回调 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;block&lt;/code&gt;&lt;br&gt;用来处理整体进度的回调，返回的是下载完成的数量和总数量等&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="读SDWebImage手札" scheme="http://guohuaden.com/categories/%E8%AF%BBSDWebImage%E6%89%8B%E6%9C%AD/"/>
    
    
      <category term="SDWebImage" scheme="http://guohuaden.com/tags/SDWebImage/"/>
    
  </entry>
  
  <entry>
    <title>读 SDWebImage 六（编码器五：SDWebImageGIFCoder）</title>
    <link href="http://guohuaden.com/2018/10/24/Read-SDWebImage-SDWebImageGIFCoder/"/>
    <id>http://guohuaden.com/2018/10/24/Read-SDWebImage-SDWebImageGIFCoder/</id>
    <published>2018-10-24T14:31:13.000Z</published>
    <updated>2018-10-30T07:54:59.419Z</updated>
    
    <content type="html"><![CDATA[<p><code>SDWebImage</code> 内部实现了一个图片解码/编码的图片编码器，用于图片的编解码、压缩。其中涉及到编解码管理（<code>SDWebImageCodersManager</code>）、编解码协议（<code>SDWebImageCoder</code> 和 <code>SDWebImageProgressiveCoder</code> ）、PNG/JPEG/TIFF编解码，解压缩，显示大图（<code>SDWebImageImageIOCoder</code>）、GIF编解码（<code>SDWebImageGIFCoder</code>）、WebP编解码（<code>SDWebImageWebPCoder</code>）以及辅助类（<code>SDWebImageCoderHelper</code>）。</p><p><code>SDWebImageImageIOCoder</code> ：内置编码器,该类遵守了 <code>SDWebImageCoder</code>协议，但并没有遵守 <code>SDWebImageProgressiveCoder</code>协议，说明该类仅针对git图片的编解码，并不支持git图片的逐行解码功能。<a id="more"></a></p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>判断图片格式是否支持编码，该类仅针对动图的操作，所以仅判断图片的格式是否为GIF格式，如果是返回YES，否则返回NO</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">BOOL</span>)canEncodeToFormat:(SDImageFormat)<span class="keyword">format</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">format</span> == SDImageFormatGIF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据给定的图片格式将图片进行编码</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSData</span> *)encodedDataWithImage:(<span class="built_in">UIImage</span> *)image format:(SDImageFormat)format &#123;</span><br><span class="line">    <span class="comment">//如果image不存在，返回nil</span></span><br><span class="line">    <span class="keyword">if</span> (!image) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//该类只支持动图的编解码，如果image的格式不是GIF，返回nil</span></span><br><span class="line">    <span class="keyword">if</span> (format != SDImageFormatGIF) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//临时变量imageData，用来保存图片数据</span></span><br><span class="line">    <span class="built_in">NSMutableData</span> *imageData = [<span class="built_in">NSMutableData</span> data];</span><br><span class="line">    <span class="comment">// 获取GIF图像格式的CFStringRef格式字符串</span></span><br><span class="line">    <span class="built_in">CFStringRef</span> imageUTType = [<span class="built_in">NSData</span> sd_UTTypeFromSDImageFormat:SDImageFormatGIF];</span><br><span class="line">    <span class="comment">// 生成图片对象的SDWebImageFrame类型元素的数组</span></span><br><span class="line">    <span class="built_in">NSArray</span>&lt;SDWebImageFrame *&gt; *frames = [SDWebImageCoderHelper framesFromAnimatedImage:image];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建图像目标。 GIF不支持EXIF图像方向</span></span><br><span class="line">    <span class="built_in">CGImageDestinationRef</span> imageDestination = <span class="built_in">CGImageDestinationCreateWithData</span>((__bridge <span class="built_in">CFMutableDataRef</span>)imageData, imageUTType, frames.count, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果创建失败，返回nil</span></span><br><span class="line">    <span class="keyword">if</span> (!imageDestination) &#123;</span><br><span class="line">        <span class="comment">// Handle failure.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (frames.count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 用于静态单个GIF图片（如果是单帧的动图就直接将图片添加到imageDestination中）</span></span><br><span class="line">        <span class="built_in">CGImageDestinationAddImage</span>(imageDestination, image.CGImage, <span class="literal">nil</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 用于动画的GIF图片</span></span><br><span class="line">        <span class="comment">//// 获取到动图的循环次数</span></span><br><span class="line">        <span class="built_in">NSUInteger</span> loopCount = image.sd_imageLoopCount;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建一个动图属性字典保存循环次数</span></span><br><span class="line">        <span class="built_in">NSDictionary</span> *gifProperties = @&#123;(__bridge <span class="built_in">NSString</span> *)kCGImagePropertyGIFDictionary: @&#123;(__bridge <span class="built_in">NSString</span> *)kCGImagePropertyGIFLoopCount : @(loopCount)&#125;&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 为图像目标设置属性</span></span><br><span class="line">        <span class="built_in">CGImageDestinationSetProperties</span>(imageDestination, (__bridge <span class="built_in">CFDictionaryRef</span>)gifProperties);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//循环每一帧的图拼啊</span></span><br><span class="line">        <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; frames.count; i++) &#123;</span><br><span class="line">             <span class="comment">// 获取SDWebImageFrame对象</span></span><br><span class="line">            SDWebImageFrame *frame = frames[i];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//获取没一帧的显示时间</span></span><br><span class="line">            <span class="keyword">float</span> frameDuration = frame.duration;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//获取每一帧取位图图片</span></span><br><span class="line">            <span class="built_in">CGImageRef</span> frameImageRef = frame.image.CGImage;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建一个临时变量字典保存每一帧的展示时间</span></span><br><span class="line">            <span class="built_in">NSDictionary</span> *frameProperties = @&#123;(__bridge <span class="built_in">NSString</span> *)kCGImagePropertyGIFDictionary : @&#123;(__bridge <span class="built_in">NSString</span> *)kCGImagePropertyGIFDelayTime : @(frameDuration)&#125;&#125;;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将位图和其对应的属性添加到imageDestination中</span></span><br><span class="line">            <span class="built_in">CGImageDestinationAddImage</span>(imageDestination, frameImageRef, (__bridge <span class="built_in">CFDictionaryRef</span>)frameProperties);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果编码失败就返回nil</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CGImageDestinationFinalize</span>(imageDestination) == <span class="literal">NO</span>) &#123;</span><br><span class="line">       </span><br><span class="line">        imageData = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放imageDestination对象</span></span><br><span class="line">    <span class="built_in">CFRelease</span>(imageDestination);</span><br><span class="line">    </span><br><span class="line">    返回图片数据</span><br><span class="line">    <span class="keyword">return</span> [imageData <span class="keyword">copy</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><p>判断是否支持图片数据的解码<br>该类仅针对动图的操作，所以仅判断图片的格式是否为GIF格式，如果是支持该图片数据解码，否则返回NO</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)canDecodeFromData:(nullable <span class="type">NSData</span> *)<span class="class"><span class="keyword">data</span> &#123;</span></span><br><span class="line"><span class="class">    <span class="title">return</span> ([<span class="type">NSData</span> <span class="title">sd_imageFormatForImageData</span>:<span class="title">data</span>] == <span class="type">SDImageFormatGIF</span>);</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><p>将图片数据解码为图片</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)decodedImageWithData:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    <span class="comment">//如果数据为空，返回nil</span></span><br><span class="line">    <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#if SD_MAC</span></span><br><span class="line">    SDAnimatedImageRep *imageRep = [[SDAnimatedImageRep alloc] initWithData:data];</span><br><span class="line">    <span class="built_in">NSImage</span> *animatedImage = [[<span class="built_in">NSImage</span> alloc] initWithSize:imageRep.size];</span><br><span class="line">    [animatedImage addRepresentation:imageRep];</span><br><span class="line">    <span class="keyword">return</span> animatedImage;</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">     <span class="comment">// 生成图片源</span></span><br><span class="line">    <span class="built_in">CGImageSourceRef</span> source = <span class="built_in">CGImageSourceCreateWithData</span>((__bridge <span class="built_in">CFDataRef</span>)data, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//如果图片源不存在，返回nil</span></span><br><span class="line">    <span class="keyword">if</span> (!source) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取子图片数量</span></span><br><span class="line">    size_t count = <span class="built_in">CGImageSourceGetCount</span>(source);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建临时变量，用来保存动图对象</span></span><br><span class="line">    <span class="built_in">UIImage</span> *animatedImage;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果子图片个数不大于2，直接将数据转化成图片</span></span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        animatedImage = [[<span class="built_in">UIImage</span> alloc] initWithData:data];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 创建可变数组保存SDWebImageFrame对象</span></span><br><span class="line">        <span class="built_in">NSMutableArray</span>&lt;SDWebImageFrame *&gt; *frames = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历子图片对象，并将其包装成SDWebImageFrame对象</span></span><br><span class="line">        <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="comment">// 获取指定帧数的相位图</span></span><br><span class="line">            <span class="built_in">CGImageRef</span> imageRef = <span class="built_in">CGImageSourceCreateImageAtIndex</span>(source, i, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">// 如果没获取到就跳过进入下次循环</span></span><br><span class="line">            <span class="keyword">if</span> (!imageRef) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 获取指定帧数的持续时间</span></span><br><span class="line">            <span class="keyword">float</span> duration = [<span class="keyword">self</span> sd_frameDurationAtIndex:i source:source];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 根据相位图生成图片对象</span></span><br><span class="line">            <span class="built_in">UIImage</span> *image = [[<span class="built_in">UIImage</span> alloc] initWithCGImage:imageRef];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 释放相位图</span></span><br><span class="line">            <span class="built_in">CGImageRelease</span>(imageRef);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将一帧的信息封装成SDWebImageFrame对象</span></span><br><span class="line">            SDWebImageFrame *frame = [SDWebImageFrame frameWithImage:image duration:duration];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将封装好的SDWebImageFrame对象添加到数组中保存</span></span><br><span class="line">            [frames addObject:frame];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建临时变量，用来保存循环次数</span></span><br><span class="line">        <span class="built_in">NSUInteger</span> loopCount = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取到图片属性</span></span><br><span class="line">        <span class="built_in">NSDictionary</span> *imageProperties = (__bridge_transfer <span class="built_in">NSDictionary</span> *)<span class="built_in">CGImageSourceCopyProperties</span>(source, <span class="literal">nil</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取到GIF相关的图像属性</span></span><br><span class="line">        <span class="built_in">NSDictionary</span> *gifProperties = [imageProperties valueForKey:(__bridge <span class="built_in">NSString</span> *)kCGImagePropertyGIFDictionary];</span><br><span class="line">        </span><br><span class="line">        如果gifProperties存在</span><br><span class="line">        <span class="keyword">if</span> (gifProperties) &#123;</span><br><span class="line">            <span class="comment">//获取GIF循环次数</span></span><br><span class="line">            <span class="built_in">NSNumber</span> *gifLoopCount = [gifProperties valueForKey:(__bridge <span class="built_in">NSString</span> *)kCGImagePropertyGIFLoopCount];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果可以转换成NSNumber类型，就将获取到的GIF循环次数赋值给loopCount</span></span><br><span class="line">            <span class="keyword">if</span> (gifLoopCount != <span class="literal">nil</span>) &#123;</span><br><span class="line">                loopCount = gifLoopCount.unsignedIntegerValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 利用封装好的SDWebImageFrame对象数组生成动图对象</span></span><br><span class="line">        animatedImage = [SDWebImageCoderHelper animatedImageWithFrames:frames];</span><br><span class="line">        <span class="comment">// 设置动图对象的循环次数</span></span><br><span class="line">        animatedImage.sd_imageLoopCount = loopCount;</span><br><span class="line">        <span class="comment">//设置动图的图片格式</span></span><br><span class="line">        animatedImage.sd_imageFormat = SDImageFormatGIF;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放图片源source</span></span><br><span class="line">    <span class="built_in">CFRelease</span>(source);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回动图</span></span><br><span class="line">    <span class="keyword">return</span> animatedImage;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果执行动图的解压操作，就直接返回该图片，动图不支持解压</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)decompressedImageWithImage:(<span class="built_in">UIImage</span> *)image</span><br><span class="line">                                   data:(<span class="built_in">NSData</span> *__autoreleasing  _Nullable *)data</span><br><span class="line">                                options:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span>*, <span class="built_in">NSObject</span>*&gt;*)optionsDict &#123;</span><br><span class="line">    <span class="comment">// GIF do not decompress</span></span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h3><p>获取动图每一帧的显示时间</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">float</span>)sd_frameDurationAtIndex:(<span class="built_in">NSUInteger</span>)index source:(<span class="built_in">CGImageSourceRef</span>)source &#123;</span><br><span class="line">    <span class="comment">//临时变量每一帧的显示时间，默认为0.1f</span></span><br><span class="line">    <span class="keyword">float</span> frameDuration = <span class="number">0.1</span>f;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取图片源中指定位置的图片属性</span></span><br><span class="line">    <span class="built_in">CFDictionaryRef</span> cfFrameProperties = <span class="built_in">CGImageSourceCopyPropertiesAtIndex</span>(source, index, <span class="literal">nil</span>);</span><br><span class="line">    <span class="comment">//如果获取失败，就返回默认每一帧的显示时间</span></span><br><span class="line">    <span class="keyword">if</span> (!cfFrameProperties) &#123;</span><br><span class="line">        <span class="keyword">return</span> frameDuration;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    获取图片属性字典</span><br><span class="line">    <span class="built_in">NSDictionary</span> *frameProperties = (__bridge <span class="built_in">NSDictionary</span> *)cfFrameProperties;</span><br><span class="line">    <span class="comment">//从图片属性中获取gif属性字典</span></span><br><span class="line">    <span class="built_in">NSDictionary</span> *gifProperties = frameProperties[(<span class="built_in">NSString</span> *)kCGImagePropertyGIFDictionary];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从git属性中获取当前帧的显示时间</span></span><br><span class="line">    <span class="built_in">NSNumber</span> *delayTimeUnclampedProp = gifProperties[(<span class="built_in">NSString</span> *)kCGImagePropertyGIFUnclampedDelayTime];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果当前帧的显示时间不为nil，赋值给frameDuration</span></span><br><span class="line">    <span class="keyword">if</span> (delayTimeUnclampedProp != <span class="literal">nil</span>) &#123;</span><br><span class="line">        frameDuration = [delayTimeUnclampedProp floatValue];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果通过key：kCGImagePropertyGIFUnclampedDelayTime 从gifProperties字典中获取不到当前帧的显示时间，则通过另一个key：kCGImagePropertyGIFDelayTime获取</span></span><br><span class="line">        <span class="built_in">NSNumber</span> *delayTimeProp = gifProperties[(<span class="built_in">NSString</span> *)kCGImagePropertyGIFDelayTime];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果不为空，赋值给赋值给frameDuration</span></span><br><span class="line">        <span class="keyword">if</span> (delayTimeProp != <span class="literal">nil</span>) &#123;</span><br><span class="line">            frameDuration = [delayTimeProp floatValue];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//许多烦人的广告指定0持续时间，以使图像尽快闪现。 我们遵循Firefox的行为，并为指定持续时间&lt;= 10 ms的任何帧使用100 ms的持续时间。</span></span><br><span class="line">    </span><br><span class="line">    如果当前帧显示的时间实现小于<span class="number">11</span>ms，就重新设置为<span class="number">100</span>ms</span><br><span class="line">    <span class="keyword">if</span> (frameDuration &lt; <span class="number">0.011</span>f) &#123;</span><br><span class="line">        frameDuration = <span class="number">0.100</span>f;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放cfFrameProperties</span></span><br><span class="line">    <span class="built_in">CFRelease</span>(cfFrameProperties);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回当前帧显示时间</span></span><br><span class="line">    <span class="keyword">return</span> frameDuration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;SDWebImage&lt;/code&gt; 内部实现了一个图片解码/编码的图片编码器，用于图片的编解码、压缩。其中涉及到编解码管理（&lt;code&gt;SDWebImageCodersManager&lt;/code&gt;）、编解码协议（&lt;code&gt;SDWebImageCoder&lt;/code&gt; 和 &lt;code&gt;SDWebImageProgressiveCoder&lt;/code&gt; ）、PNG/JPEG/TIFF编解码，解压缩，显示大图（&lt;code&gt;SDWebImageImageIOCoder&lt;/code&gt;）、GIF编解码（&lt;code&gt;SDWebImageGIFCoder&lt;/code&gt;）、WebP编解码（&lt;code&gt;SDWebImageWebPCoder&lt;/code&gt;）以及辅助类（&lt;code&gt;SDWebImageCoderHelper&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SDWebImageImageIOCoder&lt;/code&gt; ：内置编码器,该类遵守了 &lt;code&gt;SDWebImageCoder&lt;/code&gt;协议，但并没有遵守 &lt;code&gt;SDWebImageProgressiveCoder&lt;/code&gt;协议，说明该类仅针对git图片的编解码，并不支持git图片的逐行解码功能。
    
    </summary>
    
      <category term="读SDWebImage手札" scheme="http://guohuaden.com/categories/%E8%AF%BBSDWebImage%E6%89%8B%E6%9C%AD/"/>
    
    
      <category term="SDWebImage" scheme="http://guohuaden.com/tags/SDWebImage/"/>
    
  </entry>
  
  <entry>
    <title>读 SDWebImage 六 （编码器四：SDWebImageImageIOCoder）</title>
    <link href="http://guohuaden.com/2018/10/23/Read-SDWebImage-SDWebImageImageIOCoder/"/>
    <id>http://guohuaden.com/2018/10/23/Read-SDWebImage-SDWebImageImageIOCoder/</id>
    <published>2018-10-23T13:57:30.000Z</published>
    <updated>2018-10-30T02:50:13.633Z</updated>
    
    <content type="html"><![CDATA[<p><code>SDWebImage</code> 内部实现了一个图片解码/编码的图片编码器，用于图片的编解码、压缩。其中涉及到编解码管理（<code>SDWebImageCodersManager</code>）、编解码协议（<code>SDWebImageCoder</code>）、PNG/JPEG/TIFF编解码，解压缩，显示大图（<code>SDWebImageImageIOCoder</code>）、GIF编解码（<code>SDWebImageGIFCoder</code>）、WebP编解码（<code>SDWebImageWebPCoder</code>）以及辅助类（<code>SDWebImageCoderHelper</code>）</p><p><code>SDWebImageImageIOCoder</code> ：内置编码器，支持PNG，JPEG，TIFF，支持逐行解码。该类遵守 <code>SDWebImageProgressiveCoder</code>协议。该协议也遵守<code>SDWebImageCoder</code>协议，所以这个类要实现这两个协议的方法。</p><p>  GIF<br>  还支持静态GIF（意思是只处理第一帧）。<br>  要获得完整的GIF支持，我们建议使用<code>FLAnimatedImage</code>或性能较差的<code>SDWebImageGIFCoder</code></p><p>  HEIC<br>  该编码器还支持HEIC格式，因为ImageIO本身支持它。但这取决于系统功能，因此无法在所有设备上运行。<a id="more"></a></p><h3 id="私有静态常量"><a href="#私有静态常量" class="headerlink" title="私有静态常量"></a>私有静态常量</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每像素字节数为4</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> size_t kBytesPerPixel = <span class="number">4</span>;</span><br><span class="line"><span class="comment">//每位字节数为8</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> size_t kBitsPerComponent = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  *设置标志“SDWebImageScaleDownLargeImages”时，解码图像的最大大小（以MB为单位）</span></span><br><span class="line"><span class="comment">  * iPad1和iPhone 3GS的建议值：60。</span></span><br><span class="line"><span class="comment">  * iPad2和iPhone 4的建议值：120。</span></span><br><span class="line"><span class="comment">  * iPhone 3G和iPod 2及早期设备的建议值：30。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">CGFloat</span> kDestImageSizeMB = <span class="number">60.0</span>f;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *当设置标志“SDWebImageScaleDownLargeImages”时，定义用于解码图像的图块的最大大小（以MB为单位）</span></span><br><span class="line"><span class="comment"> * iPad1和iPhone 3GS的建议值：20。</span></span><br><span class="line"><span class="comment"> * iPad2和iPhone 4的建议值：40。</span></span><br><span class="line"><span class="comment"> * iPhone 3G和iPod 2及早期设备的建议值：10。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">CGFloat</span> kSourceImageTileSizeMB = <span class="number">20.0</span>f;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义 1M = 1024.0f * 1024.0f</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">CGFloat</span> kBytesPerMB = <span class="number">1024.0</span>f * <span class="number">1024.0</span>f;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义1MB的像素数是1MB的Bytes数量除以1像素的Bytes数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">CGFloat</span> kPixelsPerMB = kBytesPerMB / kBytesPerPixel;</span><br><span class="line"><span class="comment">//定义解码完的图像的最大像素总数数是解码完的图像最size乘以1MB的像素数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">CGFloat</span> kDestTotalPixels = kDestImageSizeMB * kPixelsPerMB;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义用于解码的图像的最大像素总数是解码的图像的size乘以1MB的像素数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">CGFloat</span> kTileTotalPixels = kSourceImageTileSizeMB * kPixelsPerMB;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义重叠像素大小为2像素</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">CGFloat</span> kDestSeemOverlap = <span class="number">2.0</span>f;</span><br></pre></td></tr></table></figure><h3 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h3><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">//定义了两个变量来保存图像的宽和高</span></span><br><span class="line">        size_t <span class="variable">_width</span>, <span class="variable">_height</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SD_UIKIT || SD_WATCH</span></span><br><span class="line">        <span class="comment">//定义变量记录图片方向</span></span><br><span class="line">        UIImageOrientation <span class="variable">_orientation</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">//定义变量记录图片源</span></span><br><span class="line">        CGImageSourceRef <span class="variable">_imageSource</span>;</span><br></pre></td></tr></table></figure><h3 id="life-cycle"><a href="#life-cycle" class="headerlink" title="life cycle"></a>life cycle</h3><p>单例方法和dealloc方法</p><p>C 语言不能够调用OC中的retain与release，一般的C 语言接口都提供了release函数（比如CGContextRelease(context c)）来管理内存。ARC不会自动调用这些C接口的函数，所以这还是需要我们自己来进行管理的.</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    <span class="comment">//如果CGImageSourceRef类型的_imageSource存在，在dealloc方法中手动释放掉（CGXXX 和CFXXX方法，ARC并不会自动释放，需要手动去释放掉）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (_imageSource) &#123;</span><br><span class="line">        <span class="built_in">CFRelease</span>(_imageSource);</span><br><span class="line">        _imageSource = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单例方法</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)sharedCoder &#123;</span><br><span class="line">    <span class="keyword">static</span> SDWebImageImageIOCoder *coder;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        coder = [[SDWebImageImageIOCoder alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> coder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><h4 id="SDWebImageCoder协议方法"><a href="#SDWebImageCoder协议方法" class="headerlink" title="SDWebImageCoder协议方法"></a><code>SDWebImageCoder</code>协议方法</h4><p>判断是否支持图片数据的解码</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)canDecodeFromData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    <span class="comment">//通过NSData中的扩展方法：sd_imageFormatForImageData 获取图片的格式</span></span><br><span class="line">    <span class="keyword">switch</span> ([<span class="built_in">NSData</span> sd_imageFormatForImageData:data]) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDImageFormatWebP:</span><br><span class="line">            <span class="comment">// 不支持WebP格式图片解码</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        <span class="keyword">case</span> SDImageFormatHEIC:</span><br><span class="line">            <span class="comment">// 检查是否支持HEIC格式图片解码</span></span><br><span class="line">            <span class="keyword">return</span> [[<span class="keyword">self</span> <span class="keyword">class</span>] canDecodeFromHEICFormat];</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过图片数据（ImageData）解码获取图片</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (UIImage *)decodedImageWithData:(NSData *)<span class="keyword">data</span> &#123;</span><br><span class="line">    <span class="comment">//如果data为空，返回nil</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">data</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将imagedata转为图片</span></span><br><span class="line">    UIImage *image = [[UIImage alloc] initWithData:<span class="keyword">data</span>];</span><br><span class="line">    <span class="comment">//设置图片的格式</span></span><br><span class="line">    image.sd_imageFormat = [NSData sd_imageFormatForImageData:<span class="keyword">data</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用原始图片和图片数据解压缩图片</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">使用原始图片和图片数据解压缩图片。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param image 需要压缩的原图片</span></span><br><span class="line"><span class="comment"> @param data 指向原始图像数据的指针。 指针本身是非空的，但图像数据可以为空。 如果需要，此数据将设置为缓存。 如果您不需要同时修改数据，请忽略此参数。</span></span><br><span class="line"><span class="comment"> @param optionsDict 一个包含任何解压缩选项的字典。 通过&#123;SDWebImageCoderScaleDownLargeImagesKey：@（YES）&#125;缩小大图像</span></span><br><span class="line"><span class="comment"> @return 解压缩后的图片</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)decompressedImageWithImage:(<span class="built_in">UIImage</span> *)image</span><br><span class="line">                                   data:(<span class="built_in">NSData</span> *__autoreleasing  _Nullable *)data</span><br><span class="line">                                options:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span>*, <span class="built_in">NSObject</span>*&gt;*)optionsDict &#123;</span><br><span class="line">                                </span><br><span class="line"><span class="comment">//如果是mac，直接返回图片</span></span><br><span class="line"><span class="meta">#if SD_MAC</span></span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是iOS 、osTV、osWatch</span></span><br><span class="line"><span class="meta">#if SD_UIKIT || SD_WATCH</span></span><br><span class="line">    <span class="comment">// 创建变量保存，默认是不缩小</span></span><br><span class="line">    <span class="built_in">BOOL</span> shouldScaleDown = <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果传入选项字典参数</span></span><br><span class="line">    <span class="keyword">if</span> (optionsDict != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">//创建临时变量保存选项值</span></span><br><span class="line">        <span class="built_in">NSNumber</span> *scaleDownLargeImagesOption = <span class="literal">nil</span>;</span><br><span class="line">        <span class="comment">//SDWebImageCoderScaleDownLargeImagesKey对应的value类型为NSNumber，则保存value</span></span><br><span class="line">        <span class="keyword">if</span> ([optionsDict[SDWebImageCoderScaleDownLargeImagesKey] isKindOfClass:[<span class="built_in">NSNumber</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            scaleDownLargeImagesOption = (<span class="built_in">NSNumber</span> *)optionsDict[SDWebImageCoderScaleDownLargeImagesKey];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果选项值不为nil，转换成BOOL类型，并保存</span></span><br><span class="line">        <span class="keyword">if</span> (scaleDownLargeImagesOption != <span class="literal">nil</span>) &#123;</span><br><span class="line">            shouldScaleDown = [scaleDownLargeImagesOption boolValue];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果不需要缩小图片，直接执行解压图片操作</span></span><br><span class="line">    <span class="keyword">if</span> (!shouldScaleDown) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">self</span> sd_decompressedImageWithImage:image];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        如果需要缩小图片，则执行图片的解压和缩小操作</span><br><span class="line">        <span class="built_in">UIImage</span> *scaledDownImage = [<span class="keyword">self</span> sd_decompressedAndScaledDownImageWithImage:image];</span><br><span class="line">        </span><br><span class="line">         <span class="comment">// 如果解压和缩小成功，仍处理数据指针，调用压缩方法</span></span><br><span class="line">        <span class="keyword">if</span> (scaledDownImage &amp;&amp; !<span class="built_in">CGSizeEqualToSize</span>(scaledDownImage.size, image.size)) &#123;</span><br><span class="line">            <span class="comment">//根据图片数据指针得到图片的格式</span></span><br><span class="line">            SDImageFormat format = [<span class="built_in">NSData</span> sd_imageFormatForImageData:*data];</span><br><span class="line">            <span class="comment">//通过缩小的图片和图片格式编码获取imagedata</span></span><br><span class="line">            <span class="built_in">NSData</span> *imageData = [<span class="keyword">self</span> encodedDataWithImage:scaledDownImage format:format];</span><br><span class="line">            <span class="keyword">if</span> (imageData) &#123;</span><br><span class="line">                <span class="comment">// 通过参数回传处理后的图像数据</span></span><br><span class="line">                *data = imageData;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回处理后的图片</span></span><br><span class="line">        <span class="keyword">return</span> scaledDownImage;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SDWebImageProgressiveCoder-协议方法"><a href="#SDWebImageProgressiveCoder-协议方法" class="headerlink" title="SDWebImageProgressiveCoder 协议方法"></a><code>SDWebImageProgressiveCoder</code> 协议方法</h4><p>判断是否支持增量解码某个data数据</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)canIncrementallyDecodeFromData:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    <span class="comment">//获取图片的格式</span></span><br><span class="line">    <span class="keyword">switch</span> ([<span class="built_in">NSData</span> sd_imageFormatForImageData:data]) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDImageFormatWebP:</span><br><span class="line">            <span class="comment">// 不支持WebP逐行解码</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        <span class="keyword">case</span> SDImageFormatHEIC:</span><br><span class="line">            <span class="comment">// 检查HEIC解码兼容性</span></span><br><span class="line">            <span class="keyword">return</span> [[<span class="keyword">self</span> <span class="keyword">class</span>] canDecodeFromHEICFormat];</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// 其他类型就返回YES</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将图片数据增量解码为图片</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)incrementallyDecodedImageWithData:(<span class="built_in">NSData</span> *)data finished:(<span class="built_in">BOOL</span>)finished &#123;</span><br><span class="line">    判断增量图片源是否存在，如果不存在，创建一个新的</span><br><span class="line">    <span class="keyword">if</span> (!_imageSource) &#123;</span><br><span class="line">        _imageSource = <span class="built_in">CGImageSourceCreateIncremental</span>(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">UIImage</span> *image;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//更新数据源，这里必须传递所有数据，而不仅仅是新字节</span></span><br><span class="line">    <span class="built_in">CGImageSourceUpdateData</span>(_imageSource, (__bridge <span class="built_in">CFDataRef</span>)data, finished);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取到图像的宽、高和方向</span></span><br><span class="line">    <span class="keyword">if</span> (_width + _height == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">CFDictionaryRef</span> properties = <span class="built_in">CGImageSourceCopyPropertiesAtIndex</span>(_imageSource, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (properties) &#123;</span><br><span class="line">            <span class="built_in">NSInteger</span> orientationValue = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">CFTypeRef</span> val = <span class="built_in">CFDictionaryGetValue</span>(properties, kCGImagePropertyPixelHeight);</span><br><span class="line">            <span class="keyword">if</span> (val) <span class="built_in">CFNumberGetValue</span>(val, kCFNumberLongType, &amp;_height);</span><br><span class="line">            val = <span class="built_in">CFDictionaryGetValue</span>(properties, kCGImagePropertyPixelWidth);</span><br><span class="line">            <span class="keyword">if</span> (val) <span class="built_in">CFNumberGetValue</span>(val, kCFNumberLongType, &amp;_width);</span><br><span class="line">            val = <span class="built_in">CFDictionaryGetValue</span>(properties, kCGImagePropertyOrientation);</span><br><span class="line">            <span class="keyword">if</span> (val) <span class="built_in">CFNumberGetValue</span>(val, kCFNumberNSIntegerType, &amp;orientationValue);</span><br><span class="line">            <span class="built_in">CFRelease</span>(properties);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//当我们绘制到Core Graphics时，我们会丢失方向信息，这意味着initWithCGIImage生成的图像有时会导致错误定向。 （与didCompleteWithError中的initWithData生成的图像不同。）因此将其保存在此处并稍后传递。</span></span><br><span class="line"><span class="meta">#if SD_UIKIT || SD_WATCH</span></span><br><span class="line">            _orientation = [SDWebImageCoderHelper imageOrientationFromEXIFOrientation:orientationValue];</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (_width + _height &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建位图对象</span></span><br><span class="line">        <span class="built_in">CGImageRef</span> partialImageRef = <span class="built_in">CGImageSourceCreateImageAtIndex</span>(_imageSource, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果存在，则根据该位图生成图片</span></span><br><span class="line">        <span class="keyword">if</span> (partialImageRef) &#123;</span><br><span class="line"><span class="meta">#if SD_UIKIT || SD_WATCH</span></span><br><span class="line">            image = [[<span class="built_in">UIImage</span> alloc] initWithCGImage:partialImageRef scale:<span class="number">1</span> orientation:_orientation];</span><br><span class="line"><span class="meta">#elif SD_MAC</span></span><br><span class="line">            image = [[<span class="built_in">UIImage</span> alloc] initWithCGImage:partialImageRef size:<span class="built_in">NSZeroSize</span>];</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">            <span class="comment">// 位图对象的引用计数-1</span></span><br><span class="line">            <span class="built_in">CGImageRelease</span>(partialImageRef);</span><br><span class="line">            image.sd_imageFormat = [<span class="built_in">NSData</span> sd_imageFormatForImageData:data];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// 如果加载完成就释放掉位图对象，并置空</span></span><br><span class="line">    <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_imageSource) &#123;</span><br><span class="line">            <span class="built_in">CFRelease</span>(_imageSource);</span><br><span class="line">            _imageSource = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回该图片</span></span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="私有方法中的：解压图片-和-解压并按比例缩小图片"><a href="#私有方法中的：解压图片-和-解压并按比例缩小图片" class="headerlink" title="私有方法中的：解压图片 和 解压并按比例缩小图片"></a>私有方法中的：解压图片 和 解压并按比例缩小图片</h4><p>解压图片</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#if SD_UIKIT || SD_WATCH</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)sd_decompressedImageWithImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果图片不需要解码，直接返回image</span></span><br><span class="line">    <span class="keyword">if</span> (![[<span class="keyword">self</span> <span class="keyword">class</span>] shouldDecodeImage:image]) &#123;</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自动释放位图上下文和所有变量以帮助系统在存在内存警告时释放内存。</span></span><br><span class="line">    <span class="comment">//在iOS7上，别忘了调用[[SDImageCache sharedImageCache] clearMemory];</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 建立自动释放池，以帮助系统在收到内存警告时释放内存。</span></span><br><span class="line">    <span class="keyword">@autoreleasepool</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取图片对象的位图图片</span></span><br><span class="line">        <span class="built_in">CGImageRef</span> imageRef = image.CGImage;</span><br><span class="line">        <span class="comment">// 获取图片对象的色彩空间</span></span><br><span class="line">        <span class="built_in">CGColorSpaceRef</span> colorspaceRef = SDCGColorSpaceGetDeviceRGB();</span><br><span class="line">        <span class="built_in">BOOL</span> hasAlpha = SDCGImageRefContainsAlpha(imageRef);</span><br><span class="line">        <span class="comment">//  iOS 显示 Alpha（透明）信息  (BRGA8888/BGRX8888)</span></span><br><span class="line">        <span class="built_in">CGBitmapInfo</span> bitmapInfo = kCGBitmapByteOrder32Host;</span><br><span class="line">        bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;</span><br><span class="line">        </span><br><span class="line">        size_t width = <span class="built_in">CGImageGetWidth</span>(imageRef);</span><br><span class="line">        size_t height = <span class="built_in">CGImageGetHeight</span>(imageRef);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// CGBitmapContextCreate不支持kCGImageAlphaNone。由于此处的原始图像没有alpha信息，因此使用kCGImageAlphaNoneSkipLast创建没有alpha信息的位图图形上下文。</span></span><br><span class="line">        <span class="comment">//创建位图图形上下文</span></span><br><span class="line">        <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>,</span><br><span class="line">                                                     width,</span><br><span class="line">                                                     height,</span><br><span class="line">                                                     kBitsPerComponent,</span><br><span class="line">                                                     <span class="number">0</span>,</span><br><span class="line">                                                     colorspaceRef,</span><br><span class="line">                                                     bitmapInfo);</span><br><span class="line">        <span class="comment">//如果创建失败，直接返回image</span></span><br><span class="line">        <span class="keyword">if</span> (context == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> image;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将图像绘制到上下文中并检索没有alpha的新位图图像</span></span><br><span class="line">        <span class="built_in">CGContextDrawImage</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, height), imageRef);</span><br><span class="line">        <span class="comment">// 生成位图图像</span></span><br><span class="line">        <span class="built_in">CGImageRef</span> imageRefWithoutAlpha = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line">        <span class="comment">// 根据位图图像生成图片对象</span></span><br><span class="line">        <span class="built_in">UIImage</span> *imageWithoutAlpha = [[<span class="built_in">UIImage</span> alloc] initWithCGImage:imageRefWithoutAlpha scale:image.scale orientation:image.imageOrientation];</span><br><span class="line">        <span class="comment">//释放掉上下文</span></span><br><span class="line">        <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line">        <span class="comment">//释放掉位图图片</span></span><br><span class="line">        <span class="built_in">CGImageRelease</span>(imageRefWithoutAlpha);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//返回位图图片</span></span><br><span class="line">        <span class="keyword">return</span> imageWithoutAlpha;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>//解压并按比例缩小图片</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line">- (nullable UIImage *)sd_decompressedAndScaledDownImageWithImage:(nullable UIImage *)<span class="built_in">image</span> &#123;</span><br><span class="line">    <span class="comment">//如果图片不需要解码，直接返回image</span></span><br><span class="line">    <span class="built_in">if</span> (![[self class] shouldDecodeImage:<span class="built_in">image</span>]) &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="built_in">image</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果图片不需要缩小，直接执行解压图片操作</span></span><br><span class="line">    <span class="built_in">if</span> (![[self class] shouldScaleDownImage:<span class="built_in">image</span>]) &#123;</span><br><span class="line">        <span class="built_in">return</span> [self sd_decompressedImageWithImage:<span class="built_in">image</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建图像上下文</span></span><br><span class="line">    CGContextRef destContext;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自动释放位图上下文和所有变量以帮助系统在存在内存警告时释放内存。</span></span><br><span class="line">    <span class="comment">//在iOS7上，别忘了调用[[SDImageCache sharedImageCache] clearMemory];</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 建立自动释放池，以帮助系统在收到内存警告时释放内存</span></span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        <span class="comment">//获取图片对象的位图图片</span></span><br><span class="line">        CGImageRef sourceImageRef = <span class="built_in">image</span>.CGImage;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取图像的总像素数</span></span><br><span class="line">        CGSize sourceResolution = CGSizeZero;</span><br><span class="line">        sourceResolution.<span class="built_in">width</span> = CGImageGetWidth(sourceImageRef);</span><br><span class="line">        sourceResolution.<span class="built_in">height</span> = CGImageGetHeight(sourceImageRef);</span><br><span class="line">        <span class="keyword">float</span> sourceTotalPixels = sourceResolution.<span class="built_in">width</span> * sourceResolution.<span class="built_in">height</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算缩小比例</span></span><br><span class="line">        <span class="keyword">float</span> imageScale = kDestTotalPixels / sourceTotalPixels;</span><br><span class="line">        <span class="comment">// 计算缩小后的尺寸</span></span><br><span class="line">        CGSize destResolution = CGSizeZero;</span><br><span class="line">        destResolution.<span class="built_in">width</span> = (<span class="keyword">int</span>)(sourceResolution.<span class="built_in">width</span>*imageScale);</span><br><span class="line">        destResolution.<span class="built_in">height</span> = (<span class="keyword">int</span>)(sourceResolution.<span class="built_in">height</span>*imageScale);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取色彩空间</span></span><br><span class="line">        CGColorSpaceRef colorspaceRef = SDCGColorSpaceGetDeviceRGB();</span><br><span class="line">        BOOL hasAlpha = SDCGImageRefContainsAlpha(sourceImageRef);</span><br><span class="line">        <span class="comment">// iOS 显示 Alpha（透明）信息 (BGRA8888/BGRX8888)</span></span><br><span class="line">        CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host;</span><br><span class="line">        bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// CGBitmapContextCreate不支持kCGImageAlphaNone。由于此处的原始图像没有alpha信息，因此使用kCGImageAlphaNoneSkipLast创建没有alpha信息的位图图形上下文。</span></span><br><span class="line">        <span class="comment">//创建位图图形上下文</span></span><br><span class="line">        destContext = CGBitmapContextCreate(NULL,</span><br><span class="line">                                            destResolution.<span class="built_in">width</span>,</span><br><span class="line">                                            destResolution.<span class="built_in">height</span>,</span><br><span class="line">                                            kBitsPerComponent,</span><br><span class="line">                                            <span class="number">0</span>,</span><br><span class="line">                                            colorspaceRef,</span><br><span class="line">                                            bitmapInfo);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果创建失败，直接返回image</span></span><br><span class="line">        <span class="built_in">if</span> (destContext == NULL) &#123;</span><br><span class="line">            <span class="built_in">return</span> <span class="built_in">image</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置图像上下文的绘图质量</span></span><br><span class="line">        CGContextSetInterpolationQuality(destContext, kCGInterpolationHigh);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//现在定义用于从输入图像到输出图像的增量blit的矩形的大小。由于iOS从磁盘检索图像数据的方式，我们使用的源块宽度等于源图像的宽度。 iOS必须以全宽“波段”从磁盘解码图像，即使当前图形上下文被剪切为该波段内的子图形也是如此。 因此，我们通过将我们的图块大小设置为输入图像的整个宽度来充分利用由解码操作产生的所有像素数据。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建临时变量保存来源块大小</span></span><br><span class="line">        CGRect sourceTile = CGRectZero;</span><br><span class="line">        <span class="comment">// 来源块的宽度就是原图的宽度</span></span><br><span class="line">        sourceTile.<span class="built_in">size</span>.<span class="built_in">width</span> = sourceResolution.<span class="built_in">width</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 源图块高度是动态的。 由于我们以MB为单位指定了源块的大小，因此请查看输入图像宽度可以为多少像素行。</span></span><br><span class="line">        <span class="comment">// 计算来源块的高度</span></span><br><span class="line">        sourceTile.<span class="built_in">size</span>.<span class="built_in">height</span> = (<span class="keyword">int</span>)(kTileTotalPixels / sourceTile.<span class="built_in">size</span>.<span class="built_in">width</span> );</span><br><span class="line">        <span class="comment">// 设置来源块的X坐标</span></span><br><span class="line">        sourceTile.origin.x = <span class="number">0.0</span>f;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//输出图块与输入图块的比例相同，但缩放为图像比例。</span></span><br><span class="line">        <span class="comment">// 创建历史变量保存目标块大小</span></span><br><span class="line">        CGRect destTile;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 目标块的宽是缩放后的宽</span></span><br><span class="line">        destTile.<span class="built_in">size</span>.<span class="built_in">width</span> = destResolution.<span class="built_in">width</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 目标块的宽是来源块的高乘以缩放比</span></span><br><span class="line">        destTile.<span class="built_in">size</span>.<span class="built_in">height</span> = sourceTile.<span class="built_in">size</span>.<span class="built_in">height</span> * imageScale;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置目标块的X坐标</span></span><br><span class="line">        destTile.origin.x = <span class="number">0.0</span>f;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//来源块与目标似乎重叠成比例。 这是我们组装输出图像时每个图块重叠的像素数量。</span></span><br><span class="line">        <span class="comment">// 计算来源块与目标块的重复区域</span></span><br><span class="line">        <span class="keyword">float</span> sourceSeemOverlap = (<span class="keyword">int</span>)((kDestSeemOverlap/destResolution.<span class="built_in">height</span>)*sourceResolution.<span class="built_in">height</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生成变量保存来源块图像位图</span></span><br><span class="line">        CGImageRef sourceTileImageRef;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算组装输出图像所需的读/写操作次数。</span></span><br><span class="line">        <span class="comment">// 计算需要绘制的次数</span></span><br><span class="line">        <span class="keyword">int</span> iterations = (<span class="keyword">int</span>)( sourceResolution.<span class="built_in">height</span> / sourceTile.<span class="built_in">size</span>.<span class="built_in">height</span> );</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果图块高度未均匀划分图像高度，请添加另一个迭代以考虑剩余像素。</span></span><br><span class="line">        <span class="comment">// 计算剩余像素的高度</span></span><br><span class="line">        <span class="keyword">int</span> remainder = (<span class="keyword">int</span>)sourceResolution.<span class="built_in">height</span> % (<span class="keyword">int</span>)sourceTile.<span class="built_in">size</span>.<span class="built_in">height</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果有剩余像素就将绘制次数加1</span></span><br><span class="line">        <span class="built_in">if</span>(remainder) &#123;</span><br><span class="line">            iterations++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加似乎与切片重叠，但保存原始切片高度以进行y坐标计算。</span></span><br><span class="line">         <span class="comment">// 创建变量保存来源块的高度，用来计算纵坐标的移动</span></span><br><span class="line">        <span class="keyword">float</span> sourceTileHeightMinusOverlap = sourceTile.<span class="built_in">size</span>.<span class="built_in">height</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 来源块高度加上要重复覆盖的高度</span></span><br><span class="line">        sourceTile.<span class="built_in">size</span>.<span class="built_in">height</span> += sourceSeemOverlap;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 目标块高度加上重叠的像素数</span></span><br><span class="line">        destTile.<span class="built_in">size</span>.<span class="built_in">height</span> += kDestSeemOverlap;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 开启循环绘制图像</span></span><br><span class="line">        <span class="built_in">for</span>( <span class="keyword">int</span> y = <span class="number">0</span>; y &lt; iterations; ++y ) &#123;</span><br><span class="line">            <span class="comment">// 建立自动释放池，以帮助系统在收到内存警告时释放内存。</span></span><br><span class="line">            @autoreleasepool &#123;</span><br><span class="line">                <span class="comment">// 计算来源块的纵坐标：来源块的高度乘以当前循环次数，然后加上重复覆盖的高度</span></span><br><span class="line">                sourceTile.origin.y = y * sourceTileHeightMinusOverlap + sourceSeemOverlap;</span><br><span class="line">                </span><br><span class="line">                 <span class="comment">// 计算目标块的纵坐标：目标图像的高度减去要绘制的来源块的高度乘以压缩比，再减去重叠高度</span></span><br><span class="line">                <span class="comment">// 这个地方，来源块的纵坐标是递增的，目标块的纵坐标是递减的，这是因为为UIKit的坐标系和CGContext是镜像关系</span></span><br><span class="line">                destTile.origin.y = destResolution.<span class="built_in">height</span> - (( y + <span class="number">1</span> ) * sourceTileHeightMinusOverlap * imageScale + kDestSeemOverlap);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 按照计算好的尺寸绘制来源块的位图</span></span><br><span class="line">                sourceTileImageRef = CGImageCreateWithImageInRect( sourceImageRef, sourceTile );</span><br><span class="line">                </span><br><span class="line">                 <span class="comment">// 如果是最后一块要绘制，并且这一块是剩余的像素</span></span><br><span class="line">                <span class="built_in">if</span>( y == iterations - <span class="number">1</span> &amp;&amp; remainder ) &#123;</span><br><span class="line">                </span><br><span class="line">                    <span class="comment">// 因为剩余像素的高度是不固定的，所以重新计算目标块的纵坐标</span></span><br><span class="line">                    <span class="keyword">float</span> dify = destTile.<span class="built_in">size</span>.<span class="built_in">height</span>;</span><br><span class="line">                    destTile.<span class="built_in">size</span>.<span class="built_in">height</span> = CGImageGetHeight( sourceTileImageRef ) * imageScale;</span><br><span class="line">                    dify -= destTile.<span class="built_in">size</span>.<span class="built_in">height</span>;</span><br><span class="line">                    destTile.origin.y += dify;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将来源块位图按照计算好的尺寸绘制到目标图像上下文中</span></span><br><span class="line">                CGContextDrawImage( destContext, destTile, sourceTileImageRef );</span><br><span class="line">                </span><br><span class="line">                 <span class="comment">// 释放来源块位图</span></span><br><span class="line">                CGImageRelease( sourceTileImageRef );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据目标图像上下文生成目标图像位图</span></span><br><span class="line">        CGImageRef destImageRef = CGBitmapContextCreateImage(destContext);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 释放目标图像上下文</span></span><br><span class="line">        CGContextRelease(destContext);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果生成位图失败就直接返回图片对象</span></span><br><span class="line">        <span class="built_in">if</span> (destImageRef == NULL) &#123;</span><br><span class="line">            <span class="built_in">return</span> <span class="built_in">image</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">         <span class="comment">// 生成目标图片对象</span></span><br><span class="line">        UIImage *destImage = [[UIImage alloc] initWithCGImage:destImageRef scale:<span class="built_in">image</span>.scale orientation:<span class="built_in">image</span>.imageOrientation];</span><br><span class="line">        </span><br><span class="line">         <span class="comment">// 释放目标图像位图</span></span><br><span class="line">        CGImageRelease(destImageRef);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果生成图片对象失败就直接返回图片对象</span></span><br><span class="line">        <span class="built_in">if</span> (destImage == nil) &#123;</span><br><span class="line">            <span class="built_in">return</span> <span class="built_in">image</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回目标图片对象</span></span><br><span class="line">        <span class="built_in">return</span> destImage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>判断某个图片格式是否支持编码</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果是WebP格式，则不支持编码；HEIC格式：根据canEncodeToHEICFormat方法判断是否支持编码；其他格式都支持编码</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)canEncodeToFormat:(SDImageFormat)format &#123;</span><br><span class="line">    <span class="keyword">switch</span> (format) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDImageFormatWebP:</span><br><span class="line">            <span class="comment">// 不支持WebP格式编码</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        <span class="keyword">case</span> SDImageFormatHEIC:</span><br><span class="line">            <span class="comment">// 检查HEIC编码兼容性</span></span><br><span class="line">            <span class="keyword">return</span> [[<span class="keyword">self</span> <span class="keyword">class</span>] canEncodeToHEICFormat];</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将图片根据给定的格式解码成图片数据（imageData）</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSData</span> *)encodedDataWithImage:(<span class="built_in">UIImage</span> *)image format:(SDImageFormat)format &#123;</span><br><span class="line">    <span class="comment">//如果图片不存在，返回nil</span></span><br><span class="line">    <span class="keyword">if</span> (!image) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果格式类型未识别，判断图片是否含有Alpha通道，如果有则定义为PNG格式，否则定义为JPEG格式</span></span><br><span class="line">    <span class="keyword">if</span> (format == SDImageFormatUndefined) &#123;</span><br><span class="line">        <span class="built_in">BOOL</span> hasAlpha = SDCGImageRefContainsAlpha(image.CGImage);</span><br><span class="line">        <span class="keyword">if</span> (hasAlpha) &#123;</span><br><span class="line">            format = SDImageFormatPNG;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            format = SDImageFormatJPEG;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableData</span> *imageData = [<span class="built_in">NSMutableData</span> data];</span><br><span class="line">    <span class="built_in">CFStringRef</span> imageUTType = [<span class="built_in">NSData</span> sd_UTTypeFromSDImageFormat:format];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据imageData 和 CFStringRef 创建 CGImageDestinationRef对象，如果创建失败，返回nil</span></span><br><span class="line">    <span class="built_in">CGImageDestinationRef</span> imageDestination = <span class="built_in">CGImageDestinationCreateWithData</span>((__bridge <span class="built_in">CFMutableDataRef</span>)imageData, imageUTType, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!imageDestination) &#123;</span><br><span class="line">        <span class="comment">// Handle failure.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建字典对象保存编码参数</span></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *properties = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line"><span class="meta">#if SD_UIKIT || SD_WATCH</span></span><br><span class="line">    <span class="comment">//// 获取图片的方向</span></span><br><span class="line">    <span class="built_in">NSInteger</span> exifOrientation = [SDWebImageCoderHelper exifOrientationFromImageOrientation:image.imageOrientation];</span><br><span class="line">    <span class="comment">//设置方向参数</span></span><br><span class="line">    [properties setValue:@(exifOrientation) forKey:(__bridge <span class="built_in">NSString</span> *)kCGImagePropertyOrientation];</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加图片位图对象到创建的CGImageDestinationRef对象中</span></span><br><span class="line">    <span class="built_in">CGImageDestinationAddImage</span>(imageDestination, image.CGImage, (__bridge <span class="built_in">CFDictionaryRef</span>)properties);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果编码失败就返回空</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CGImageDestinationFinalize</span>(imageDestination) == <span class="literal">NO</span>) &#123;</span><br><span class="line">        <span class="comment">// Handle failure.</span></span><br><span class="line">        imageData = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放掉imageDestination对象</span></span><br><span class="line">    <span class="built_in">CFRelease</span>(imageDestination);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回</span></span><br><span class="line">    <span class="keyword">return</span> [imageData <span class="keyword">copy</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="私有方法（辅助方法）"><a href="#私有方法（辅助方法）" class="headerlink" title="私有方法（辅助方法）"></a>私有方法（辅助方法）</h3><ol><li>是否需要解压图片<br>（如果图片为动图或不存在，不解压图片，否则解压图片）</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)shouldDecodeImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image &#123;</span><br><span class="line">    <span class="comment">//如果图片为空，返回NO</span></span><br><span class="line">    <span class="keyword">if</span> (image == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果图片为动图，返回NO</span></span><br><span class="line">    <span class="keyword">if</span> (image.images != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    否则返回<span class="literal">YES</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>是否支持<code>HEIC</code>格式类型的图片解码</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)canDecodeFromHEICFormat &#123;</span><br><span class="line">    <span class="comment">//临时静态变量 canDecode 为 NO</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">BOOL</span> canDecode = <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//忽略-Wunguarded-availability警告   </span></span><br><span class="line"><span class="meta">#pragma clang diagnostic push</span></span><br><span class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Wunguarded-availability"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是iWatch 或者 SIMULATOR ，则不支持</span></span><br><span class="line"><span class="meta">#if TARGET_OS_SIMULATOR || SD_WATCH  //iWatch</span></span><br><span class="line">        canDecode = <span class="literal">NO</span>;</span><br><span class="line">        </span><br><span class="line"><span class="meta">#elif SD_MAC  //mac</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取进程信息对象</span></span><br><span class="line">        <span class="built_in">NSProcessInfo</span> *processInfo = [<span class="built_in">NSProcessInfo</span> processInfo];</span><br><span class="line">        <span class="keyword">if</span> ([processInfo respondsToSelector:<span class="keyword">@selector</span>(operatingSystemVersion)]) &#123;</span><br><span class="line">            <span class="comment">//通过进程信息对象获取操作系统版本。判断macOS系统版本10.13+，则支持HEIC类型图像的解码</span></span><br><span class="line">            canDecode = processInfo.operatingSystemVersion.minorVersion &gt;= <span class="number">13</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            canDecode = <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#elif SD_UIKIT //iOS 和 tvOS</span></span><br><span class="line">        <span class="comment">//获取进程信息对象</span></span><br><span class="line">        <span class="built_in">NSProcessInfo</span> *processInfo = [<span class="built_in">NSProcessInfo</span> processInfo];</span><br><span class="line">        <span class="keyword">if</span> ([processInfo respondsToSelector:<span class="keyword">@selector</span>(operatingSystemVersion)]) &#123;</span><br><span class="line">            <span class="comment">//通过进程信息对象获取操作系统版本。判断操作系统版本是iOS 11+就支持HEIC类型图像的解码</span></span><br><span class="line">            canDecode = processInfo.operatingSystemVersion.majorVersion &gt;= <span class="number">11</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            canDecode = <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"><span class="meta">#pragma clang diagnostic pop</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> canDecode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>是否支持<code>HEIC</code>格式类型的图片编码</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)canEncodeToHEICFormat &#123;</span><br><span class="line">    <span class="comment">//临时静态变量 canDecode 为 NO</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">BOOL</span> canEncode = <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="built_in">NSMutableData</span> *imageData = [<span class="built_in">NSMutableData</span> data];</span><br><span class="line">        <span class="built_in">CFStringRef</span> imageUTType = [<span class="built_in">NSData</span> sd_UTTypeFromSDImageFormat:SDImageFormatHEIC];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建一个CGImageDestinationRef对象，如果该对象可以创建成功，则需要编码，否则不需要</span></span><br><span class="line">        <span class="built_in">CGImageDestinationRef</span> imageDestination = <span class="built_in">CGImageDestinationCreateWithData</span>((__bridge <span class="built_in">CFMutableDataRef</span>)imageData, imageUTType, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (!imageDestination) &#123;</span><br><span class="line">            <span class="comment">// Can't encode to HEIC</span></span><br><span class="line">            canEncode = <span class="literal">NO</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Can encode to HEIC</span></span><br><span class="line">            <span class="built_in">CFRelease</span>(imageDestination);</span><br><span class="line">            canEncode = <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> canEncode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>是否应该缩小图片</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#if SD_UIKIT || SD_WATCH</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)shouldScaleDownImage:(<span class="keyword">nonnull</span> <span class="built_in">UIImage</span> *)image &#123;</span><br><span class="line">    <span class="built_in">BOOL</span> shouldScaleDown = <span class="literal">YES</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取图片的位图图像</span></span><br><span class="line">    <span class="built_in">CGImageRef</span> sourceImageRef = image.CGImage;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取到位图图像的宽和高</span></span><br><span class="line">    <span class="built_in">CGSize</span> sourceResolution = <span class="built_in">CGSizeZero</span>;</span><br><span class="line">    sourceResolution.width = <span class="built_in">CGImageGetWidth</span>(sourceImageRef);</span><br><span class="line">    sourceResolution.height = <span class="built_in">CGImageGetHeight</span>(sourceImageRef);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计算图片的总像素数</span></span><br><span class="line">    <span class="keyword">float</span> sourceTotalPixels = sourceResolution.width * sourceResolution.height;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//图片的压缩比： 最大像素数 / 图片的总像素数</span></span><br><span class="line">    <span class="keyword">float</span> imageScale = kDestTotalPixels / sourceTotalPixels;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果压缩比小于1，返回YES，否则返回NO</span></span><br><span class="line">    <span class="keyword">if</span> (imageScale &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        shouldScaleDown = <span class="literal">YES</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        shouldScaleDown = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> shouldScaleDown;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;SDWebImage&lt;/code&gt; 内部实现了一个图片解码/编码的图片编码器，用于图片的编解码、压缩。其中涉及到编解码管理（&lt;code&gt;SDWebImageCodersManager&lt;/code&gt;）、编解码协议（&lt;code&gt;SDWebImageCoder&lt;/code&gt;）、PNG/JPEG/TIFF编解码，解压缩，显示大图（&lt;code&gt;SDWebImageImageIOCoder&lt;/code&gt;）、GIF编解码（&lt;code&gt;SDWebImageGIFCoder&lt;/code&gt;）、WebP编解码（&lt;code&gt;SDWebImageWebPCoder&lt;/code&gt;）以及辅助类（&lt;code&gt;SDWebImageCoderHelper&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SDWebImageImageIOCoder&lt;/code&gt; ：内置编码器，支持PNG，JPEG，TIFF，支持逐行解码。该类遵守 &lt;code&gt;SDWebImageProgressiveCoder&lt;/code&gt;协议。该协议也遵守&lt;code&gt;SDWebImageCoder&lt;/code&gt;协议，所以这个类要实现这两个协议的方法。&lt;/p&gt;
&lt;p&gt;  GIF&lt;br&gt;  还支持静态GIF（意思是只处理第一帧）。&lt;br&gt;  要获得完整的GIF支持，我们建议使用&lt;code&gt;FLAnimatedImage&lt;/code&gt;或性能较差的&lt;code&gt;SDWebImageGIFCoder&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;  HEIC&lt;br&gt;  该编码器还支持HEIC格式，因为ImageIO本身支持它。但这取决于系统功能，因此无法在所有设备上运行。
    
    </summary>
    
      <category term="读SDWebImage手札" scheme="http://guohuaden.com/categories/%E8%AF%BBSDWebImage%E6%89%8B%E6%9C%AD/"/>
    
    
      <category term="SDWebImage" scheme="http://guohuaden.com/tags/SDWebImage/"/>
    
  </entry>
  
  <entry>
    <title>读 SDWebImage 六 （编码器三：SDWebImageCodersManager）</title>
    <link href="http://guohuaden.com/2018/10/18/Read-SDWebImage-SDWebImageCodersManager/"/>
    <id>http://guohuaden.com/2018/10/18/Read-SDWebImage-SDWebImageCodersManager/</id>
    <published>2018-10-18T12:48:55.000Z</published>
    <updated>2018-10-29T09:59:10.285Z</updated>
    
    <content type="html"><![CDATA[<p><code>SDWebImage</code> 内部实现了一个图片解码/编码的图片编解码器，用于图片的编解码、压缩。其中涉及到编解码管理（<code>SDWebImageCodersManager</code>）、编解码协议（<code>SDWebImageCoder</code>）、PNG/JPEG/TIFF编解码，解压缩，显示大图（<code>SDWebImageImageIOCoder</code>）、GIF编解码（<code>SDWebImageGIFCoder</code>）、WebP编解码（<code>SDWebImageWebPCoder</code>）以及辅助类（<code>SDWebImageCoderHelper</code>）</p><h3 id="编解码管理（-SDWebImageCodersManager-）"><a href="#编解码管理（-SDWebImageCodersManager-）" class="headerlink" title="编解码管理（ SDWebImageCodersManager ）"></a>编解码管理（ <code>SDWebImageCodersManager</code> ）</h3><p>编解码管理器，整体编解码器的入口，该类遵守了 <code>SDWebImageCoder</code> 协议，说明这个类可以提供基本的编解码功能 。编解码器数组是一个优先级队列，也意味着处理多个图片编解码任务时新添加的编解码器将具有最高优先级（即被先调用）<a id="more"></a></p><h4 id="声明属性和方法"><a href="#声明属性和方法" class="headerlink" title="声明属性和方法"></a>声明属性和方法</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 单例初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)sharedInstance;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 所有的编解码器都在这个编解码器管理中（编码器数组）这个编解码器数组是一个优先级对列, 这意味着最后添加的编解码器拥有最高的优先级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readwrite</span>, <span class="keyword">nullable</span>) <span class="built_in">NSArray</span>&lt;<span class="keyword">id</span>&lt;SDWebImageCoder&gt;&gt; *coders;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 在编解码器数组的末尾添加一个新的编解码器。 新添加的编解码器优先级最高。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param coder 需添加的coder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)addCoder:(<span class="keyword">nonnull</span> <span class="keyword">id</span>&lt;SDWebImageCoder&gt;)coder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 在编解码器数组中移除编码器</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param coder 需移除的coder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)removeCoder:(<span class="keyword">nonnull</span> <span class="keyword">id</span>&lt;SDWebImageCoder&gt;)coder;</span><br></pre></td></tr></table></figure><h4 id="初始化方法实现"><a href="#初始化方法实现" class="headerlink" title="初始化方法实现"></a>初始化方法实现</h4><p>初始化</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单例</span></span><br><span class="line">+ (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)sharedInstance &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> once;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">id</span> instance;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;once, ^&#123;</span><br><span class="line">        instance = [<span class="keyword">self</span> new];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="comment">// 初始化默认的编解码器，默认编码器只有SDWebImageImageIOCoder类型的</span></span><br><span class="line">        <span class="built_in">NSMutableArray</span>&lt;<span class="keyword">id</span>&lt;SDWebImageCoder&gt;&gt; *mutableCoders = [@[[SDWebImageImageIOCoder sharedCoder]] mutableCopy];</span><br><span class="line"><span class="meta">#ifdef SD_WEBP</span></span><br><span class="line">        <span class="comment">//如果是WEBP，就添加SDWebImageWebPCoder单例</span></span><br><span class="line">        [mutableCoders addObject:[SDWebImageWebPCoder sharedCoder]];</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">        _coders = [mutableCoders <span class="keyword">copy</span>];</span><br><span class="line">        _codersLock = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编码器IO操作"><a href="#编码器IO操作" class="headerlink" title="编码器IO操作"></a>编码器IO操作</h4><p>添加编码器</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addCoder:(<span class="keyword">nonnull</span> <span class="keyword">id</span>&lt;SDWebImageCoder&gt;)coder &#123;</span><br><span class="line">    <span class="comment">//判断要添加的编解码器是否遵守SDWebImageCoder协议，以提供最基本的编解码功能</span></span><br><span class="line">    <span class="comment">//如果不遵守SDWebImageCoder协议，返回</span></span><br><span class="line">    <span class="keyword">if</span> (![coder conformsToProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">SDWebImageCoder</span>)]) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LOCK(<span class="keyword">self</span>.codersLock);</span><br><span class="line">    <span class="comment">//临时变量，编解码器数组，如果不存在，重新初始化一个</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span>&lt;<span class="keyword">id</span>&lt;SDWebImageCoder&gt;&gt; *mutableCoders = [<span class="keyword">self</span>.coders mutableCopy];</span><br><span class="line">    <span class="keyword">if</span> (!mutableCoders) &#123;</span><br><span class="line">        mutableCoders = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加新的coder</span></span><br><span class="line">    [mutableCoders addObject:coder];</span><br><span class="line">    <span class="comment">//重新赋值给self.coders</span></span><br><span class="line">    <span class="keyword">self</span>.coders = [mutableCoders <span class="keyword">copy</span>];</span><br><span class="line">    UNLOCK(<span class="keyword">self</span>.codersLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>移除编码器</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)removeCoder:(<span class="keyword">nonnull</span> <span class="keyword">id</span>&lt;SDWebImageCoder&gt;)coder &#123;</span><br><span class="line">    <span class="comment">//判断要添加的编解码器是否遵守SDWebImageCoder协议，以提供最基本的编解码功能</span></span><br><span class="line">    <span class="comment">//如果不遵守SDWebImageCoder协议，返回</span></span><br><span class="line">    <span class="keyword">if</span> (![coder conformsToProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">SDWebImageCoder</span>)]) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LOCK(<span class="keyword">self</span>.codersLock);</span><br><span class="line">    <span class="comment">//临时变量，编解码器数组，使其等于self.coders（深拷贝）</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span>&lt;<span class="keyword">id</span>&lt;SDWebImageCoder&gt;&gt; *mutableCoders = [<span class="keyword">self</span>.coders mutableCopy];</span><br><span class="line">    <span class="comment">//移除编解码器coder</span></span><br><span class="line">    [mutableCoders removeObject:coder];</span><br><span class="line">     <span class="comment">//重新赋值给self.coders</span></span><br><span class="line">    <span class="keyword">self</span>.coders = [mutableCoders <span class="keyword">copy</span>];</span><br><span class="line">    UNLOCK(<span class="keyword">self</span>.codersLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SDWebImageCoder协议方法实现"><a href="#SDWebImageCoder协议方法实现" class="headerlink" title="SDWebImageCoder协议方法实现"></a>SDWebImageCoder协议方法实现</h4><p>解码协议实现</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 如果此编解码器可以解码某些data，返回YES，否则，它应该传递给另一个编码器</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> @param data 需要解码的图片数据</span></span><br><span class="line"><span class="comment"> @return 如果此编解码器可以解码图片数据，返回YES，否则返回NO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)canDecodeFromData:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    LOCK(<span class="keyword">self</span>.codersLock);</span><br><span class="line">    <span class="comment">//临时变量，编解码器数组，赋值等于 self.coders</span></span><br><span class="line">    <span class="built_in">NSArray</span>&lt;<span class="keyword">id</span>&lt;SDWebImageCoder&gt;&gt; *coders = <span class="keyword">self</span>.coders;</span><br><span class="line">    UNLOCK(<span class="keyword">self</span>.codersLock);</span><br><span class="line">    <span class="comment">//倒序遍历编解码器数组（倒序的原因是：编解码器数组中最新添加的具有最高优先级）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">id</span>&lt;SDWebImageCoder&gt; coder <span class="keyword">in</span> coders.reverseObjectEnumerator) &#123;</span><br><span class="line">        <span class="comment">//判断，如果其中有编解码器能够解码，就返回YES，否则返回NO</span></span><br><span class="line">        <span class="keyword">if</span> ([coder canDecodeFromData:data]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 将图片数据解码为图片。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> @param data 需要解码的图片数据</span></span><br><span class="line"><span class="comment"> @return 解码后得到的图片</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)decodedImageWithData:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    LOCK(<span class="keyword">self</span>.codersLock);</span><br><span class="line">    <span class="built_in">NSArray</span>&lt;<span class="keyword">id</span>&lt;SDWebImageCoder&gt;&gt; *coders = <span class="keyword">self</span>.coders;</span><br><span class="line">    UNLOCK(<span class="keyword">self</span>.codersLock);</span><br><span class="line">    <span class="comment">//倒序遍历编解码器列表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">id</span>&lt;SDWebImageCoder&gt; coder <span class="keyword">in</span> coders.reverseObjectEnumerator) &#123;</span><br><span class="line">        <span class="comment">//判断，如果其中有编解码器能够解码，就执行解码操作，否则返回Image为nil</span></span><br><span class="line">        <span class="keyword">if</span> ([coder canDecodeFromData:data]) &#123;</span><br><span class="line">            <span class="keyword">return</span> [coder decodedImageWithData:data];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">使用原始图片和图片数据解压缩图片。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param image 需要压缩的原图片</span></span><br><span class="line"><span class="comment"> @param data 指向原始图像数据的指针。 指针本身是非空的，但图像数据可以为空。 如果需要，此数据将设置为缓存。 如果您不需要同时修改数据，请忽略此参数。</span></span><br><span class="line"><span class="comment"> @param optionsDict 一个包含任何解压缩选项的字典。 通过&#123;SDWebImageCoderScaleDownLargeImagesKey：@（YES）&#125;缩小大图像</span></span><br><span class="line"><span class="comment"> @return 解压缩后的图片</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)decompressedImageWithImage:(<span class="built_in">UIImage</span> *)image</span><br><span class="line">                                   data:(<span class="built_in">NSData</span> *__autoreleasing  _Nullable *)data</span><br><span class="line">                                options:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span>*, <span class="built_in">NSObject</span>*&gt;*)optionsDict &#123;</span><br><span class="line">    <span class="comment">//如果image不存在，返回nil</span></span><br><span class="line">    <span class="keyword">if</span> (!image) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LOCK(<span class="keyword">self</span>.codersLock);</span><br><span class="line">    <span class="built_in">NSArray</span>&lt;<span class="keyword">id</span>&lt;SDWebImageCoder&gt;&gt; *coders = <span class="keyword">self</span>.coders;</span><br><span class="line">    UNLOCK(<span class="keyword">self</span>.codersLock);</span><br><span class="line">    <span class="comment">//倒序遍历编解码器列表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">id</span>&lt;SDWebImageCoder&gt; coder <span class="keyword">in</span> coders.reverseObjectEnumerator) &#123;</span><br><span class="line">        <span class="comment">//如果其中有编解码器可以解码，执行解压缩图片操作，并返回解压缩后的图片</span></span><br><span class="line">        <span class="keyword">if</span> ([coder canDecodeFromData:*data]) &#123;</span><br><span class="line">            <span class="comment">//解压缩图片操作</span></span><br><span class="line">            <span class="built_in">UIImage</span> *decompressedImage = [coder decompressedImageWithImage:image data:data options:optionsDict];</span><br><span class="line">            decompressedImage.sd_imageFormat = image.sd_imageFormat;</span><br><span class="line">            <span class="keyword">return</span> decompressedImage;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编码协议实现</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 如果此编码器可以编码某些图片格式，返回YES，否则，它应该传递给另一个编码器</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> @param format 图片格式</span></span><br><span class="line"><span class="comment"> @return 如果此编码器可以编码图片格式，返回YES，否则返回NO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)canEncodeToFormat:(SDImageFormat)format &#123;</span><br><span class="line">    LOCK(<span class="keyword">self</span>.codersLock);</span><br><span class="line">    <span class="built_in">NSArray</span>&lt;<span class="keyword">id</span>&lt;SDWebImageCoder&gt;&gt; *coders = <span class="keyword">self</span>.coders;</span><br><span class="line">    UNLOCK(<span class="keyword">self</span>.codersLock);</span><br><span class="line">    <span class="comment">//倒序遍历编解码器列表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">id</span>&lt;SDWebImageCoder&gt; coder <span class="keyword">in</span> coders.reverseObjectEnumerator) &#123;</span><br><span class="line">        <span class="comment">//判断，如果其中有编解码器能够编码图片格式，就返回YES，否则返回NO</span></span><br><span class="line">        <span class="keyword">if</span> ([coder canEncodeToFormat:format]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 将图片编码为图片数据（imagedata）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param image 需要编码的图片</span></span><br><span class="line"><span class="comment"> @param format 要编码的图片格式, 也有可能是 `SDImageFormatUndefined` 格式（未识别格式）</span></span><br><span class="line"><span class="comment"> @return The encoded image data</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">NSData</span> *)encodedDataWithImage:(<span class="built_in">UIImage</span> *)image format:(SDImageFormat)format &#123;</span><br><span class="line">    <span class="comment">//如果image不存在，返回nil</span></span><br><span class="line">    <span class="keyword">if</span> (!image) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LOCK(<span class="keyword">self</span>.codersLock);</span><br><span class="line">    <span class="built_in">NSArray</span>&lt;<span class="keyword">id</span>&lt;SDWebImageCoder&gt;&gt; *coders = <span class="keyword">self</span>.coders;</span><br><span class="line">    UNLOCK(<span class="keyword">self</span>.codersLock);</span><br><span class="line">    <span class="comment">//倒序遍历编解码器列表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">id</span>&lt;SDWebImageCoder&gt; coder <span class="keyword">in</span> coders.reverseObjectEnumerator) &#123;</span><br><span class="line">        <span class="comment">//判断，如果其中有编解码器能够编码图片格式，就执行将图片以format格式编码为data操作，并返回imagedata</span></span><br><span class="line">        <span class="keyword">if</span> ([coder canEncodeToFormat:format]) &#123;</span><br><span class="line">            <span class="comment">// 将图片编码为图片数据（imagedata）</span></span><br><span class="line">            <span class="keyword">return</span> [coder encodedDataWithImage:image format:format];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;SDWebImage&lt;/code&gt; 内部实现了一个图片解码/编码的图片编解码器，用于图片的编解码、压缩。其中涉及到编解码管理（&lt;code&gt;SDWebImageCodersManager&lt;/code&gt;）、编解码协议（&lt;code&gt;SDWebImageCoder&lt;/code&gt;）、PNG/JPEG/TIFF编解码，解压缩，显示大图（&lt;code&gt;SDWebImageImageIOCoder&lt;/code&gt;）、GIF编解码（&lt;code&gt;SDWebImageGIFCoder&lt;/code&gt;）、WebP编解码（&lt;code&gt;SDWebImageWebPCoder&lt;/code&gt;）以及辅助类（&lt;code&gt;SDWebImageCoderHelper&lt;/code&gt;）&lt;/p&gt;
&lt;h3 id=&quot;编解码管理（-SDWebImageCodersManager-）&quot;&gt;&lt;a href=&quot;#编解码管理（-SDWebImageCodersManager-）&quot; class=&quot;headerlink&quot; title=&quot;编解码管理（ SDWebImageCodersManager ）&quot;&gt;&lt;/a&gt;编解码管理（ &lt;code&gt;SDWebImageCodersManager&lt;/code&gt; ）&lt;/h3&gt;&lt;p&gt;编解码管理器，整体编解码器的入口，该类遵守了 &lt;code&gt;SDWebImageCoder&lt;/code&gt; 协议，说明这个类可以提供基本的编解码功能 。编解码器数组是一个优先级队列，也意味着处理多个图片编解码任务时新添加的编解码器将具有最高优先级（即被先调用）
    
    </summary>
    
      <category term="读SDWebImage手札" scheme="http://guohuaden.com/categories/%E8%AF%BBSDWebImage%E6%89%8B%E6%9C%AD/"/>
    
    
      <category term="SDWebImage" scheme="http://guohuaden.com/tags/SDWebImage/"/>
    
  </entry>
  
  <entry>
    <title>读 SDWebImage  六 （编码器二：SDWebImageCoderHelper  以及动图处理使用到的 SDWebImageFrame）</title>
    <link href="http://guohuaden.com/2018/10/15/Read-SDWebImage-SDWebImageCoderHelper/"/>
    <id>http://guohuaden.com/2018/10/15/Read-SDWebImage-SDWebImageCoderHelper/</id>
    <published>2018-10-15T13:52:22.000Z</published>
    <updated>2018-10-26T02:52:32.450Z</updated>
    
    <content type="html"><![CDATA[<p><code>SDWebImage</code> 内部实现了一个图片解码/编码的图片编码器，用于图片的编解码、压缩。其中涉及到编解码管理（<code>SDWebImageCodersManager</code>）、编解码协议（<code>SDWebImageCoder</code>）、PNG/JPEG/TIFF编解码，解压缩，显示大图（<code>SDWebImageImageIOCoder</code>）、GIF编解码（<code>SDWebImageGIFCoder</code>）、WebP编解码（<code>SDWebImageWebPCoder</code>）以及辅助类（<code>SDWebImageCoderHelper</code>）</p><p>本篇只做 <code>SDWebImageCoderHelper</code> 类的分析。该类作为辅助类，主要实现了两个功能：动图处理 和 图片方向处理。每个功能有两种方法，均为互逆方法。</p><a id="more"></a><h4 id="SDWebImageFrame类对象"><a href="#SDWebImageFrame类对象" class="headerlink" title="SDWebImageFrame类对象"></a><code>SDWebImageFrame</code>类对象</h4><p>在动图处理期间，使用到了 <code>SDWebImageFrame</code> 对象，该对象是使用单独的类实现的，在GIF等动态图使用中作为每一帧的显示作用。该类用于通过<code>SDWebImageCoderHelper</code>中的<code>animatedImageWithFrames</code>创建动画图片。 如果需要指定动画图片循环计数，请在“UIImage + MultiFormat”中使用<code>sd_imageLoopCount</code>属性。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 当前帧的图片</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>, <span class="keyword">nonnull</span>) <span class="built_in">UIImage</span> *image;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">要显示的当前帧的持续时间。 数字是秒而不是毫秒。不应将此值设置为零。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">assign</span>) <span class="built_in">NSTimeInterval</span> duration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">使用指定图片和持续时间创建框架实例</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param image 当前帧的图片</span></span><br><span class="line"><span class="comment"> @param duration 当前帧的持续时间</span></span><br><span class="line"><span class="comment"> @return 返回框架实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">instancetype</span> _Nonnull)frameWithImage:(<span class="built_in">UIImage</span> * _Nonnull)image duration:(<span class="built_in">NSTimeInterval</span>)duration;</span><br></pre></td></tr></table></figure><p>初始化方法实现</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (instance<span class="keyword">type</span>)frameWithImage:(<span class="type">UIImage</span> *)image duration:(<span class="type">NSTimeInterval</span>)duration &#123;</span><br><span class="line">    <span class="type">SDWebImageFrame</span> *frame = [[<span class="type">SDWebImageFrame</span> alloc] init];</span><br><span class="line">    frame.image = image;</span><br><span class="line">    frame.duration = duration;</span><br><span class="line">    </span><br><span class="line">    return frame;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动图处理"><a href="#动图处理" class="headerlink" title="动图处理"></a>动图处理</h4><p>根据SDWebImageFrame帧数组返回动图</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 根据SDWebImageFrame帧数组返回动图</span><br><span class="line">  对于UIKit，这将应用补丁，然后创建动画UIImage。 补丁是因为<span class="string">`+ [UIImage animatedImageWithImages：duration：]`</span>只使用每个图片的平均持续时间。 因此，如果不同的帧具有不同的持续时间，则不起作用 因此，我们重复指定帧的指定帧以使其工作。</span><br><span class="line">  对于AppKit，NSImage不支持GIF以外的动画。 这将尝试将帧编码为GIF格式，然后创建用于渲染的动画NSImage。 注意，如果输入帧包含完整的Alpha通道，动画图片可能会丢失一些细节，因为GIF仅支持<span class="number">1</span>位alpha通道。 （<span class="number">1</span>个像素，透明或不透明）</span><br><span class="line"></span><br><span class="line"> @param frames SDWebImageFrame帧数组. 如果数组为空或者<span class="literal">nil</span>，返回<span class="literal">nil</span></span><br><span class="line"> @<span class="keyword">return</span> 用于在UIImageView（UIKit）或NSImageView（AppKit）上渲染的动画图片</span><br><span class="line"> *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">+ (UIImage * _Nullable)animatedImageWithFrames:(NSArray&lt;SDWebImageFrame *&gt; * _Nullable)frames;</span></span><br></pre></td></tr></table></figure><p>方法实现</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">UIImage</span> *)animatedImageWithFrames:(<span class="built_in">NSArray</span>&lt;SDWebImageFrame *&gt; *)frames &#123;</span><br><span class="line">  <span class="comment">//如果数组元素为空，返回动图为nil</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> frameCount = frames.count;</span><br><span class="line">    <span class="keyword">if</span> (frameCount == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// 生成临时变量保存动图</span></span><br><span class="line">    <span class="built_in">UIImage</span> *animatedImage;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//如果是iOS 、iWatch 、 Apple TV  </span></span><br><span class="line"><span class="meta">#if SD_UIKIT || SD_WATCH </span></span><br><span class="line">    <span class="comment">//生成一个元素类型为非负整数，长度为动图帧数的数组个数，保存每一帧的展示时间</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> durations[frameCount];</span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; frameCount; i++) &#123;</span><br><span class="line">        <span class="comment">//遍历SDWebImageFrame对象数组，获取每一帧的展示时间</span></span><br><span class="line">        durations[i] = frames[i].duration * <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    计算所有帧展示时长的最大公约数</span><br><span class="line">    <span class="built_in">NSUInteger</span> <span class="keyword">const</span> gcd = gcdArray(frameCount, durations);</span><br><span class="line">    <span class="comment">//临时变量保存总时长</span></span><br><span class="line">    __block <span class="built_in">NSUInteger</span> totalDuration = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//创建一个可变数组，长度为动图帧数的数组个数</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span>&lt;<span class="built_in">UIImage</span> *&gt; *animatedImages = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:frameCount];</span><br><span class="line">    <span class="comment">//遍历传入的动图帧数的数组</span></span><br><span class="line">    [frames enumerateObjectsUsingBlock:^(SDWebImageFrame * _Nonnull frame, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">        <span class="comment">// 获取SDWebImageFrame对象保存的每一帧的图像</span></span><br><span class="line">        <span class="built_in">UIImage</span> *image = frame.image;</span><br><span class="line">        <span class="comment">// 获取SDWebImageFrame对象保存的每一帧的展示时间</span></span><br><span class="line">        <span class="built_in">NSUInteger</span> duration = frame.duration * <span class="number">1000</span>;</span><br><span class="line">        <span class="comment">//总时长</span></span><br><span class="line">        totalDuration += duration;</span><br><span class="line">        <span class="comment">//临时变量，保存重复次数</span></span><br><span class="line">        <span class="built_in">NSUInteger</span> repeatCount;</span><br><span class="line">        <span class="comment">// 如果计算出的最大公约数大于零，每一帧的重复次数就是展示时间除以最大公约数</span></span><br><span class="line">        <span class="comment">// 否则每一帧只重复一次，也就说不重复</span></span><br><span class="line">        <span class="keyword">if</span> (gcd) &#123;</span><br><span class="line">            repeatCount = duration / gcd;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            repeatCount = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据重复次数向动图数组中重复添加同一帧</span></span><br><span class="line">        <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; repeatCount; ++i) &#123;</span><br><span class="line">            [animatedImages addObject:image];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    获得动图</span><br><span class="line">    animatedImage = [<span class="built_in">UIImage</span> animatedImageWithImages:animatedImages duration:totalDuration / <span class="number">1000.</span>f];</span><br><span class="line">    </span><br><span class="line"><span class="meta">#else //如果不是（iOS 、iWatch 、 Apple TV ）</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableData</span> *imageData = [<span class="built_in">NSMutableData</span> data];</span><br><span class="line">    <span class="built_in">CFStringRef</span> imageUTType = [<span class="built_in">NSData</span> sd_UTTypeFromSDImageFormat:SDImageFormatGIF];</span><br><span class="line">    <span class="comment">// 创建图像目标。 GIF不支持EXIF图像方向</span></span><br><span class="line">    <span class="built_in">CGImageDestinationRef</span> imageDestination = <span class="built_in">CGImageDestinationCreateWithData</span>((__bridge <span class="built_in">CFMutableDataRef</span>)imageData, imageUTType, frameCount, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!imageDestination) &#123;</span><br><span class="line">        <span class="comment">// 处理失败。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历传入的动图帧数的数组</span></span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; frameCount; i++) &#123;</span><br><span class="line">        <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">            <span class="comment">// 获取SDWebImageFrame对象保存的每一帧的图像</span></span><br><span class="line">            SDWebImageFrame *frame = frames[i];</span><br><span class="line">            <span class="comment">// 获取SDWebImageFrame对象保存的每一帧的展示时间</span></span><br><span class="line">            <span class="keyword">float</span> frameDuration = frame.duration;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">CGImageRef</span> frameImageRef = frame.image.CGImage;</span><br><span class="line">            <span class="built_in">NSDictionary</span> *frameProperties = @&#123;(__bridge <span class="built_in">NSString</span> *)kCGImagePropertyGIFDictionary : @&#123;(__bridge <span class="built_in">NSString</span> *)kCGImagePropertyGIFDelayTime : @(frameDuration)&#125;&#125;;</span><br><span class="line">            <span class="built_in">CGImageDestinationAddImage</span>(imageDestination, frameImageRef, (__bridge <span class="built_in">CFDictionaryRef</span>)frameProperties);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Finalize the destination.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CGImageDestinationFinalize</span>(imageDestination) == <span class="literal">NO</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理失败。</span></span><br><span class="line">        <span class="built_in">CFRelease</span>(imageDestination);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CFRelease</span>(imageDestination);</span><br><span class="line">    SDAnimatedImageRep *imageRep = [[SDAnimatedImageRep alloc] initWithData:imageData];</span><br><span class="line">    animatedImage = [[<span class="built_in">NSImage</span> alloc] initWithSize:imageRep.size];</span><br><span class="line">    [animatedImage addRepresentation:imageRep];</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> animatedImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据动图返回SDWebImageFrame帧数组</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/<span class="symbol">*</span><span class="symbol">*</span></span><br><span class="line"> 根据动图返回SDWebImageFrame帧数组</span><br><span class="line">对于UIKit，这将取消应用上述描述的补丁，然后创建frames数组。 这也适用于普通的动画UIImage。</span><br><span class="line">  对于AppKit，NSImage不支持GIF以外的动画。 这将尝试解码GIF imageRep，然后创建帧数组。</span><br><span class="line"></span><br><span class="line"> <span class="meta">@param</span> animatedImage 一个动图.如果不是动图，返回nil</span><br><span class="line"> <span class="meta">@return</span> 返回SDWebImageFrame帧数组</span><br><span class="line"> <span class="symbol">*</span>/</span><br><span class="line">+ (NSArray<span class="variable">&lt;SDWebImageFrame *&gt;</span> <span class="symbol">*</span> _Nullable)framesFromAnimatedImage:(UIImage <span class="symbol">*</span> _Nullable)animatedImage;</span><br></pre></td></tr></table></figure><p>方法实现</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSArray</span>&lt;SDWebImageFrame *&gt; *)framesFromAnimatedImage:(<span class="built_in">UIImage</span> *)animatedImage &#123;</span><br><span class="line">    <span class="comment">//如果动图不存在，返回nil</span></span><br><span class="line">    <span class="keyword">if</span> (!animatedImage) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化两个临时变量： SDWebImageFrame对象 和帧个数</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span>&lt;SDWebImageFrame *&gt; *frames = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="built_in">NSUInteger</span> frameCount = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#if SD_UIKIT || SD_WATCH</span></span><br><span class="line">    <span class="comment">//获取动图的帧图片数组</span></span><br><span class="line">    <span class="built_in">NSArray</span>&lt;<span class="built_in">UIImage</span> *&gt; *animatedImages = animatedImage.images;</span><br><span class="line">    <span class="comment">//获取动图的帧图片数量</span></span><br><span class="line">    frameCount = animatedImages.count;</span><br><span class="line">    <span class="comment">//如果帧图片数量为0，表示不是动图，返回nil</span></span><br><span class="line">    <span class="keyword">if</span> (frameCount == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算每一帧的平均展示时间</span></span><br><span class="line">    <span class="built_in">NSTimeInterval</span> avgDuration = animatedImage.duration / frameCount;</span><br><span class="line">    <span class="comment">//如果这个动图没有展示时间就默认每一帧展示100毫秒 ，即0.1秒（这没有像GIF或WebP那样的10ms限制，以允许自定义编码器提供限制）</span></span><br><span class="line">    <span class="keyword">if</span> (avgDuration == <span class="number">0</span>) &#123;</span><br><span class="line">        avgDuration = <span class="number">0.1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录不同帧图片的数量</span></span><br><span class="line">    __block <span class="built_in">NSUInteger</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//记录一帧图片重复次数</span></span><br><span class="line">    __block <span class="built_in">NSUInteger</span> repeatCount = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//记录当前遍历到的图片之前的图片</span></span><br><span class="line">    __block <span class="built_in">UIImage</span> *previousImage = animatedImages.firstObject;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历图片数组</span></span><br><span class="line">    [animatedImages enumerateObjectsUsingBlock:^(<span class="built_in">UIImage</span> * _Nonnull image, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">        <span class="comment">// 第一张图片不处理，忽略掉</span></span><br><span class="line">        <span class="keyword">if</span> (idx == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果这一帧的图片和之前一帧图片相同就添加重复次数</span></span><br><span class="line">        <span class="keyword">if</span> ([image isEqual:previousImage]) &#123;</span><br><span class="line">            repeatCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果两帧图片不相同，就生成SDWebImageFrame对象</span></span><br><span class="line">            SDWebImageFrame *frame = [SDWebImageFrame frameWithImage:previousImage duration:avgDuration * repeatCount];</span><br><span class="line">            <span class="comment">// 数组记录对象</span></span><br><span class="line">            [frames addObject:frame];</span><br><span class="line">            <span class="comment">// 重复次数设置为1次</span></span><br><span class="line">            repeatCount = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 记录不同的帧图片的数量加1</span></span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录当前图片，用于下次遍历使用</span></span><br><span class="line">        previousImage = image;</span><br><span class="line">        <span class="comment">// 最后一张图片</span></span><br><span class="line">        <span class="keyword">if</span> (idx == frameCount - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果是最后一张照片就直接添加</span></span><br><span class="line">            SDWebImageFrame *frame = [SDWebImageFrame frameWithImage:previousImage duration:avgDuration * repeatCount];</span><br><span class="line">            [frames addObject:frame];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line"><span class="meta">#else //以下非iOS实现，一些东西不同，不做分析</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSBitmapImageRep</span> *bitmapRep;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSImageRep</span> *imageRep <span class="keyword">in</span> animatedImage.representations) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([imageRep isKindOfClass:[<span class="built_in">NSBitmapImageRep</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            bitmapRep = (<span class="built_in">NSBitmapImageRep</span> *)imageRep;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bitmapRep) &#123;</span><br><span class="line">        frameCount = [[bitmapRep valueForProperty:<span class="built_in">NSImageFrameCount</span>] unsignedIntegerValue];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (frameCount == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; frameCount; i++) &#123;</span><br><span class="line">        <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">            <span class="comment">//NSBitmapImageRep需要手动更改帧。 “Good taste”API</span></span><br><span class="line">            [bitmapRep setProperty:<span class="built_in">NSImageCurrentFrame</span> withValue:@(i)];</span><br><span class="line">            <span class="keyword">float</span> frameDuration = [[bitmapRep valueForProperty:<span class="built_in">NSImageCurrentFrameDuration</span>] floatValue];</span><br><span class="line">            <span class="built_in">NSImage</span> *frameImage = [[<span class="built_in">NSImage</span> alloc] initWithCGImage:bitmapRep.CGImage size:<span class="built_in">CGSizeZero</span>];</span><br><span class="line">            SDWebImageFrame *frame = [SDWebImageFrame frameWithImage:frameImage duration:frameDuration];</span><br><span class="line">            [frames addObject:frame];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> frames;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="图片方向处理"><a href="#图片方向处理" class="headerlink" title="图片方向处理"></a>图片方向处理</h4><p>将EXIF图片方向转换为iOS图片方向</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 将EXIF图片方向转换为iOS图片方向。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> exifOrientation EXIF图片方向</span></span><br><span class="line"><span class="comment"> <span class="doctag">@return</span> iOS图片方向</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (UIImageOrientation)<span class="string">imageOrientationFromEXIFOrientation:</span>(NSInteger)exifOrientation;</span><br></pre></td></tr></table></figure><p>方法实现</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将EXIF图片方向转换为iOS图片方向。根据EXIF图片方向做判断，返回iOS图片方向</span></span><br><span class="line">+ (<span class="built_in">UIImageOrientation</span>)imageOrientationFromEXIFOrientation:(<span class="built_in">NSInteger</span>)exifOrientation &#123;</span><br><span class="line">    <span class="comment">// CGImagePropertyOrientation在上面的iOS 8上可用。 目前保持兼容性</span></span><br><span class="line">    <span class="built_in">UIImageOrientation</span> imageOrientation = <span class="built_in">UIImageOrientationUp</span>;</span><br><span class="line">    <span class="keyword">switch</span> (exifOrientation) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            imageOrientation = <span class="built_in">UIImageOrientationUp</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            imageOrientation = <span class="built_in">UIImageOrientationDown</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            imageOrientation = <span class="built_in">UIImageOrientationLeft</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            imageOrientation = <span class="built_in">UIImageOrientationRight</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            imageOrientation = <span class="built_in">UIImageOrientationUpMirrored</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            imageOrientation = <span class="built_in">UIImageOrientationDownMirrored</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            imageOrientation = <span class="built_in">UIImageOrientationLeftMirrored</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            imageOrientation = <span class="built_in">UIImageOrientationRightMirrored</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> imageOrientation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将iOS方向转换为EXIF图片方向</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">将iOS方向转换为EXIF图片方向</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> imageOrientation iOS方向</span></span><br><span class="line"><span class="comment"> <span class="doctag">@return</span> EXIF图片方向</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (NSInteger)<span class="string">exifOrientationFromImageOrientation:</span>(UIImageOrientation)imageOrientation;</span><br></pre></td></tr></table></figure><p>方法实现</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将iOS方向转换为EXIF图片方向，根据iOS方向做判断，返回EXIF图片方向</span></span><br><span class="line">+ (<span class="built_in">NSInteger</span>)exifOrientationFromImageOrientation:(<span class="built_in">UIImageOrientation</span>)imageOrientation &#123;</span><br><span class="line">    <span class="comment">// CGImagePropertyOrientation 在上面的iOS 8上可用。 目前保持兼容性</span></span><br><span class="line">    <span class="built_in">NSInteger</span> exifOrientation = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">switch</span> (imageOrientation) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationUp</span>:</span><br><span class="line">            exifOrientation = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationDown</span>:</span><br><span class="line">            exifOrientation = <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationLeft</span>:</span><br><span class="line">            exifOrientation = <span class="number">8</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationRight</span>:</span><br><span class="line">            exifOrientation = <span class="number">6</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationUpMirrored</span>:</span><br><span class="line">            exifOrientation = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationDownMirrored</span>:</span><br><span class="line">            exifOrientation = <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationLeftMirrored</span>:</span><br><span class="line">            exifOrientation = <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationRightMirrored</span>:</span><br><span class="line">            exifOrientation = <span class="number">7</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> exifOrientation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="两个私有方法-计算最大公约数"><a href="#两个私有方法-计算最大公约数" class="headerlink" title="两个私有方法: 计算最大公约数"></a>两个私有方法: 计算最大公约数</h4><p>计算两个整数a和b的最大公约数</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static NSUInteger gcd(NSUInteger a, NSUInteger <span class="keyword">b) </span>&#123;</span><br><span class="line">    NSUInteger c<span class="comment">;</span></span><br><span class="line">    while (a != <span class="number">0</span>) &#123;</span><br><span class="line">        c = a<span class="comment">;</span></span><br><span class="line">        a = <span class="keyword">b </span>% a<span class="comment">;</span></span><br><span class="line">        <span class="keyword">b </span>= c<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="keyword">b;</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure><p>计算一个整数数组的最大公约数</p><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">NSUInteger</span> gcdArray(size_t <span class="keyword">const</span> count, <span class="type">NSUInteger</span> <span class="keyword">const</span> * <span class="keyword">const</span> values) &#123;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">NSUInteger</span> <span class="literal">result</span> = values[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">1</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        <span class="literal">result</span> = gcd(values[i], <span class="literal">result</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;SDWebImage&lt;/code&gt; 内部实现了一个图片解码/编码的图片编码器，用于图片的编解码、压缩。其中涉及到编解码管理（&lt;code&gt;SDWebImageCodersManager&lt;/code&gt;）、编解码协议（&lt;code&gt;SDWebImageCoder&lt;/code&gt;）、PNG/JPEG/TIFF编解码，解压缩，显示大图（&lt;code&gt;SDWebImageImageIOCoder&lt;/code&gt;）、GIF编解码（&lt;code&gt;SDWebImageGIFCoder&lt;/code&gt;）、WebP编解码（&lt;code&gt;SDWebImageWebPCoder&lt;/code&gt;）以及辅助类（&lt;code&gt;SDWebImageCoderHelper&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;本篇只做 &lt;code&gt;SDWebImageCoderHelper&lt;/code&gt; 类的分析。该类作为辅助类，主要实现了两个功能：动图处理 和 图片方向处理。每个功能有两种方法，均为互逆方法。&lt;/p&gt;
    
    </summary>
    
      <category term="读SDWebImage手札" scheme="http://guohuaden.com/categories/%E8%AF%BBSDWebImage%E6%89%8B%E6%9C%AD/"/>
    
    
      <category term="SDWebImage" scheme="http://guohuaden.com/tags/SDWebImage/"/>
    
  </entry>
  
  <entry>
    <title>读 SDWebImage 六 （编码器一：SDWebImageCoder）</title>
    <link href="http://guohuaden.com/2018/10/13/Read-SDWebImage-SDWebImageCoder/"/>
    <id>http://guohuaden.com/2018/10/13/Read-SDWebImage-SDWebImageCoder/</id>
    <published>2018-10-13T13:15:04.000Z</published>
    <updated>2018-10-26T03:07:23.441Z</updated>
    
    <content type="html"><![CDATA[<p><code>SDWebImage</code> 内部实现了一个图片解码/编码的图片编码器，用于图片的编解码、压缩。其中涉及到编解码管理（<code>SDWebImageCodersManager</code>）、编解码协议（<code>SDWebImageCoder</code>）、PNG/JPEG/TIFF编解码，解压缩，显示大图（<code>SDWebImageImageIOCoder</code>）、GIF编解码（<code>SDWebImageGIFCoder</code>）、WebP编解码（<code>SDWebImageWebPCoder</code>）以及辅助类（<code>SDWebImageCoderHelper</code>）</p><p>本篇只做 <code>SDWebImageCoder</code> 的分析。 <code>SDWebImageCoder</code> 是编解码协议，包含两个协议：<code>SDWebImageCoder</code> 和 <code>SDWebImageProgressiveCoder</code>，两个协议定义了图片编解码类的接口。</p><a id="more"></a><h4 id="公共变量与函数"><a href="#公共变量与函数" class="headerlink" title="公共变量与函数"></a>公共变量与函数</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//一个bool类型的key，标记在解压缩期间是否缩小大图片。使用：@&#123;SDWebImageCoderScaleDownLargeImagesKey: @(BOOL值)&#125;</span></span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * _Nonnull <span class="keyword">const</span> SDWebImageCoderScaleDownLargeImagesKey;</span><br><span class="line"></span><br><span class="line"><span class="comment">//.m文件</span></span><br><span class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> SDWebImageCoderScaleDownLargeImagesKey = <span class="string">@"scaleDownLargeImages"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 返回使用CGColorSpaceCreateDeviceRGB创建的共享设备相关RGB颜色空间。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @return 与设备相关RGB颜色空间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">CG_EXTERN</span> <span class="built_in">CGColorSpaceRef</span> _Nonnull SDCGColorSpaceGetDeviceRGB(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 检查 CGImageRef 是否包含 alpha 通道</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param imageRef The CGImageRef</span></span><br><span class="line"><span class="comment"> @return 如果CGImageRef包含alpha通道，则返回YES，否则返回NO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">CG_EXTERN</span> <span class="built_in">BOOL</span> SDCGImageRefContainsAlpha(_Nullable <span class="built_in">CGImageRef</span> imageRef);</span><br></pre></td></tr></table></figure><h4 id="两个函数的实现"><a href="#两个函数的实现" class="headerlink" title="两个函数的实现"></a>两个函数的实现</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义了一个单利方法，获取设备的RGB色彩空间</span></span><br><span class="line"><span class="built_in">CGColorSpaceRef</span> SDCGColorSpaceGetDeviceRGB(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="comment">//通过单例模式获取设备的RGB色彩空间并返回</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">CGColorSpaceRef</span> colorSpace;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> colorSpace;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查图片是否有透明度</span></span><br><span class="line"><span class="built_in">BOOL</span> SDCGImageRefContainsAlpha(<span class="built_in">CGImageRef</span> imageRef) &#123;</span><br><span class="line">    <span class="comment">//如果没有图片就返回没有透明度</span></span><br><span class="line">    <span class="keyword">if</span> (!imageRef) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取图片的透明度信息</span></span><br><span class="line">    <span class="built_in">CGImageAlphaInfo</span> alphaInfo = <span class="built_in">CGImageGetAlphaInfo</span>(imageRef);</span><br><span class="line">    <span class="comment">//如果满足下面的任何一个选项，就代表没有透明度；否则就有透明度</span></span><br><span class="line">    <span class="built_in">BOOL</span> hasAlpha = !(alphaInfo == kCGImageAlphaNone ||</span><br><span class="line">                      alphaInfo == kCGImageAlphaNoneSkipFirst ||</span><br><span class="line">                      alphaInfo == kCGImageAlphaNoneSkipLast);</span><br><span class="line">    <span class="keyword">return</span> hasAlpha;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="两个协议"><a href="#两个协议" class="headerlink" title="两个协议"></a>两个协议</h4><h5 id="SDWebImageCoder-协议"><a href="#SDWebImageCoder-协议" class="headerlink" title="SDWebImageCoder 协议"></a><code>SDWebImageCoder</code> 协议</h5><p>该协议提供自定义图像解码/编码的图像编码器协议。<br>需要注意的是：不要从主队列调用这些方法。<br>该协议使用了 <code>@required</code> 关键词，标志着里面的协议方法必须实现</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@required</span> <span class="comment">//标志着里面的协议方法必须实现</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - 解码</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 如果此编码器可以解码某些data，返回YES，否则，它应该传递给另一个编码器</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> @param data 需要解码的图片数据</span></span><br><span class="line"><span class="comment"> @return 如果此编码器可以解码图片，返回YES，否则返回NO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)canDecodeFromData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 将图片数据解码为图片。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> @param data 需要解码的图片数据</span></span><br><span class="line"><span class="comment"> @return 解码后得到的图片</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)decodedImageWithData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">使用原始图片和图片数据解压缩图片。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param image 需要压缩的原图片</span></span><br><span class="line"><span class="comment"> @param data 指向原始图像数据的指针。 指针本身是非空的，但图像数据可以为空。 如果需要，此数据将设置为缓存。 如果您不需要同时修改数据，请忽略此参数。</span></span><br><span class="line"><span class="comment"> @param optionsDict 一个包含任何解压缩选项的字典。 通过&#123;SDWebImageCoderScaleDownLargeImagesKey：@（YES）&#125;缩小大图像</span></span><br><span class="line"><span class="comment"> @return 解压缩后的图片</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)decompressedImageWithImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image</span><br><span class="line">                                            data:(<span class="built_in">NSData</span> * _Nullable * _Nonnull)data</span><br><span class="line">                                         options:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span>*, <span class="built_in">NSObject</span>*&gt;*)optionsDict;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark -编码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 如果此编码器可以编码某些图片，返回YES，否则，它应该传递给另一个编码器</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> @param format 图片格式</span></span><br><span class="line"><span class="comment"> @return 如果此编码器可以编码图片，返回YES，否则返回NO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)canEncodeToFormat:(SDImageFormat)format;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 将图片编码为图片数据（imagedata）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param image 需要编码的图片</span></span><br><span class="line"><span class="comment"> @param format 要编码的图片格式, 也有可能是 `SDImageFormatUndefined` 格式（未识别格式）</span></span><br><span class="line"><span class="comment"> @return The encoded image data</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)encodedDataWithImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image format:(SDImageFormat)format;</span><br></pre></td></tr></table></figure><h5 id="SDWebImageProgressiveCoder-协议"><a href="#SDWebImageProgressiveCoder-协议" class="headerlink" title="SDWebImageProgressiveCoder 协议"></a><code>SDWebImageProgressiveCoder</code> 协议</h5><p>该协议提供自定义逐行图像解码的图像编码器协议。<br>注意：不要从主队列调用这些方法。<br>该协议使用了 <code>@required</code> 关键词，标志着里面的协议方法必须实现</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">`@required` //标志着里面的协议方法必须实现</span><br><span class="line">/**</span><br><span class="line"> 如果此编码器可以增量解码某些数据，返回<span class="type">YES</span>，否则，它应该传递给另一个解码器。</span><br><span class="line"> </span><br><span class="line"> @param <span class="class"><span class="keyword">data</span> 图片数据，以便可以查看它</span></span><br><span class="line"> @return 如果此编码器可以增量解码该数据，返回<span class="type">YES</span>，否则返回<span class="type">NO</span></span><br><span class="line"> */</span><br><span class="line">- (<span class="type">BOOL</span>)canIncrementallyDecodeFromData:(nullable <span class="type">NSData</span> *)<span class="class"><span class="keyword">data</span>;</span></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">将图片数据增量解码为图片</span><br><span class="line"></span><br><span class="line"> @param <span class="class"><span class="keyword">data</span> 到目前为止已下载的图片数据</span></span><br><span class="line"> @param finished 下载是否已经结束</span><br><span class="line"> @warning 因为增量解码需要保持解码的上下文，我们将为每个下载操作分配一个具有相同类的新实例，以避免冲突</span><br><span class="line"> @return <span class="type">The</span> decoded image from <span class="class"><span class="keyword">data</span></span></span><br><span class="line"> */</span><br><span class="line">- (nullable <span class="type">UIImage</span> *)incrementallyDecodedImageWithData:(nullable <span class="type">NSData</span> *)<span class="class"><span class="keyword">data</span> finished:(<span class="type">BOOL</span>)finished;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;SDWebImage&lt;/code&gt; 内部实现了一个图片解码/编码的图片编码器，用于图片的编解码、压缩。其中涉及到编解码管理（&lt;code&gt;SDWebImageCodersManager&lt;/code&gt;）、编解码协议（&lt;code&gt;SDWebImageCoder&lt;/code&gt;）、PNG/JPEG/TIFF编解码，解压缩，显示大图（&lt;code&gt;SDWebImageImageIOCoder&lt;/code&gt;）、GIF编解码（&lt;code&gt;SDWebImageGIFCoder&lt;/code&gt;）、WebP编解码（&lt;code&gt;SDWebImageWebPCoder&lt;/code&gt;）以及辅助类（&lt;code&gt;SDWebImageCoderHelper&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;本篇只做 &lt;code&gt;SDWebImageCoder&lt;/code&gt; 的分析。 &lt;code&gt;SDWebImageCoder&lt;/code&gt; 是编解码协议，包含两个协议：&lt;code&gt;SDWebImageCoder&lt;/code&gt; 和 &lt;code&gt;SDWebImageProgressiveCoder&lt;/code&gt;，两个协议定义了图片编解码类的接口。&lt;/p&gt;
    
    </summary>
    
      <category term="读SDWebImage手札" scheme="http://guohuaden.com/categories/%E8%AF%BBSDWebImage%E6%89%8B%E6%9C%AD/"/>
    
    
      <category term="SDWebImage" scheme="http://guohuaden.com/tags/SDWebImage/"/>
    
  </entry>
  
  <entry>
    <title>读 SDWebImage 五 （SDWebImageDownloaderOperation）</title>
    <link href="http://guohuaden.com/2018/10/11/Read-SDWebImage-SDWebImageDownloaderOperation/"/>
    <id>http://guohuaden.com/2018/10/11/Read-SDWebImage-SDWebImageDownloaderOperation/</id>
    <published>2018-10-11T09:58:01.000Z</published>
    <updated>2018-10-25T11:23:12.187Z</updated>
    
    <content type="html"><![CDATA[<p><code>SDWebImage</code> 的图片下载是由 <code>SDWebImageDownloader</code> 类实现的，该类是一个异步下载管理器。主要工作是下载相关配置项的管理，包括下载队列的先后顺序、最大下载任务数量控制、下载队列中的任务创建、取消、暂停等任务管理，以及其他的 <code>HTTPS</code> 和 <code>HTTP Header</code> 的设置。</p><p>而真正实现图片下载的是 <code>SDWebImageDownloaderOperation</code> 类。该类的 <code>Operation</code> 操作依赖系统提供的 <code>NSURLConnection</code> 类来实现图片的下载。在 <code>SDWebImageDownloader</code> 类中，将图片的下载操作封装成了自定义的一个类 <code>SDWebImageDownloaderOperation</code> ，然后添加到了操作队列中。当操作队列调用这个操作时，会调用操作对象的 <code>- (void)start</code> 方法，在重写的这个方法中，生成了任务对象<code>dataTask</code>，并调用<code>resume</code>开始执行任务。<br>因为S<code>DWebImageDownloaderOperation</code>类遵守了<code>dataTask</code>对象的协议，所以<code>dataTask</code>执行的结果会通过代理方法进行回调。在代理方法中，获取并保存了服务器返回的数据，并在任务执行结束后，对数据进行解码、缩放和解压。处理完成后就进行回调。</p><p><strong>梳理</strong>：<br> <code>SDWebImageDownloaderOperation</code>是一个自定义、并行的 <code>NSOperation</code> 子类。这个子类主要实现的功能有：<br>由于只自定义的并行 <code>NSOperation</code>,所以需要管理 <code>executing</code> , <code>finished</code> 等各种属性的处理，并且手动触发KVO。<br>在 <code>- (void)start</code> 方法里面实现主要逻辑，在重写的这个方法中生成了任务对象<code>dataTask</code>，并调用<code>resume</code>开始执行任务。<br>在 <code>NSURLSessionTaskDelegate</code> 和 <code>NSURLSessionDataDelegate</code> 中处理数据的加载，以及进度Block的处理。<br>如果 <code>unownedSession</code> 属性因为某种原因是<code>nil</code>，则手动初始化一个做网络请求。<br>在代理方法中对认证、数据拼装、完成回调<code>Block</code>做处理。</p><p>通过发送 <code>SDWebImageDownloadStopNotification</code>,<br><code>SDWebImageDownloadFinishNotification</code>,<br><code>SDWebImageDownloadReceiveResponseNotification</code>, <code>SDWebImageDownloadStartNotification</code>来通知 <code>Operation</code> 的状态。</p><h3 id="h文件"><a href="#h文件" class="headerlink" title=".h文件"></a>.h文件</h3><p>四个通知，<code>SDWebImageDownloaderOperation</code> 在四种情况下会发送通知：</p><ol><li>开始下载</li><li>接收到数据</li><li>停止下载</li><li>结束下载</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * _Nonnull <span class="keyword">const</span> SDWebImageDownloadStartNotification;</span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * _Nonnull <span class="keyword">const</span> SDWebImageDownloadReceiveResponseNotification;</span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * _Nonnull <span class="keyword">const</span> SDWebImageDownloadStopNotification;</span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * _Nonnull <span class="keyword">const</span> SDWebImageDownloadFinishNotification;</span><br></pre></td></tr></table></figure><h3 id="SDWebImageDownloaderOperationInterface协议"><a href="#SDWebImageDownloaderOperationInterface协议" class="headerlink" title="SDWebImageDownloaderOperationInterface协议"></a><code>SDWebImageDownloaderOperationInterface</code>协议</h3><p>如果想要实现一个自定义的下载操作，就必须继承自 <code>NSOperation</code> ,同时实现 <code>SDWebImageDownloaderOperationInterface</code> 这个协议。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">SDWebImageDownloaderOperationInterface</span>&lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用NSURLRequest,NSURLSession和SDWebImageDownloaderOptions初始化</span></span><br><span class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)initWithRequest:(<span class="keyword">nullable</span> <span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                              inSession:(<span class="keyword">nullable</span> <span class="built_in">NSURLSession</span> *)session</span><br><span class="line">                                options:(SDWebImageDownloaderOptions)options;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以为每一个NSOperation自由的添加相应对象</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)addHandlersForProgress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                            completed:(<span class="keyword">nullable</span> SDWebImageDownloaderCompletedBlock)completedBlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否需要解压图片</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)shouldDecompressImages;</span><br><span class="line"><span class="comment">//设置是否需要解压图片</span></span><br><span class="line">- (<span class="keyword">void</span>)setShouldDecompressImages:(<span class="built_in">BOOL</span>)value;</span><br><span class="line"></span><br><span class="line"><span class="comment">//证书</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLCredential</span> *)credential;</span><br><span class="line"><span class="comment">//设置证书</span></span><br><span class="line">- (<span class="keyword">void</span>)setCredential:(<span class="keyword">nullable</span> <span class="built_in">NSURLCredential</span> *)value;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取消token</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)cancel:(<span class="keyword">nullable</span> <span class="keyword">id</span>)token;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="属性声明-和-方法"><a href="#属性声明-和-方法" class="headerlink" title="属性声明 和 方法"></a>属性声明 和 方法</h3><p><code>SDWebImageDownloaderOperation</code> 遵守 <code>SDWebImageDownloaderOperationInterface</code>, <code>SDWebImageOperation</code>, <code>NSURLSessionTaskDelegate</code>, <code>NSURLSessionDataDelegate</code> 等协议</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 操作任务使用的请求。（外部只读）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">NSURLRequest</span> *request;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 操作任务（外部只读）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">NSURLSessionTask</span> *dataTask;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//是否需要解压图片</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> shouldDecompressImages;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  用于确定URL连接是否应查询凭据存储以验证连接。</span></span><br><span class="line"><span class="comment"> *  @deprecated Not used for a couple of versions</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> shouldUseCredentialStorage __deprecated_msg(<span class="string">"Property deprecated. Does nothing. Kept only for backwards compatibility"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The credential used for authentication challenges 在 `-URLSession:task:didReceiveChallenge:completionHandler:`中用于身份验证挑战的凭证.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果存在请求URL的用户名或密码，则会覆盖此任何共享凭据。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="built_in">NSURLCredential</span> *credential;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SDWebImageDownloaderOptions选项 （外部只读）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) SDWebImageDownloaderOptions options;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 预期的数据大小。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSInteger</span> expectedSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 操作任务返回的响应。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">NSURLResponse</span> *response;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  I初始化`SDWebImageDownloaderOperation` 对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @see SDWebImageDownloaderOperation</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param request       URL请求</span></span><br><span class="line"><span class="comment"> *  @param session       将运行此操作的URL会话</span></span><br><span class="line"><span class="comment"> *  @param options       下载的选项</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return 初始化实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)initWithRequest:(<span class="keyword">nullable</span> <span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                              inSession:(<span class="keyword">nullable</span> <span class="built_in">NSURLSession</span> *)session</span><br><span class="line">                                options:(SDWebImageDownloaderOptions)options <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  添加处理程序以进行和完成。 返回可以传递给-cancel的tokent：取消这组回调。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param progressBlock  当新的数据块到达时执行的块。</span></span><br><span class="line"><span class="comment"> *                        @note 在后台队列上执行进度块</span></span><br><span class="line"><span class="comment"> *  @param completedBlock 当下载完成时执行的代码块</span></span><br><span class="line"><span class="comment"> *                        @note 已完成的代码块在主队列上执行以获得成功。如果发现错误，则代码块可能会在后台队列上执行</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return 用于取消这组处理程序的token</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)addHandlersForProgress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                            completed:(<span class="keyword">nullable</span> SDWebImageDownloaderCompletedBlock)completedBlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  取消一组回调. 一旦所有的回调被取消，该操作取消</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param token代表一组要取消的回调</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return 如果操作已停止，则为YES，因为这是要取消的最后一个token。 否则为NO。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)cancel:(<span class="keyword">nullable</span> <span class="keyword">id</span>)token;</span><br></pre></td></tr></table></figure><h3 id="m文件"><a href="#m文件" class="headerlink" title=".m文件"></a>.m文件</h3><p>信号量实现锁机制，这种锁性能要比NSLock高</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define LOCK(<span class="name">lock</span>) dispatch_semaphore_wait(<span class="name">lock</span>, DISPATCH_TIME_FOREVER)<span class="comment">;</span></span><br><span class="line">#define UNLOCK(<span class="name">lock</span>) dispatch_semaphore_signal(<span class="name">lock</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>静态全局变量</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开始下载的通知</span></span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> SDWebImageDownloadStartNotification = <span class="string">@"SDWebImageDownloadStartNotification"</span>;</span><br><span class="line"><span class="comment">//接受数据的通知</span></span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> SDWebImageDownloadReceiveResponseNotification = <span class="string">@"SDWebImageDownloadReceiveResponseNotification"</span>;</span><br><span class="line"><span class="comment">//停止下载的通知</span></span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> SDWebImageDownloadStopNotification = <span class="string">@"SDWebImageDownloadStopNotification"</span>;</span><br><span class="line"><span class="comment">//结束下载的通知</span></span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> SDWebImageDownloadFinishNotification = <span class="string">@"SDWebImageDownloadFinishNotification"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态全局变量作为下载进度block字典存储的key</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> kProgressCallbackKey = <span class="string">@"progress"</span>;</span><br><span class="line"><span class="comment">//静态全局变量作为结束下载block字典存储的key</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> kCompletedCallbackKey = <span class="string">@"completed"</span>;</span><br></pre></td></tr></table></figure><h4 id="属性声明"><a href="#属性声明" class="headerlink" title="属性声明"></a>属性声明</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//回调Block列表</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSMutableArray</span>&lt;SDCallbacksDictionary *&gt; *callbackBlocks;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义并行Operation需要管理的两个属性。默认是readonly的，我们这里通过声明改为可修改的。方便我们在后面操作。默认情况下_executing和finished都是NO</span></span><br><span class="line"><span class="comment">//是否正在执行</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>, <span class="keyword">getter</span> = isExecuting) <span class="built_in">BOOL</span> executing;</span><br><span class="line"><span class="comment">//是否结束</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>, <span class="keyword">getter</span> = isFinished) <span class="built_in">BOOL</span> finished;</span><br><span class="line"><span class="comment">//图片数据</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">NSMutableData</span> *imageData;</span><br><span class="line"><span class="comment">//缓存数据</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">NSData</span> *cachedData; <span class="comment">// for `SDWebImageDownloaderIgnoreCachedResponse`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过SDWebImageDownloader传过来。所以这里是weak。因为他是通过SDWebImageDownloader管理的。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">NSURLSession</span> *unownedSession;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果unownedSession是nil，我们需要手动创建一个并且管理他的生命周期和代理方法</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">NSURLSession</span> *ownedSession;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dataTask对象</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>, <span class="keyword">nullable</span>) <span class="built_in">NSURLSessionTask</span> *dataTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个锁，以保持对`callbackBlocks`线程安全的访问</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) dispatch_semaphore_t callbacksLock; <span class="comment">// a lock to keep the access to `callbackBlocks` thread-safe</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一个并行queue。用于控制数据的处理</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">dispatch_queue_t</span> coderQueue; <span class="comment">// the queue to do image decoding</span></span><br><span class="line"><span class="meta">#if SD_UIKIT</span></span><br><span class="line"><span class="comment">//如果用户设置了后台继续加载选线。则通过backgroundTask来继续下载图片</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">UIBackgroundTaskIdentifier</span> backgroundTaskId;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//图片解码器，有意思的是如果图片没有完全下载完成时也可以解码展示部分图片</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="keyword">id</span>&lt;SDWebImageProgressiveCoder&gt; progressiveCoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h4 id="方法实现"><a href="#方法实现" class="headerlink" title="方法实现"></a>方法实现</h4><p>编译器自动添加get和set方法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">synthesize</span> executing = _executing;</span><br><span class="line">@<span class="keyword">synthesize</span> finished = _finished;</span><br></pre></td></tr></table></figure><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithRequest:<span class="literal">nil</span> inSession:<span class="literal">nil</span> options:<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)initWithRequest:(<span class="keyword">nullable</span> <span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                              inSession:(<span class="keyword">nullable</span> <span class="built_in">NSURLSession</span> *)session</span><br><span class="line">                                options:(SDWebImageDownloaderOptions)options &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) &#123;</span><br><span class="line">        _request = [request <span class="keyword">copy</span>];</span><br><span class="line">        _shouldDecompressImages = <span class="literal">YES</span>;</span><br><span class="line">        _options = options;</span><br><span class="line">        _callbackBlocks = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">        <span class="comment">//默认情况下_executing和finished都是NO</span></span><br><span class="line">        _executing = <span class="literal">NO</span>;</span><br><span class="line">        _finished = <span class="literal">NO</span>;</span><br><span class="line">        _expectedSize = <span class="number">0</span>;</span><br><span class="line">        _unownedSession = session;</span><br><span class="line">        _callbacksLock = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">        _coderQueue = dispatch_queue_create(<span class="string">"com.hackemist.SDWebImageDownloaderOperationCoderQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给Operation添加进度和回调Block</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 给Operation添加进度和回调Block</span></span><br><span class="line"><span class="comment"> @param progressBlock 进度Block</span></span><br><span class="line"><span class="comment"> @param completedBlock 回调Block</span></span><br><span class="line"><span class="comment"> @return 回调字典</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)addHandlersForProgress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                            completed:(<span class="keyword">nullable</span> SDWebImageDownloaderCompletedBlock)completedBlock &#123;</span><br><span class="line">    <span class="comment">//初始化一个回调Block列表                      </span></span><br><span class="line">    SDCallbacksDictionary *callbacks = [<span class="built_in">NSMutableDictionary</span> new];</span><br><span class="line">    <span class="comment">//如果progressBlock 和 completedBlock 存在，就把Operation对应的回调和进度Block添加到回调Block列表中</span></span><br><span class="line">    <span class="keyword">if</span> (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock <span class="keyword">copy</span>];</span><br><span class="line">    <span class="keyword">if</span> (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock <span class="keyword">copy</span>];</span><br><span class="line">    LOCK(<span class="keyword">self</span>.callbacksLock);</span><br><span class="line">    [<span class="keyword">self</span>.callbackBlocks addObject:callbacks];</span><br><span class="line">    UNLOCK(<span class="keyword">self</span>.callbacksLock);</span><br><span class="line">    <span class="keyword">return</span> callbacks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过key获取回调列表组</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSArray</span>&lt;<span class="keyword">id</span>&gt; *)callbacksForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    LOCK(<span class="keyword">self</span>.callbacksLock);</span><br><span class="line">    <span class="built_in">NSMutableArray</span>&lt;<span class="keyword">id</span>&gt; *callbacks = [[<span class="keyword">self</span>.callbackBlocks valueForKey:key] mutableCopy];</span><br><span class="line">    UNLOCK(<span class="keyword">self</span>.callbacksLock);</span><br><span class="line">    <span class="comment">// 我们需要删除[NSNull null]，因为每个回调可能并不总是有进度Block</span></span><br><span class="line">    [callbacks removeObjectIdenticalTo:[<span class="built_in">NSNull</span> null]];</span><br><span class="line">    <span class="keyword">return</span> [callbacks <span class="keyword">copy</span>]; <span class="comment">// strip mutability here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过token判断是否需要取消Opration</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)cancel:(<span class="keyword">nullable</span> <span class="keyword">id</span>)token &#123;</span><br><span class="line">    <span class="built_in">BOOL</span> shouldCancel = <span class="literal">NO</span>;</span><br><span class="line">    LOCK(<span class="keyword">self</span>.callbacksLock);</span><br><span class="line">    <span class="comment">//通过token移除对象</span></span><br><span class="line">    [<span class="keyword">self</span>.callbackBlocks removeObjectIdenticalTo:token];</span><br><span class="line">    <span class="comment">//如果self.callbackBlocks的count为0，则shouldCancel = YES</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.callbackBlocks.count == <span class="number">0</span>) &#123;</span><br><span class="line">        shouldCancel = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    UNLOCK(<span class="keyword">self</span>.callbacksLock);</span><br><span class="line">    <span class="comment">//如果shouldCancel = YES，则执行取消操作</span></span><br><span class="line">    <span class="keyword">if</span> (shouldCancel) &#123;</span><br><span class="line">        [<span class="keyword">self</span> cancel];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shouldCancel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="下载、取消、复位、完成等操作"><a href="#下载、取消、复位、完成等操作" class="headerlink" title="下载、取消、复位、完成等操作"></a>下载、取消、复位、完成等操作</h5><p>并行的Operation需要重写这个方法，在这个方法里面做具体的处理</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)start &#123;</span><br><span class="line">    <span class="comment">//加同步锁</span></span><br><span class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">//如果已经被设置为取消状态，就直接重新复位：将Operation从回调Block列表中移除，dataTask设置为nil，并将NSURLSession注销并取消（invalidateAndCancel）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.isCancelled) &#123;</span><br><span class="line">            <span class="keyword">self</span>.finished = <span class="literal">YES</span>;</span><br><span class="line">            [<span class="keyword">self</span> reset];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#if SD_UIKIT</span></span><br><span class="line">        <span class="comment">//查看是否能获取到UIApplication类</span></span><br><span class="line">        Class <span class="built_in">UIApplicationClass</span> = <span class="built_in">NSClassFromString</span>(<span class="string">@"UIApplication"</span>);</span><br><span class="line">        <span class="built_in">BOOL</span> hasApplication = <span class="built_in">UIApplicationClass</span> &amp;&amp; [<span class="built_in">UIApplicationClass</span> respondsToSelector:<span class="keyword">@selector</span>(sharedApplication)];</span><br><span class="line">        <span class="comment">//如果有UIApplication类并设置了Background模式，则设置一个backgroundTask</span></span><br><span class="line">        <span class="keyword">if</span> (hasApplication &amp;&amp; [<span class="keyword">self</span> shouldContinueWhenAppEntersBackground]) &#123;</span><br><span class="line">        <span class="comment">//开始后台下载</span></span><br><span class="line">            __<span class="keyword">weak</span> __typeof__ (<span class="keyword">self</span>) wself = <span class="keyword">self</span>;</span><br><span class="line">            <span class="built_in">UIApplication</span> * app = [<span class="built_in">UIApplicationClass</span> performSelector:<span class="keyword">@selector</span>(sharedApplication)];</span><br><span class="line">            <span class="keyword">self</span>.backgroundTaskId = [app beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class="line">            <span class="comment">//后台下载任务结束，做清理工作（取消任务）</span></span><br><span class="line">                __<span class="keyword">strong</span> __<span class="keyword">typeof</span> (wself) sself = wself;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (sself) &#123;</span><br><span class="line">                    [sself cancel];</span><br><span class="line"></span><br><span class="line">                    [app endBackgroundTask:sself.backgroundTaskId];</span><br><span class="line">                    sself.backgroundTaskId = <span class="built_in">UIBackgroundTaskInvalid</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">        <span class="comment">//获取传入的网络会话对象</span></span><br><span class="line">        <span class="built_in">NSURLSession</span> *session = <span class="keyword">self</span>.unownedSession;</span><br><span class="line">        <span class="comment">//如果SDWebImageDownloader传入的session是nil，则手动初始化一个session对象</span></span><br><span class="line">        <span class="keyword">if</span> (!session) &#123;</span><br><span class="line">            <span class="built_in">NSURLSessionConfiguration</span> *sessionConfig = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line">            <span class="comment">//请求超时时间 15秒</span></span><br><span class="line">            sessionConfig.timeoutIntervalForRequest = <span class="number">15</span>;</span><br><span class="line">            session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:sessionConfig</span><br><span class="line">                                                    delegate:<span class="keyword">self</span></span><br><span class="line">                                               delegateQueue:<span class="literal">nil</span>];</span><br><span class="line">            <span class="keyword">self</span>.ownedSession = session;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果设置了忽略从NSURLCache中获取缓存的选项</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.options &amp; SDWebImageDownloaderIgnoreCachedResponse) &#123;</span><br><span class="line">            <span class="comment">// 获取缓存的数据以供日后检查，不存在就初始化一个URLCache对象</span></span><br><span class="line">            <span class="built_in">NSURLCache</span> *URLCache = session.configuration.URLCache;</span><br><span class="line">            <span class="keyword">if</span> (!URLCache) &#123;</span><br><span class="line">                URLCache = [<span class="built_in">NSURLCache</span> sharedURLCache];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">NSCachedURLResponse</span> *cachedResponse;</span><br><span class="line">            <span class="comment">// NSURLCache的 `cachedResponseForRequest:` 不是线程安全的，所以这里加了同步锁。 详情看（ https://developer.apple.com/documentation/foundation/nsurlcache#2317483）</span></span><br><span class="line">            <span class="keyword">@synchronized</span> (URLCache) &#123;</span><br><span class="line">                cachedResponse = [URLCache cachedResponseForRequest:<span class="keyword">self</span>.request];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cachedResponse) &#123;</span><br><span class="line">                <span class="keyword">self</span>.cachedData = cachedResponse.data;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//生成NSURLSessionTask类对象</span></span><br><span class="line">        <span class="keyword">self</span>.dataTask = [session dataTaskWithRequest:<span class="keyword">self</span>.request];</span><br><span class="line">        <span class="comment">//设置为正在执行状态</span></span><br><span class="line">        <span class="keyword">self</span>.executing = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果NSURLSessionTask类对象存在</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.dataTask) &#123;</span><br><span class="line"><span class="meta">#pragma clang diagnostic push</span></span><br><span class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Wunguarded-availability"</span></span></span><br><span class="line">        <span class="comment">//因为NSURLSessionTask的priority这个属性是iOS8.0以后才有的，所以要判断一下</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.dataTask respondsToSelector:<span class="keyword">@selector</span>(setPriority:)]) &#123;</span><br><span class="line">        <span class="comment">//根据设置的选项设置优先级</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.options &amp; SDWebImageDownloaderHighPriority) &#123;</span><br><span class="line">                <span class="keyword">self</span>.dataTask.priority = <span class="built_in">NSURLSessionTaskPriorityHigh</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">self</span>.options &amp; SDWebImageDownloaderLowPriority) &#123;</span><br><span class="line">                <span class="keyword">self</span>.dataTask.priority = <span class="built_in">NSURLSessionTaskPriorityLow</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#pragma clang diagnostic pop</span></span><br><span class="line">        <span class="comment">//发送请求，开始执行任务</span></span><br><span class="line">        [<span class="keyword">self</span>.dataTask resume];</span><br><span class="line">        <span class="comment">//获取到进度回调代码块并调用</span></span><br><span class="line">        <span class="keyword">for</span> (SDWebImageDownloaderProgressBlock progressBlock <span class="keyword">in</span> [<span class="keyword">self</span> callbacksForKey:kProgressCallbackKey]) &#123;</span><br><span class="line">            progressBlock(<span class="number">0</span>, <span class="built_in">NSURLResponseUnknownLength</span>, <span class="keyword">self</span>.request.URL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//异步主队列发送下载开始通知</span></span><br><span class="line">        __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadStartNotification object:weakSelf];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果没有获取到NSURLSessionTask类对象，就回调错误并返回</span></span><br><span class="line">        [<span class="keyword">self</span> callCompletionBlocksWithError:[<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:<span class="built_in">NSURLErrorUnknown</span> userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span> : <span class="string">@"Task can't be initialized"</span>&#125;]];</span><br><span class="line">        [<span class="keyword">self</span> done];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#if SD_UIKIT</span></span><br><span class="line">    <span class="comment">//如果是后台任务，就关闭后台任务</span></span><br><span class="line">    Class <span class="built_in">UIApplicationClass</span> = <span class="built_in">NSClassFromString</span>(<span class="string">@"UIApplication"</span>);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">UIApplicationClass</span> || ![<span class="built_in">UIApplicationClass</span> respondsToSelector:<span class="keyword">@selector</span>(sharedApplication)]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.backgroundTaskId != <span class="built_in">UIBackgroundTaskInvalid</span>) &#123;</span><br><span class="line">        <span class="built_in">UIApplication</span> * app = [<span class="built_in">UIApplication</span> performSelector:<span class="keyword">@selector</span>(sharedApplication)];</span><br><span class="line">        [app endBackgroundTask:<span class="keyword">self</span>.backgroundTaskId];</span><br><span class="line">        <span class="keyword">self</span>.backgroundTaskId = <span class="built_in">UIBackgroundTaskInvalid</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取消Operation操作。</span></span><br><span class="line">- (<span class="keyword">void</span>)cancel &#123;</span><br><span class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span> cancelInternal];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">- (<span class="keyword">void</span>)cancelInternal &#123;</span><br><span class="line">    <span class="comment">//如果已经结束，返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.isFinished) <span class="keyword">return</span>;</span><br><span class="line">    [<span class="keyword">super</span> cancel];</span><br><span class="line">    <span class="comment">//如果存在NSURLSessionTask类对象，就取消，并且异步主队列发送下载开始通知</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.dataTask) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.dataTask cancel];</span><br><span class="line">        __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadStopNotification object:weakSelf];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// As we cancelled the task, its callback won't be called and thus won't</span></span><br><span class="line">        <span class="comment">// maintain the isFinished and isExecuting flags.</span></span><br><span class="line">        <span class="comment">//更新执行状态和结束状态</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.isExecuting) <span class="keyword">self</span>.executing = <span class="literal">NO</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>.isFinished) <span class="keyword">self</span>.finished = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//复位</span></span><br><span class="line">    [<span class="keyword">self</span> reset];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//完成Operation操作</span></span><br><span class="line">- (<span class="keyword">void</span>)done &#123;</span><br><span class="line">    <span class="comment">//更新执行状态和结束状态</span></span><br><span class="line">    <span class="keyword">self</span>.finished = <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">self</span>.executing = <span class="literal">NO</span>;</span><br><span class="line">     <span class="comment">//复位</span></span><br><span class="line">    [<span class="keyword">self</span> reset];</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//复位</span></span><br><span class="line">- (<span class="keyword">void</span>)reset &#123;</span><br><span class="line">    <span class="comment">//删除回调block列表中所有的对象</span></span><br><span class="line">    LOCK(<span class="keyword">self</span>.callbacksLock);</span><br><span class="line">    [<span class="keyword">self</span>.callbackBlocks removeAllObjects];</span><br><span class="line">    UNLOCK(<span class="keyword">self</span>.callbacksLock);</span><br><span class="line">    <span class="comment">//NSURLSessionTask类对象置为nil</span></span><br><span class="line">    <span class="keyword">self</span>.dataTask = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注销网络会话对象</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.ownedSession) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.ownedSession invalidateAndCancel];</span><br><span class="line">        <span class="keyword">self</span>.ownedSession = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置结束状态</span></span><br><span class="line">- (<span class="keyword">void</span>)setFinished:(<span class="built_in">BOOL</span>)finished &#123;</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"isFinished"</span>];</span><br><span class="line">    _finished = finished;</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"isFinished"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置执行状态</span></span><br><span class="line">- (<span class="keyword">void</span>)setExecuting:(<span class="built_in">BOOL</span>)executing &#123;</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"isExecuting"</span>];</span><br><span class="line">    _executing = executing;</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"isExecuting"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断Operation是否是并发</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isConcurrent &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="NSURLSessionDataDelegate"><a href="#NSURLSessionDataDelegate" class="headerlink" title="NSURLSessionDataDelegate"></a>NSURLSessionDataDelegate</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//收到服务端响应，再一次请求中只会执行一次</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">          dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line"> completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionResponseDisposition</span> disposition))completionHandler &#123;</span><br><span class="line">    <span class="built_in">NSURLSessionResponseDisposition</span> disposition = <span class="built_in">NSURLSessionResponseAllow</span>;</span><br><span class="line">    <span class="comment">//获取要下载图片的长度</span></span><br><span class="line">    <span class="built_in">NSInteger</span> expected = (<span class="built_in">NSInteger</span>)response.expectedContentLength;</span><br><span class="line">    expected = expected &gt; <span class="number">0</span> ? expected : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//设置当前expectedSize</span></span><br><span class="line">    <span class="keyword">self</span>.expectedSize = expected;</span><br><span class="line">    <span class="comment">//设置当前response</span></span><br><span class="line">    <span class="keyword">self</span>.response = response;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据状态代码判断氢气的状态</span></span><br><span class="line">    <span class="built_in">NSInteger</span> statusCode = [response respondsToSelector:<span class="keyword">@selector</span>(statusCode)] ? ((<span class="built_in">NSHTTPURLResponse</span> *)response).statusCode : <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">BOOL</span> valid = statusCode &lt; <span class="number">400</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//'304 Not Modified'是一个特殊的。 如果没有缓存数据，则应将其视为已取消。</span></span><br><span class="line">    <span class="comment">//当服务器响应304并且URLCache命中时，URLSession当前行为将返回200状态代码。 但这不是标准行为，我们只是添加一个检查</span></span><br><span class="line">    <span class="keyword">if</span> (statusCode == <span class="number">304</span> &amp;&amp; !<span class="keyword">self</span>.cachedData) &#123;</span><br><span class="line">        valid = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果状态代码是有效的</span></span><br><span class="line">    <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">        <span class="comment">//遍历进度回调块并触发进度block回调</span></span><br><span class="line">        <span class="keyword">for</span> (SDWebImageDownloaderProgressBlock progressBlock <span class="keyword">in</span> [<span class="keyword">self</span> callbacksForKey:kProgressCallbackKey]) &#123;</span><br><span class="line">            progressBlock(<span class="number">0</span>, expected, <span class="keyword">self</span>.request.URL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 状态代码无效并标记为已取消。 不要调用`[self.dataTask cancel]` which may mass up URLSession life cycle</span></span><br><span class="line">        disposition = <span class="built_in">NSURLSessionResponseCancel</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//异步主队列发送接受数据通知</span></span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadReceiveResponseNotification object:weakSelf];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//表示允许继续加载</span></span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每次收到数据都会触发， 可能多次调用</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask didReceiveData:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//向可变数据中添加接收到的数据</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.imageData) &#123;</span><br><span class="line">        <span class="keyword">self</span>.imageData = [[<span class="built_in">NSMutableData</span> alloc] initWithCapacity:<span class="keyword">self</span>.expectedSize];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.imageData appendData:data];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果设置了SDWebImageDownloaderProgressiveDownload选项下载（即展示已经下载的部分,并expectedSize返回的图片size大于0）</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span>.options &amp; SDWebImageDownloaderProgressiveDownload) &amp;&amp; <span class="keyword">self</span>.expectedSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 获得图片数据</span></span><br><span class="line">        __block <span class="built_in">NSData</span> *imageData = [<span class="keyword">self</span>.imageData <span class="keyword">copy</span>];</span><br><span class="line">        <span class="comment">// 获得下载的总字节数</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">NSInteger</span> totalSize = imageData.length;</span><br><span class="line">        <span class="comment">// 获得结束的状态</span></span><br><span class="line">        <span class="built_in">BOOL</span> finished = (totalSize &gt;= <span class="keyword">self</span>.expectedSize);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果图片解码器不存在</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>.progressiveCoder) &#123;</span><br><span class="line">            <span class="comment">// 因为增量解码需要保留解码后的上下文，我们将为每个下载操作分配一个具有相同类的新实例，以避免冲突</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">id</span>&lt;SDWebImageCoder&gt;coder <span class="keyword">in</span> [SDWebImageCodersManager sharedInstance].coders) &#123;</span><br><span class="line">                <span class="keyword">if</span> ([coder conformsToProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">SDWebImageProgressiveCoder</span>)] &amp;&amp;</span></span><br><span class="line">                    [((<span class="keyword">id</span>&lt;SDWebImageProgressiveCoder&gt;)coder) canIncrementallyDecodeFromData:imageData]) &#123;</span><br><span class="line">                    <span class="keyword">self</span>.progressiveCoder = [[[coder <span class="keyword">class</span>] alloc] init];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 逐步解码编码器队列中的图像，自定义串行队列异步执行</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.coderQueue, ^&#123;</span><br><span class="line">           <span class="comment">//解码生成图片（增量解码图像数据到图像）</span></span><br><span class="line">            <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span>.progressiveCoder incrementallyDecodedImageWithData:imageData finished:finished];</span><br><span class="line">             <span class="comment">//如果图片存在，通过URL获取key，再对image进行缩放操作</span></span><br><span class="line">            <span class="keyword">if</span> (image) &#123;</span><br><span class="line">                <span class="built_in">NSString</span> *key = [[SDWebImageManager sharedManager] cacheKeyForURL:<span class="keyword">self</span>.request.URL];</span><br><span class="line">                <span class="comment">//image进行缩放操作</span></span><br><span class="line">                image = [<span class="keyword">self</span> scaledImageForKey:key image:image];</span><br><span class="line">                <span class="comment">//如果需要压缩图片，就执行压缩操作</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.shouldDecompressImages) &#123;</span><br><span class="line">                    image = [[SDWebImageCodersManager sharedInstance] decompressedImageWithImage:image data:&amp;imageData options:@&#123;SDWebImageCoderScaleDownLargeImagesKey: @(<span class="literal">NO</span>)&#125;];</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//当`finished`=YES时，不再保留逐行解码图片。 因为它们用于视图渲染但不从下载器选项中获取全部功能。 并且一些编码器实现可能在逐行解码和正常解码之间不一致。</span></span><br><span class="line">                <span class="comment">//进行完成回调</span></span><br><span class="line">                [<span class="keyword">self</span> callCompletionBlocksWithImage:image imageData:<span class="literal">nil</span> error:<span class="literal">nil</span> finished:<span class="literal">NO</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回调进度</span></span><br><span class="line">    <span class="keyword">for</span> (SDWebImageDownloaderProgressBlock progressBlock <span class="keyword">in</span> [<span class="keyword">self</span> callbacksForKey:kProgressCallbackKey]) &#123;</span><br><span class="line">        progressBlock(<span class="keyword">self</span>.imageData.length, <span class="keyword">self</span>.expectedSize, <span class="keyword">self</span>.request.URL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当NSURLSessionDataTask弯成接受所有预期数据后会调用这个代理方法，询问代理对象是否将响应存储在缓存中</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">          dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line"> willCacheResponse:(<span class="built_in">NSCachedURLResponse</span> *)proposedResponse</span><br><span class="line"> completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSCachedURLResponse</span> *cachedResponse))completionHandler &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取缓存响应</span></span><br><span class="line">    <span class="built_in">NSCachedURLResponse</span> *cachedResponse = proposedResponse;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果设置了缓存选项（SDWebImageDownloaderUseNSURLCache），就回调缓存响应，否则就回调nil，不缓存</span></span><br><span class="line">    <span class="keyword">if</span> (!(<span class="keyword">self</span>.options &amp; SDWebImageDownloaderUseNSURLCache)) &#123;</span><br><span class="line">        <span class="comment">// Prevents caching of responses</span></span><br><span class="line">        cachedResponse = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用完成代码块并传参</span></span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        completionHandler(cachedResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="NSURLSessionTaskDelegate-代理实现"><a href="#NSURLSessionTaskDelegate-代理实现" class="headerlink" title="NSURLSessionTaskDelegate 代理实现"></a>NSURLSessionTaskDelegate 代理实现</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当NSURLSessionTask已经完成传输数据时会调用这个代理方法</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session task:(<span class="built_in">NSURLSessionTask</span> *)task didCompleteWithError:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line">    <span class="comment">//同步锁</span></span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">//将保存任务对象的属性置为nil</span></span><br><span class="line">        <span class="keyword">self</span>.dataTask = <span class="literal">nil</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//主队列异步发送下载停止通知，如果没有错误，发送下载结束通知</span></span><br><span class="line">        __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadStopNotification object:weakSelf];</span><br><span class="line">            <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">                [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadFinishNotification object:weakSelf];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果出错就回调错误，并调用完成方法</span></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        [<span class="keyword">self</span> callCompletionBlocksWithError:error];</span><br><span class="line">        [<span class="keyword">self</span> done];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果有完成回调的代码块</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> callbacksForKey:kCompletedCallbackKey].count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 如果您指定使用`NSURLCache`，那么您在此处获得的响应就是您所需要的。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">             <span class="comment">//如果有下载的imageData</span></span><br><span class="line">            __block <span class="built_in">NSData</span> *imageData = [<span class="keyword">self</span>.imageData <span class="keyword">copy</span>];</span><br><span class="line">            <span class="keyword">if</span> (imageData) &#123;</span><br><span class="line">                <span class="comment">/**  if you specified to only use cached data via `SDWebImageDownloaderIgnoreCachedResponse`,</span></span><br><span class="line"><span class="comment">                 *  then we should check if the cached data is equal to image data</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                 如果设置了忽略缓存响应选项（SDWebImageDownloaderIgnoreCachedResponse），并且缓存数据和下载的图片数据相同</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.options &amp; SDWebImageDownloaderIgnoreCachedResponse &amp;&amp; [<span class="keyword">self</span>.cachedData isEqualToData:imageData]) &#123;</span><br><span class="line">                    <span class="comment">//回调完成block nil，并调用完成方法</span></span><br><span class="line">                    [<span class="keyword">self</span> callCompletionBlocksWithImage:<span class="literal">nil</span> imageData:<span class="literal">nil</span> error:<span class="literal">nil</span> finished:<span class="literal">YES</span>];</span><br><span class="line">                    [<span class="keyword">self</span> done];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 在自定义串行异步执行</span></span><br><span class="line">                    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.coderQueue, ^&#123;</span><br><span class="line">                      <span class="comment">//对下载图片数据进行解码，通过imageData获取图片</span></span><br><span class="line">                        <span class="built_in">UIImage</span> *image = [[SDWebImageCodersManager sharedInstance] decodedImageWithData:imageData];</span><br><span class="line">                        <span class="comment">//获取图片url对应的key</span></span><br><span class="line">                        <span class="built_in">NSString</span> *key = [[SDWebImageManager sharedManager] cacheKeyForURL:<span class="keyword">self</span>.request.URL];</span><br><span class="line">                        <span class="comment">//图片缩放操作</span></span><br><span class="line">                        image = [<span class="keyword">self</span> scaledImageForKey:key image:image];</span><br><span class="line">                        <span class="comment">//生成变量图片是否应该解码，</span></span><br><span class="line">                        <span class="built_in">BOOL</span> shouldDecode = <span class="literal">YES</span>;</span><br><span class="line">                        <span class="comment">// 如果是gif动态图片（图片组）就不需要解码</span></span><br><span class="line">                        <span class="keyword">if</span> (image.images) &#123;</span><br><span class="line">                            shouldDecode = <span class="literal">NO</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#ifdef SD_WEBP              </span></span><br><span class="line">                            <span class="comment">//如果是webp个事的也不需要解码</span></span><br><span class="line">                            SDImageFormat imageFormat = [<span class="built_in">NSData</span> sd_imageFormatForImageData:imageData];</span><br><span class="line">                            <span class="keyword">if</span> (imageFormat == SDImageFormatWebP) &#123;</span><br><span class="line">                                shouldDecode = <span class="literal">NO</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//如果需要解码，执行解码操作</span></span><br><span class="line">                        <span class="keyword">if</span> (shouldDecode) &#123;</span><br><span class="line">                            <span class="comment">//是否需要解压图片，需要就执行解压操作</span></span><br><span class="line">                            <span class="keyword">if</span> (<span class="keyword">self</span>.shouldDecompressImages) &#123;</span><br><span class="line">                                <span class="comment">//是否需要缩小图片</span></span><br><span class="line">                                <span class="built_in">BOOL</span> shouldScaleDown = <span class="keyword">self</span>.options &amp; SDWebImageDownloaderScaleDownLargeImages;</span><br><span class="line">                                <span class="comment">//解压操作</span></span><br><span class="line">                                image = [[SDWebImageCodersManager sharedInstance] decompressedImageWithImage:image data:&amp;imageData options:@&#123;SDWebImageCoderScaleDownLargeImagesKey: @(shouldScaleDown)&#125;];</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//获取处理好的图片尺寸</span></span><br><span class="line">                        <span class="built_in">CGSize</span> imageSize = image.size;</span><br><span class="line">                        <span class="comment">//如果图片的宽或者长为0，就回调错误，否则回调完成block</span></span><br><span class="line">                        <span class="keyword">if</span> (imageSize.width == <span class="number">0</span> || imageSize.height == <span class="number">0</span>) &#123;</span><br><span class="line">                            [<span class="keyword">self</span> callCompletionBlocksWithError:[<span class="built_in">NSError</span> errorWithDomain:SDWebImageErrorDomain code:<span class="number">0</span> userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span> : <span class="string">@"Downloaded image has 0 pixels"</span>&#125;]];</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">//回调完成</span></span><br><span class="line">                            [<span class="keyword">self</span> callCompletionBlocksWithImage:image imageData:imageData error:<span class="literal">nil</span> finished:<span class="literal">YES</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//调用完成方法</span></span><br><span class="line">                        [<span class="keyword">self</span> done];</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果没有下载的图片数据，就回调错误，并执行完成方法</span></span><br><span class="line">                [<span class="keyword">self</span> callCompletionBlocksWithError:[<span class="built_in">NSError</span> errorWithDomain:SDWebImageErrorDomain code:<span class="number">0</span> userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span> : <span class="string">@"Image data is nil"</span>&#125;]];</span><br><span class="line">                [<span class="keyword">self</span> done];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果没有完成回调代码块，直接执行完成方法</span></span><br><span class="line">            [<span class="keyword">self</span> done];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当task接受到身份验证时，会回调这个代理方法</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session task:(<span class="built_in">NSURLSessionTask</span> *)task didReceiveChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition, <span class="built_in">NSURLCredential</span> *credential))completionHandler &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置临时变量保存数据</span></span><br><span class="line">    <span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</span><br><span class="line">    __block <span class="built_in">NSURLCredential</span> *credential = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//若验证方式为NSURLAuthenticationMethodServerTrust</span></span><br><span class="line">    <span class="keyword">if</span> ([challenge.protectionSpace.authenticationMethod isEqualToString:<span class="built_in">NSURLAuthenticationMethodServerTrust</span>]) &#123;</span><br><span class="line">        <span class="comment">//如果没有设置允许不可信的SSL证书，就设置蓄力方式为默认的NSURLSessionAuthChallengePerformDefaultHandling，否则就设置验证模式为指定证书验证，并生成证书</span></span><br><span class="line">        <span class="keyword">if</span> (!(<span class="keyword">self</span>.options &amp; SDWebImageDownloaderAllowInvalidSSLCertificates)) &#123;</span><br><span class="line">            disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            credential = [<span class="built_in">NSURLCredential</span> credentialForTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">            disposition = <span class="built_in">NSURLSessionAuthChallengeUseCredential</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//若验证方式不是NSURLAuthenticationMethodServerTrust</span></span><br><span class="line">        <span class="keyword">if</span> (challenge.previousFailureCount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//判断是否有证书，如果有就设置证书，验证模式为通过指定证书验证，否则就设置验证模式为不需要验证证书</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.credential) &#123;</span><br><span class="line">                credential = <span class="keyword">self</span>.credential;</span><br><span class="line">                disposition = <span class="built_in">NSURLSessionAuthChallengeUseCredential</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                disposition = <span class="built_in">NSURLSessionAuthChallengeCancelAuthenticationChallenge</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果认证的失败次数设置超过0次，就设置验证模式为不需要验证证书</span></span><br><span class="line">            disposition = <span class="built_in">NSURLSessionAuthChallengeCancelAuthenticationChallenge</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用完成代码并传参</span></span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition, credential);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Helper-methods"><a href="#Helper-methods" class="headerlink" title="Helper methods"></a>Helper methods</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//缩放操作</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)scaledImageForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key image:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image &#123;</span><br><span class="line">    <span class="keyword">return</span> SDScaledImageForKey(key, image);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否允许app后台继续下载图片</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)shouldContinueWhenAppEntersBackground &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.options &amp; SDWebImageDownloaderContinueInBackground;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误完成回调方法</span></span><br><span class="line">- (<span class="keyword">void</span>)callCompletionBlocksWithError:(<span class="keyword">nullable</span> <span class="built_in">NSError</span> *)error &#123;</span><br><span class="line">    [<span class="keyword">self</span> callCompletionBlocksWithImage:<span class="literal">nil</span> imageData:<span class="literal">nil</span> error:error finished:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//完成回调方法</span></span><br><span class="line">- (<span class="keyword">void</span>)callCompletionBlocksWithImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image</span><br><span class="line">                            imageData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)imageData</span><br><span class="line">                                error:(<span class="keyword">nullable</span> <span class="built_in">NSError</span> *)error</span><br><span class="line">                             finished:(<span class="built_in">BOOL</span>)finished &#123;</span><br><span class="line">    <span class="built_in">NSArray</span>&lt;<span class="keyword">id</span>&gt; *completionBlocks = [<span class="keyword">self</span> callbacksForKey:kCompletedCallbackKey];</span><br><span class="line">    dispatch_main_async_safe(^&#123;</span><br><span class="line">        <span class="keyword">for</span> (SDWebImageDownloaderCompletedBlock completedBlock <span class="keyword">in</span> completionBlocks) &#123;</span><br><span class="line">            completedBlock(image, imageData, error, finished);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;SDWebImage&lt;/code&gt; 的图片下载是由 &lt;code&gt;SDWebImageDownloader&lt;/code&gt; 类实现的，该类是一个异步下载管理器。主要工作是下载相关配置项的管理，包括下载队列的先后顺序、最大下载任务数量控制、下载队列中的任务创建、取消、
      
    
    </summary>
    
      <category term="读SDWebImage手札" scheme="http://guohuaden.com/categories/%E8%AF%BBSDWebImage%E6%89%8B%E6%9C%AD/"/>
    
    
      <category term="SDWebImage" scheme="http://guohuaden.com/tags/SDWebImage/"/>
    
  </entry>
  
  <entry>
    <title>读 SDWebImage 四 (SDWebImageDownloader)</title>
    <link href="http://guohuaden.com/2018/10/04/Read-SDWebImage-SDWebImageDownloader/"/>
    <id>http://guohuaden.com/2018/10/04/Read-SDWebImage-SDWebImageDownloader/</id>
    <published>2018-10-04T11:38:50.000Z</published>
    <updated>2018-10-25T11:23:06.489Z</updated>
    
    <content type="html"><![CDATA[<p><code>SDWebImage</code> 的图片下载是由 <code>SDWebImageDownloader</code> 这个类实现的，该类是一个异步下载管理器。主要工作是下载相关配置项的管理，包括下载队列的先后顺序、最大下载任务数量控制、下载队列中的任务创建、取消、暂停等任务管理，以及其他的 <code>HTTPS</code> 和 <code>HTTP Header</code> 的设置。而真正实现图片下载的是 <code>SDWebImageDownloaderOperation</code>类。该类的 <code>Operation</code> 操作依赖系统提供的NSURLConnection类来实现图片的下载。</p><h3 id="下载选项"><a href="#下载选项" class="headerlink" title="下载选项"></a>下载选项</h3><p>枚举列出不同的下载选项 （选项使用掩码形式，如 <code>1 &lt;&lt; 2</code> 表示将1左移2位，即：00000010，也就是2。）<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, SDWebImageDownloaderOptions) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认模式，将下载放入低优先级队列 和 低优先级任务中</span></span><br><span class="line">    SDWebImageDownloaderLowPriority = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该选项启用渐进式下载，图像在下载过程中逐步显示，就像浏览器一样。（该选项在返回进度Block的同时也返回completedBlock，里面的UIImage就是当前下载时的图片，可以实现将图片一点点显示出来的功能）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SDWebImageDownloaderProgressiveDownload = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认情况下，http请求会阻止使用NSURLCache。 使用此标志，NSURLCache将与默认策略一起使用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SDWebImageDownloaderUseNSURLCache = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果从NSURLCache缓存中读取图片，则使用nil作为image/imageData的参数来调用block代码块。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SDWebImageDownloaderIgnoreCachedResponse = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在iOS 4+ 系统中，允许程序进入后台后继续下载图片，该操作通过向系统申请额外的时间来完成后台下载请求，如果后台任务终止，则操作被取消。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SDWebImageDownloaderContinueInBackground = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过设置NSMutableURLRequest，HTTPShouldHandleCookies =  YES来处理存储在NSHTTPCookieStore中的cookie;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SDWebImageDownloaderHandleCookies = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *允许允许不受信任的SSL证书。用于测试目的。 在生产中谨慎使用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SDWebImageDownloaderAllowInvalidSSLCertificates = <span class="number">1</span> &lt;&lt; <span class="number">6</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将下载放入高队列优先级和高任务优先级中。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SDWebImageDownloaderHighPriority = <span class="number">1</span> &lt;&lt; <span class="number">7</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缩小图像（默认情况下，图片会按照它的原始大小来解码显示。这个属性会根据设备的内存限制调整图片的尺寸到合适的大小。如果`SDWebImageProgressiveDownload`标记被设置了，则这个flag不起作用。）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SDWebImageDownloaderScaleDownLargeImages = <span class="number">1</span> &lt;&lt; <span class="number">8</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="下载操作的执行顺序"><a href="#下载操作的执行顺序" class="headerlink" title="下载操作的执行顺序"></a>下载操作的执行顺序</h3><p>两种执行顺序： 先进先出 和 后进先出<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="type">NS_ENUM</span>(<span class="type">NSInteger</span>, <span class="type">SDWebImageDownloaderExecutionOrder</span>) &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 默认值。 所有下载操作都将以队列样式执行（先进先出）。</span><br><span class="line">     */</span><br><span class="line">    <span class="type">SDWebImageDownloaderFIFOExecutionOrder</span>,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 所有下载操作都将以栈的方式执行（后进先出）。</span><br><span class="line">     */</span><br><span class="line">    <span class="type">SDWebImageDownloaderLIFOExecutionOrder</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="外部定义的系统通知标示"><a href="#外部定义的系统通知标示" class="headerlink" title="外部定义的系统通知标示"></a>外部定义的系统通知标示</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开始下载通知</span></span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * _Nonnull <span class="keyword">const</span> SDWebImageDownloadStartNotification;</span><br><span class="line"><span class="comment">//停止下载通知</span></span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * _Nonnull <span class="keyword">const</span> SDWebImageDownloadStopNotification;</span><br></pre></td></tr></table></figure><h3 id="两个代码块"><a href="#两个代码块" class="headerlink" title="两个代码块"></a>两个代码块</h3><p>每个下载操作的下载进度回调和下载完成回调，这两个回调稍后将保存在下载管理器的URLCallbacks字典中，key为URL，value为一个数组，数组里面又存放一个保存了下载进度回调和完成回调代码块的字典。<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//下载进度代码块</span><br><span class="line">typedef void(^<span class="type">SDWebImageDownloaderProgressBlock</span>)(<span class="type">NSInteger</span> receivedSize, <span class="type">NSInteger</span> expectedSize, <span class="type">NSURL</span> * _Nullable targetURL);</span><br><span class="line">//下载完成回调代码块</span><br><span class="line">typedef void(^<span class="type">SDWebImageDownloaderCompletedBlock</span>)(<span class="type">UIImage</span> * _Nullable image, <span class="type">NSData</span> * _Nullable data, <span class="type">NSError</span> * _Nullable error, <span class="type">BOOL</span> finished);</span><br></pre></td></tr></table></figure></p><h3 id="三个字典"><a href="#三个字典" class="headerlink" title="三个字典"></a>三个字典</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求头字典</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="built_in">NSString</span> *&gt; SDHTTPHeadersDictionary;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSMutableDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="built_in">NSString</span> *&gt; SDHTTPHeadersMutableDictionary;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义请求头，通过Block传值，可以拿到一些参数，然后加工成我们需要的数据，最后返回</span></span><br><span class="line"><span class="keyword">typedef</span> SDHTTPHeadersDictionary * _Nullable (^SDWebImageDownloaderHeadersFilterBlock)(<span class="built_in">NSURL</span> * _Nullable url, SDHTTPHeadersDictionary * _Nullable headers);</span><br></pre></td></tr></table></figure><h3 id="SDWebImageDownloadToken"><a href="#SDWebImageDownloadToken" class="headerlink" title="SDWebImageDownloadToken"></a>SDWebImageDownloadToken</h3><p>作为下载操作的唯一标识，在创建 <code>operation</code> 的时候初始化绑定，当需要去 <code>cancel</code> 操作的时候就需要这个 <code>token</code>。<br><code>SDWebImageDownloadToken</code> 为每一个下载任务的唯一身份标识，<code>SDWebImageDownloader</code> 和我们平时开发中的下载有一些不同，它弱化了下载过程，比较强调的是下载结果，不支持断点下载。</p><h4 id="h文件"><a href="#h文件" class="headerlink" title=".h文件"></a>.h文件</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">SDWebImageDownloadToken </span>: NSObject &lt;SDWebImageOperation&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">下载的URL。 这应该是只读的，你不应该修改</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="variable">@property</span> (nonatomic, strong, nullable) NSURL *url;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 取消token 可以从 “id downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock]” 方法获得，这应该是只读的，你不应该修改。</span></span><br><span class="line"><span class="comment"> @note 使用 `-[SDWebImageDownloadToken cancel]`方法去取消下载token</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="variable">@property</span> (nonatomic, strong, nullable) id downloadOperationCancelToken;</span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure><h4 id="m文件"><a href="#m文件" class="headerlink" title=".m文件"></a>.m文件</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SDWebImageDownloadToken</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下载操作</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>, <span class="keyword">nullable</span>) <span class="built_in">NSOperation</span>&lt;SDWebImageDownloaderOperationInterface&gt; *downloadOperation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SDWebImageDownloadToken</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//取消下载</span></span><br><span class="line">- (<span class="keyword">void</span>)cancel &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.downloadOperation) &#123;</span><br><span class="line">        SDWebImageDownloadToken *cancelToken = <span class="keyword">self</span>.downloadOperationCancelToken;</span><br><span class="line">        <span class="keyword">if</span> (cancelToken) &#123;</span><br><span class="line">            [<span class="keyword">self</span>.downloadOperation cancel:cancelToken];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h2 id="SDWebImageDownloader-h文件"><a href="#SDWebImageDownloader-h文件" class="headerlink" title="SDWebImageDownloader.h文件"></a>SDWebImageDownloader.h文件</h2><h3 id="属性声明"><a href="#属性声明" class="headerlink" title="属性声明"></a>属性声明</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解压缩下载和缓存的图像可以提高性能，但会占用大量内存。</span></span><br><span class="line"><span class="comment"> * 默认是YES. 如果由于过多的内存消耗而遇到崩溃，可以设置为NO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//当图片下载完成以后，解码图片。如果因为过多的内存消耗导致一个奔溃，可以把这个属性设置为NO</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> shouldDecompressImages;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最大兵法下载数目</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSInteger</span> maxConcurrentDownloads;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 显示仍需要下载的当前下载量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> currentDownloadCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  下载操作的超时值（秒为单位），默认15秒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSTimeInterval</span> downloadTimeout;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内部NSURLSession使用的配置</span></span><br><span class="line"><span class="comment"> * 直接变换此对象无效</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @see createNewSessionWithConfiguration:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSURLSessionConfiguration</span> *sessionConfiguration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 改变下载操作的执行顺序 默认值是 `SDWebImageDownloaderFIFOExecutionOrder`.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) SDWebImageDownloaderExecutionOrder executionOrder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  设置要为请求操作设置的默认URL凭据。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">NSURLCredential</span> *urlCredential;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置用户名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">NSString</span> *username;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置密码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">NSString</span> *password;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置过滤器以选择用于下载图像HTTP请求的标头</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 将为每个下载图像请求调用此块，返回的NSDictionary将用作相应HTTP请求中的标头。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//http头部的过滤函数</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) SDWebImageDownloaderHeadersFilterBlock headersFilter;</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下载管理器单例函数</span></span><br><span class="line">+ (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)sharedDownloader;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用指定的会话配置创建下载程序的实例。（初始化方法）</span></span><br><span class="line"><span class="comment"> * @note `timeoutIntervalForRequest` 将被覆盖</span></span><br><span class="line"><span class="comment"> * @return 下载器的新事例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)initWithSessionConfiguration:(<span class="keyword">nullable</span> <span class="built_in">NSURLSessionConfiguration</span> *)sessionConfiguration <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置要附加到每个下载HTTP请求的HTTP标头的值。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param value The value for the header field. 值为 `nil` 移除请求头文件.</span></span><br><span class="line"><span class="comment"> * @param field 设置http请求头部字段.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)value forHTTPHeaderField:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)field;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回指定的HTTP标头字段的值。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return 与标题字段字段关联的值，如果没有相应的标题字段，则为“nil”。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)valueForHTTPHeaderField:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)field;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 将`SDWebImageDownloaderOperation`的子类设置为默认值</span></span><br><span class="line"><span class="comment">  * 每次SDWebImage构造请求时都要使用`NSOperation`</span></span><br><span class="line"><span class="comment">  * 下载图像的操作。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * @param operationClass要设置的`SDWebImageDownloaderOperation`的子类</span></span><br><span class="line"><span class="comment">  *默认。 传递`nil`将恢复为`SDWebImageDownloaderOperation`。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">- (<span class="keyword">void</span>)setOperationClass:(<span class="keyword">nullable</span> Class)operationClass;</span><br><span class="line"></span><br><span class="line">/ **</span><br><span class="line">  * 使用给定的URL创建SDWebImageDownloader异步下载器实例</span><br><span class="line">  *</span><br><span class="line">  * 图像完成下载或发生错误时将通知代理。</span><br><span class="line">  *</span><br><span class="line">  * @see SDWebImageDownloaderDelegate</span><br><span class="line">  *</span><br><span class="line">  * @param url要下载的图像的URL</span><br><span class="line">  * @param options用于此下载的选项</span><br><span class="line">  * @param progressBlock在下载图像时重复调用的块</span><br><span class="line">  * @note在后台队列上执行进度块</span><br><span class="line">  * @param completedBlock下载完成后调用的块。</span><br><span class="line">  * 如果下载成功，则设置image参数，如果出错，</span><br><span class="line">  * 错误参数设置为错误。最后一个参数始终为<span class="literal">YES</span></span><br><span class="line">  * 如果没有使用SDWebImageDownloaderProgressiveDownload。随着</span><br><span class="line">  * SDWebImageDownloaderProgressiveDownload选项，调用此块</span><br><span class="line">  * 重复使用部分图像对象，并将完成的参数设置为<span class="literal">NO</span></span><br><span class="line">  * 之前用完整的图像和完成的参数调用最后一次</span><br><span class="line">  * 设为是。如果出错，则完成的参数始终为<span class="literal">YES</span>。</span><br><span class="line">  *</span><br><span class="line">  * @return可以传递给-cancel的令牌（SDWebImageDownloadToken）：取消此操作</span><br><span class="line">  * /</span><br><span class="line">- (<span class="keyword">nullable</span> SDWebImageDownloadToken *)downloadImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">                                                   options:(SDWebImageDownloaderOptions)options</span><br><span class="line">                                                  progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                                 completed:(<span class="keyword">nullable</span> SDWebImageDownloaderCompletedBlock)completedBlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取消之前使用排队的下载 获取token使用 “-downloadImageWithURL:options:progress:completed:”方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param token 从“-downloadImageWithURL:options:progress:completed:”方法获取的token应该被取消</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)cancel:(<span class="keyword">nullable</span> SDWebImageDownloadToken *)token;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置下载队列挂起状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)setSuspended:(<span class="built_in">BOOL</span>)suspended;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取消队列中的所有下载操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)cancelAllDownloads;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 强制SDWebImageDownloader 创建和使用一个给定配置的初始化NSURLSession（队列中的所有现有下载操作都将被取消；请求超时的时间也被重写）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param sessionConfiguration 使用新的NSURLSession配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)createNewSessionWithConfiguration:(<span class="keyword">nonnull</span> <span class="built_in">NSURLSessionConfiguration</span> *)sessionConfiguration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * //取消operation并且session设置为Invalidates （如果您使用自定义下载程序而不是共享下载程序，则在不使用它时避免内存泄漏时需要调用此方法）</span></span><br><span class="line"><span class="comment"> * @param cancelPendingOperations 是否取消挂起的操作。</span></span><br><span class="line"><span class="comment"> * @note 在共享下载程序上调用此方法无效。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)invalidateSessionAndCancel:(<span class="built_in">BOOL</span>)cancelPendingOperations;</span><br></pre></td></tr></table></figure><h2 id="SDWebImageDownloader-m文件"><a href="#SDWebImageDownloader-m文件" class="headerlink" title="SDWebImageDownloader.m文件"></a>SDWebImageDownloader.m文件</h2><h3 id="属性声明-1"><a href="#属性声明-1" class="headerlink" title="属性声明"></a>属性声明</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SDWebImageDownloader</span> () &lt;<span class="title">NSURLSessionTaskDelegate</span>, <span class="title">NSURLSessionDataDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下载队列</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSOperationQueue</span> *downloadQueue;</span><br><span class="line"><span class="comment">//最新添加的操作</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">NSOperation</span> *lastAddedOperation;</span><br><span class="line"><span class="comment">//操作的类</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) Class operationClass;</span><br><span class="line"><span class="comment">//下载操作的集合</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSMutableDictionary</span>&lt;<span class="built_in">NSURL</span> *, SDWebImageDownloaderOperation *&gt; *URLOperations;</span><br><span class="line"><span class="comment">//HTTP头文件集合</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) SDHTTPHeadersMutableDictionary *HTTPHeaders;</span><br><span class="line"><span class="comment">//操作锁</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) dispatch_semaphore_t operationsLock; <span class="comment">// a lock to keep the access to `URLOperations` thread-safe</span></span><br><span class="line"><span class="comment">//头文件锁</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) dispatch_semaphore_t headersLock; <span class="comment">// a lock to keep the access to `HTTPHeaders` thread-safe</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The session in which data tasks will run</span></span><br><span class="line"><span class="comment">//NSURLSession</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSURLSession</span> *session;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h4 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h4><p><code>SDWebImageDownloader</code> 提供了一个initialize方法 四个初始化方法和一个注销方法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)initialize &#123;</span><br><span class="line">    <span class="comment">//绑定SDNetworkActivityIndicator（如果可用），如果使用它，需要导入"SDNetworkActivityIndicator.h"头文件</span></span><br><span class="line">    <span class="comment">//主要是用来加载图片的时候，状态栏会转小菊花。（该方法是为了给图片下载绑定一个SDNetworkActivityIndicator，只有当这个SDNetworkActivityIndicator文件存在的情况下才会执行，目的就是当下载图片时，状态栏会转小菊花。）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NSClassFromString</span>(<span class="string">@"SDNetworkActivityIndicator"</span>)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//LLVM 3.0 编译器可以用以下代码消除 warning </span></span><br><span class="line"><span class="meta">#pragma clang diagnostic push</span></span><br><span class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Warc-performSelector-leaks"</span></span></span><br><span class="line">        <span class="keyword">id</span> activityIndicator = [<span class="built_in">NSClassFromString</span>(<span class="string">@"SDNetworkActivityIndicator"</span>) performSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"sharedActivityIndicator"</span>)];</span><br><span class="line"><span class="meta">#pragma clang diagnostic pop</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果之前已经添加，先移除观察者</span></span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:activityIndicator name:SDWebImageDownloadStartNotification object:<span class="literal">nil</span>];</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:activityIndicator name:SDWebImageDownloadStopNotification object:<span class="literal">nil</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//添加观察者</span></span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:activityIndicator</span><br><span class="line">                                                 selector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"startActivity"</span>)</span><br><span class="line">                                                     name:SDWebImageDownloadStartNotification object:<span class="literal">nil</span>];</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:activityIndicator</span><br><span class="line">                                                 selector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"stopActivity"</span>)</span><br><span class="line">                                                     name:SDWebImageDownloadStopNotification object:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单例，返回SDWebImageDownloader对象</span></span><br><span class="line">+ (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)sharedDownloader &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> once;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">id</span> instance;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;once, ^&#123;</span><br><span class="line">        instance = [<span class="keyword">self</span> new];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithSessionConfiguration:[<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个请求对象</span></span><br><span class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)initWithSessionConfiguration:(<span class="keyword">nullable</span> <span class="built_in">NSURLSessionConfiguration</span> *)sessionConfiguration &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) &#123;</span><br><span class="line">        _operationClass = [SDWebImageDownloaderOperation <span class="keyword">class</span>];</span><br><span class="line">        _shouldDecompressImages = <span class="literal">YES</span>;</span><br><span class="line">        _executionOrder = SDWebImageDownloaderFIFOExecutionOrder;</span><br><span class="line">        _downloadQueue = [<span class="built_in">NSOperationQueue</span> new];</span><br><span class="line">        _downloadQueue.maxConcurrentOperationCount = <span class="number">6</span>;</span><br><span class="line">        _downloadQueue.name = <span class="string">@"com.hackemist.SDWebImageDownloader"</span>;</span><br><span class="line">        _URLOperations = [<span class="built_in">NSMutableDictionary</span> new];</span><br><span class="line"><span class="meta">#ifdef SD_WEBP</span></span><br><span class="line">        _HTTPHeaders = [@&#123;<span class="string">@"Accept"</span>: <span class="string">@"image/webp,image/*;q=0.8"</span>&#125; mutableCopy];</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">        _HTTPHeaders = [@&#123;<span class="string">@"Accept"</span>: <span class="string">@"image/*;q=0.8"</span>&#125; mutableCopy];</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">        _operationsLock = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">        _headersLock = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">        _downloadTimeout = <span class="number">15.0</span>;</span><br><span class="line"></span><br><span class="line">        [<span class="keyword">self</span> createNewSessionWithConfiguration:sessionConfiguration];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个新的请求对象</span></span><br><span class="line">- (<span class="keyword">void</span>)createNewSessionWithConfiguration:(<span class="built_in">NSURLSessionConfiguration</span> *)sessionConfiguration &#123;</span><br><span class="line">    [<span class="keyword">self</span> cancelAllDownloads];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.session) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.session invalidateAndCancel];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sessionConfiguration.timeoutIntervalForRequest = <span class="keyword">self</span>.downloadTimeout;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Create the session for this task</span></span><br><span class="line"><span class="comment">     *  We send nil as delegate queue so that the session creates a serial operation queue for performing all delegate</span></span><br><span class="line"><span class="comment">     *  method calls and completion handler calls.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">self</span>.session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:sessionConfiguration</span><br><span class="line">                                                 delegate:<span class="keyword">self</span></span><br><span class="line">                                            delegateQueue:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///取消operation并且session设置为Invalidates</span></span><br><span class="line">- (<span class="keyword">void</span>)invalidateSessionAndCancel:(<span class="built_in">BOOL</span>)cancelPendingOperations &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> == [SDWebImageDownloader sharedDownloader]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cancelPendingOperations) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.session invalidateAndCancel];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span>.session finishTasksAndInvalidate];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    [<span class="keyword">self</span>.session invalidateAndCancel];</span><br><span class="line">    <span class="keyword">self</span>.session = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.downloadQueue cancelAllOperations];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Set-和-Get-方法"><a href="#Set-和-Get-方法" class="headerlink" title="Set 和 Get 方法"></a><code>Set</code> 和 <code>Get</code> 方法</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置请求报文头部</span></span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)value forHTTPHeaderField:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)field &#123;</span><br><span class="line">    LOCK(<span class="keyword">self</span>.headersLock);</span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">        <span class="keyword">self</span>.HTTPHeaders[field] = value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span>.HTTPHeaders removeObjectForKey:field];</span><br><span class="line">    &#125;</span><br><span class="line">    UNLOCK(<span class="keyword">self</span>.headersLock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取请求报文头部</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)valueForHTTPHeaderField:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)field &#123;</span><br><span class="line">    <span class="keyword">if</span> (!field) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> allHTTPHeaderFields] objectForKey:field];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全部的请求报文头部</span></span><br><span class="line">- (<span class="keyword">nonnull</span> SDHTTPHeadersDictionary *)allHTTPHeaderFields &#123;</span><br><span class="line">    LOCK(<span class="keyword">self</span>.headersLock);</span><br><span class="line">    SDHTTPHeadersDictionary *allHTTPHeaderFields = [<span class="keyword">self</span>.HTTPHeaders <span class="keyword">copy</span>];</span><br><span class="line">    UNLOCK(<span class="keyword">self</span>.headersLock);</span><br><span class="line">    <span class="keyword">return</span> allHTTPHeaderFields;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置下载队列的最大并发数</span></span><br><span class="line">- (<span class="keyword">void</span>)setMaxConcurrentDownloads:(<span class="built_in">NSInteger</span>)maxConcurrentDownloads &#123;</span><br><span class="line">    _downloadQueue.maxConcurrentOperationCount = maxConcurrentDownloads;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取下载队列的当前operation数</span></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)currentDownloadCount &#123;</span><br><span class="line">    <span class="keyword">return</span> _downloadQueue.operationCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取下载队列的最大并发数</span></span><br><span class="line">- (<span class="built_in">NSInteger</span>)maxConcurrentDownloads &#123;</span><br><span class="line">    <span class="keyword">return</span> _downloadQueue.maxConcurrentOperationCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSURLSessionConfiguration</span> *)sessionConfiguration &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.session.configuration;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置一个`SDWebImageDownloaderOperation`的子类作为`NSOperation`来构建request来下载一张图片</span></span><br><span class="line">- (<span class="keyword">void</span>)setOperationClass:(<span class="keyword">nullable</span> Class)operationClass &#123;</span><br><span class="line">    <span class="keyword">if</span> (operationClass &amp;&amp; [operationClass isSubclassOfClass:[<span class="built_in">NSOperation</span> <span class="keyword">class</span>]] &amp;&amp; [operationClass conformsToProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">SDWebImageDownloaderOperationInterface</span>)]) </span>&#123;</span><br><span class="line">        _operationClass = operationClass;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _operationClass = [SDWebImageDownloaderOperation <span class="keyword">class</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="下载方法"><a href="#下载方法" class="headerlink" title="下载方法"></a>下载方法</h4><p>下载管理器的主要实现为 <code>downloadImageWithURL:options:progress:completed:</code> 方法(调用该方法创建 <code>operation</code> 操作)，这个方法调用 <code>- (void)addProgressCallback:completedBlock:forURL: createCallback:</code> 方法来将请求的信息和一些回调函数存入管理器中，同时在创建回调的 <code>block</code> 中创建新 <code>operation</code> 操作,新的操作由管理器中存储的信息配置后，放入到 <code>downloadQueue</code> 操作队列中，最后返回新创建的操作<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 下载图片</span></span><br><span class="line"><span class="comment"> @param url 图片url</span></span><br><span class="line"><span class="comment"> @param options 下载选项</span></span><br><span class="line"><span class="comment"> @param progressBlock 下载进度blockhui</span></span><br><span class="line"><span class="comment"> @param completedBlock 下载完成block</span></span><br><span class="line"><span class="comment"> @return  返回一个SDWebImageDownloadToken，用于关联一个请求</span></span><br><span class="line"><span class="comment">    调用addProgressCallback方法 return token，addProgressCallback的回调里进行以下操作</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        1.1设置下载时间</span></span><br><span class="line"><span class="comment">        1.2创建request</span></span><br><span class="line"><span class="comment">        1.3创建operation对象 传入 request session options</span></span><br><span class="line"><span class="comment">        1.4设置身份认证</span></span><br><span class="line"><span class="comment">        1.5设置下载优先级</span></span><br><span class="line"><span class="comment">        1.6设置下载顺序</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nullable</span> SDWebImageDownloadToken *)downloadImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">                                                   options:(SDWebImageDownloaderOptions)options</span><br><span class="line">                                                  progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                                 completed:(<span class="keyword">nullable</span> SDWebImageDownloaderCompletedBlock)completedBlock &#123;</span><br><span class="line">    __<span class="keyword">weak</span> SDWebImageDownloader *wself = <span class="keyword">self</span>;</span><br><span class="line">    <span class="comment">// 调用- (void)addProgressCallback:completedBlock:forURL: createCallback:方法来将请求的信息和一些回调函数存入管理器中，同时在创建回调的block中创建新operation操作,新的操作由管理器中存储的信息配置后，放入到downloadQueue操作队列中，最后返回新创建的操作</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^SDWebImageDownloaderOperation *&#123;</span><br><span class="line">        __<span class="keyword">strong</span> __<span class="keyword">typeof</span> (wself) sself = wself;</span><br><span class="line">        <span class="comment">//获取超时时间，如果没有设置，默认为15秒</span></span><br><span class="line">        <span class="built_in">NSTimeInterval</span> timeoutInterval = sself.downloadTimeout;</span><br><span class="line">        <span class="keyword">if</span> (timeoutInterval == <span class="number">0.0</span>) &#123;</span><br><span class="line">            timeoutInterval = <span class="number">15.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为了防止潜在的重复缓存（NSURLCache 和 SDImageCache同时缓存），如果另有说明，我们会禁用图像请求的缓存</span></span><br><span class="line">        <span class="built_in">NSURLRequestCachePolicy</span> cachePolicy = options &amp; SDWebImageDownloaderUseNSURLCache ? <span class="built_in">NSURLRequestUseProtocolCachePolicy</span> : <span class="built_in">NSURLRequestReloadIgnoringLocalCacheData</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建请求对象，并根据options参数设置其属性</span></span><br><span class="line">        <span class="built_in">NSMutableURLRequest</span> *request = [[<span class="built_in">NSMutableURLRequest</span> alloc] initWithURL:url</span><br><span class="line">                                                                    cachePolicy:cachePolicy</span><br><span class="line">                                                                timeoutInterval:timeoutInterval];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用cookies</span></span><br><span class="line">        request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies);</span><br><span class="line">        <span class="comment">//使用管道</span></span><br><span class="line">        request.HTTPShouldUsePipelining = <span class="literal">YES</span>;</span><br><span class="line">        <span class="comment">//添加自定义请求头</span></span><br><span class="line">        <span class="keyword">if</span> (sself.headersFilter) &#123;</span><br><span class="line">            request.allHTTPHeaderFields = sself.headersFilter(url, [sself allHTTPHeaderFields]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            request.allHTTPHeaderFields = [sself allHTTPHeaderFields];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化一个自定义NSOperation对象</span></span><br><span class="line">        SDWebImageDownloaderOperation *operation = [[sself.operationClass alloc] initWithRequest:request inSession:sself.session options:options];</span><br><span class="line">        <span class="comment">//当图片下载完成以后，解码图片。如果因为过多的内存消耗导致一个奔溃，可以把这个属性设置为NO</span></span><br><span class="line">        operation.shouldDecompressImages = sself.shouldDecompressImages;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//指定验证信息（url证书）</span></span><br><span class="line">        <span class="keyword">if</span> (sself.urlCredential) &#123;</span><br><span class="line">            operation.credential = sself.urlCredential;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sself.username &amp;&amp; sself.password) &#123;</span><br><span class="line">            <span class="comment">//基础验证</span></span><br><span class="line">            operation.credential = [<span class="built_in">NSURLCredential</span> credentialWithUser:sself.username password:sself.password persistence:<span class="built_in">NSURLCredentialPersistenceForSession</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//指定优先级</span></span><br><span class="line">        <span class="keyword">if</span> (options &amp; SDWebImageDownloaderHighPriority) &#123;</span><br><span class="line">            operation.queuePriority = <span class="built_in">NSOperationQueuePriorityHigh</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options &amp; SDWebImageDownloaderLowPriority) &#123;</span><br><span class="line">            operation.queuePriority = <span class="built_in">NSOperationQueuePriorityLow</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//指定下载顺序（ 如果是LIFO这种模式，则需要手动指定operation之间的依赖关系）</span></span><br><span class="line">        <span class="keyword">if</span> (sself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</span><br><span class="line">            <span class="comment">// 如果是LIFO，则让前面的operation依赖于最新添加的operation</span></span><br><span class="line">            [sself.lastAddedOperation addDependency:operation];</span><br><span class="line">            sself.lastAddedOperation = operation;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> operation;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取消一个图片的下载操作</span></span><br><span class="line">- (<span class="keyword">void</span>)cancel:(<span class="keyword">nullable</span> SDWebImageDownloadToken *)token &#123;</span><br><span class="line">    <span class="comment">//如果url不存在，则返回</span></span><br><span class="line">    <span class="built_in">NSURL</span> *url = token.url;</span><br><span class="line">    <span class="keyword">if</span> (!url) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取该操作，通过token来确定操作是否取消（移除），如果取消，则在URLOperations中移除url</span></span><br><span class="line">    LOCK(<span class="keyword">self</span>.operationsLock);</span><br><span class="line">    SDWebImageDownloaderOperation *operation = [<span class="keyword">self</span>.URLOperations objectForKey:url];</span><br><span class="line">    <span class="keyword">if</span> (operation) &#123;</span><br><span class="line">        <span class="built_in">BOOL</span> canceled = [operation cancel:token.downloadOperationCancelToken];</span><br><span class="line">        <span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">            [<span class="keyword">self</span>.URLOperations removeObjectForKey:url];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    UNLOCK(<span class="keyword">self</span>.operationsLock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给下载过程添加进度</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    1.生成URLOperations字典 下载url作为key value是具体的下载operation</span></span><br><span class="line"><span class="comment">    2.将操作添加到操作队列中</span></span><br><span class="line"><span class="comment">    3.将进度progressBlock和下载结束completedBlock封装成字典SDCallbacksDictionary，装入数组callbackBlocks，</span></span><br><span class="line"><span class="comment">    4.生成token标识，并返回token</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">nullable</span> SDWebImageDownloadToken *)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                           completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock</span><br><span class="line">                                                   forURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">                                           createCallback:(SDWebImageDownloaderOperation *(^)(<span class="keyword">void</span>))createCallback &#123;</span><br><span class="line">    <span class="comment">// url作为回调字典里的key，因此url不能为空，如果url为空则立即调用已完成代码块（image、imageData都传nil），并直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (url == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (completedBlock != <span class="literal">nil</span>) &#123;</span><br><span class="line">            completedBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">NO</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LOCK(<span class="keyword">self</span>.operationsLock);</span><br><span class="line">    获取url下载的操作</span><br><span class="line">    SDWebImageDownloaderOperation *operation = [<span class="keyword">self</span>.URLOperations objectForKey:url];</span><br><span class="line">    <span class="comment">// 有一种情况是操作可能被标记为已完成，但未从“self.URLOperations”中删除。</span></span><br><span class="line">    <span class="keyword">if</span> (!operation || operation.isFinished) &#123;</span><br><span class="line">    <span class="comment">//创建一个operation，并且添加到URLOperation中</span></span><br><span class="line">        operation = createCallback();</span><br><span class="line">        __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) wself = <span class="keyword">self</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//设置operation操作完成以后的回调</span></span><br><span class="line">        operation.completionBlock = ^&#123;</span><br><span class="line">            __<span class="keyword">strong</span> <span class="keyword">typeof</span>(wself) sself = wself;</span><br><span class="line">            <span class="keyword">if</span> (!sself) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            LOCK(sself.operationsLock);</span><br><span class="line">            <span class="comment">//完成以后从URLOperations中移除该URL的operation操作</span></span><br><span class="line">            [sself.URLOperations removeObjectForKey:url];</span><br><span class="line">            UNLOCK(sself.operationsLock);</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将该url的operation操作添加到URLOperations中</span></span><br><span class="line">        [<span class="keyword">self</span>.URLOperations setObject:operation forKey:url];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//仅在根据Apple的doc完成所有配置后才将操作添加到操作队列。`addOperation：`不同步执行`operation.completionBlock`，所以这不会导致死锁。</span></span><br><span class="line">        <span class="comment">//把operation添加进入NSOperationQueue中，当operation添加到downloadQueue，会触发相应的start方法，开始下载。</span></span><br><span class="line">        [<span class="keyword">self</span>.downloadQueue addOperation:operation];</span><br><span class="line">    &#125;</span><br><span class="line">    UNLOCK(<span class="keyword">self</span>.operationsLock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取downloadOperationCancelToken</span></span><br><span class="line">    <span class="keyword">id</span> downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建一个新的token，给各属性赋值，并返回token</span></span><br><span class="line">    SDWebImageDownloadToken *token = [SDWebImageDownloadToken new];</span><br><span class="line">    token.downloadOperation = operation;</span><br><span class="line">    token.url = url;</span><br><span class="line">    token.downloadOperationCancelToken = downloadOperationCancelToken;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> token;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置下载队列全部暂停/开始</span></span><br><span class="line">- (<span class="keyword">void</span>)setSuspended:(<span class="built_in">BOOL</span>)suspended &#123;</span><br><span class="line">    <span class="keyword">self</span>.downloadQueue.suspended = suspended;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全部取消下载队列中的下载操作</span></span><br><span class="line">- (<span class="keyword">void</span>)cancelAllDownloads &#123;</span><br><span class="line">    [<span class="keyword">self</span>.downloadQueue cancelAllOperations];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark Helper methods</span></span><br><span class="line"><span class="comment">//根据task获取下载操作operation</span></span><br><span class="line">- (SDWebImageDownloaderOperation *)operationWithTask:(<span class="built_in">NSURLSessionTask</span> *)task &#123;</span><br><span class="line">    SDWebImageDownloaderOperation *returnOperation = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">for</span> (SDWebImageDownloaderOperation *operation <span class="keyword">in</span> <span class="keyword">self</span>.downloadQueue.operations) &#123;</span><br><span class="line">        <span class="keyword">if</span> (operation.dataTask.taskIdentifier == task.taskIdentifier) &#123;</span><br><span class="line">            returnOperation = operation;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> returnOperation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="NSURLSessionDataDelegate"><a href="#NSURLSessionDataDelegate" class="headerlink" title="NSURLSessionDataDelegate"></a>NSURLSessionDataDelegate</h4><p>当收到数据的时候，会触发这些代理方法，最后调用SDWebImageDownloaderOperation中的代理方法，来实际处理事情。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="string">URLSession:</span>(NSURLSession *)session</span><br><span class="line"><span class="symbol">          dataTask:</span>(NSURLSessionDataTask *)dataTask</span><br><span class="line"><span class="string">didReceiveResponse:</span>(NSURLResponse *)response</span><br><span class="line"><span class="symbol"> completionHandler:</span>(<span class="keyword">void</span> (^)(NSURLSessionResponseDisposition disposition))completionHandler &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Identify the operation that runs this task and pass it the delegate method</span></span><br><span class="line">    SDWebImageDownloaderOperation *dataOperation = [self <span class="string">operationWithTask:</span>dataTask];</span><br><span class="line">    <span class="keyword">if</span> ([dataOperation <span class="string">respondsToSelector:</span><span class="meta">@selector</span>(<span class="string">URLSession:</span><span class="string">dataTask:</span><span class="string">didReceiveResponse:</span><span class="string">completionHandler:</span>)]) &#123;</span><br><span class="line">        [dataOperation <span class="string">URLSession:</span>session <span class="string">dataTask:</span>dataTask <span class="string">didReceiveResponse:</span>response <span class="string">completionHandler:</span>completionHandler];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">            completionHandler(NSURLSessionResponseAllow);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">URLSession:</span>(NSURLSession *)session <span class="string">dataTask:</span>(NSURLSessionDataTask *)dataTask <span class="string">didReceiveData:</span>(NSData *)data &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Identify the operation that runs this task and pass it the delegate method</span></span><br><span class="line">    SDWebImageDownloaderOperation *dataOperation = [self <span class="string">operationWithTask:</span>dataTask];</span><br><span class="line">    <span class="keyword">if</span> ([dataOperation <span class="string">respondsToSelector:</span><span class="meta">@selector</span>(<span class="string">URLSession:</span><span class="string">dataTask:</span><span class="string">didReceiveData:</span>)]) &#123;</span><br><span class="line">        [dataOperation <span class="string">URLSession:</span>session <span class="string">dataTask:</span>dataTask <span class="string">didReceiveData:</span>data];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">URLSession:</span>(NSURLSession *)session</span><br><span class="line"><span class="symbol">          dataTask:</span>(NSURLSessionDataTask *)dataTask</span><br><span class="line"><span class="symbol"> willCacheResponse:</span>(NSCachedURLResponse *)proposedResponse</span><br><span class="line"><span class="symbol"> completionHandler:</span>(<span class="keyword">void</span> (^)(NSCachedURLResponse *cachedResponse))completionHandler &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Identify the operation that runs this task and pass it the delegate method</span></span><br><span class="line">    SDWebImageDownloaderOperation *dataOperation = [self <span class="string">operationWithTask:</span>dataTask];</span><br><span class="line">    <span class="keyword">if</span> ([dataOperation <span class="string">respondsToSelector:</span><span class="meta">@selector</span>(<span class="string">URLSession:</span><span class="string">dataTask:</span><span class="string">willCacheResponse:</span><span class="string">completionHandler:</span>)]) &#123;</span><br><span class="line">        [dataOperation <span class="string">URLSession:</span>session <span class="string">dataTask:</span>dataTask <span class="string">willCacheResponse:</span>proposedResponse <span class="string">completionHandler:</span>completionHandler];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">            completionHandler(proposedResponse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="NSURLSessionTaskDelegate"><a href="#NSURLSessionTaskDelegate" class="headerlink" title="NSURLSessionTaskDelegate"></a>NSURLSessionTaskDelegate</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="string">URLSession:</span>(NSURLSession *)session <span class="string">task:</span>(NSURLSessionTask *)task <span class="string">didCompleteWithError:</span>(NSError *)error &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Identify the operation that runs this task and pass it the delegate method</span></span><br><span class="line">    SDWebImageDownloaderOperation *dataOperation = [self <span class="string">operationWithTask:</span>task];</span><br><span class="line">    <span class="keyword">if</span> ([dataOperation <span class="string">respondsToSelector:</span><span class="meta">@selector</span>(<span class="string">URLSession:</span><span class="string">task:</span><span class="string">didCompleteWithError:</span>)]) &#123;</span><br><span class="line">        [dataOperation <span class="string">URLSession:</span>session <span class="string">task:</span>task <span class="string">didCompleteWithError:</span>error];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">URLSession:</span>(NSURLSession *)session <span class="string">task:</span>(NSURLSessionTask *)task <span class="string">willPerformHTTPRedirection:</span>(NSHTTPURLResponse *)response <span class="string">newRequest:</span>(NSURLRequest *)request <span class="string">completionHandler:</span>(<span class="keyword">void</span> (^)(NSURLRequest * _Nullable))completionHandler &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Identify the operation that runs this task and pass it the delegate method</span></span><br><span class="line">    SDWebImageDownloaderOperation *dataOperation = [self <span class="string">operationWithTask:</span>task];</span><br><span class="line">    <span class="keyword">if</span> ([dataOperation <span class="string">respondsToSelector:</span><span class="meta">@selector</span>(<span class="string">URLSession:</span><span class="string">task:</span><span class="string">willPerformHTTPRedirection:</span><span class="string">newRequest:</span><span class="string">completionHandler:</span>)]) &#123;</span><br><span class="line">        [dataOperation <span class="string">URLSession:</span>session <span class="string">task:</span>task <span class="string">willPerformHTTPRedirection:</span>response <span class="string">newRequest:</span>request <span class="string">completionHandler:</span>completionHandler];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">            completionHandler(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">URLSession:</span>(NSURLSession *)session <span class="string">task:</span>(NSURLSessionTask *)task <span class="string">didReceiveChallenge:</span>(NSURLAuthenticationChallenge *)challenge <span class="string">completionHandler:</span>(<span class="keyword">void</span> (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Identify the operation that runs this task and pass it the delegate method</span></span><br><span class="line">    SDWebImageDownloaderOperation *dataOperation = [self <span class="string">operationWithTask:</span>task];</span><br><span class="line">    <span class="keyword">if</span> ([dataOperation <span class="string">respondsToSelector:</span><span class="meta">@selector</span>(<span class="string">URLSession:</span><span class="string">task:</span><span class="string">didReceiveChallenge:</span><span class="string">completionHandler:</span>)]) &#123;</span><br><span class="line">        [dataOperation <span class="string">URLSession:</span>session <span class="string">task:</span>task <span class="string">didReceiveChallenge:</span>challenge <span class="string">completionHandler:</span>completionHandler];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">            completionHandler(NSURLSessionAuthChallengePerformDefaultHandling, nil);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;SDWebImage&lt;/code&gt; 的图片下载是由 &lt;code&gt;SDWebImageDownloader&lt;/code&gt; 这个类实现的，该类是一个异步下载管理器。主要工作是下载相关配置项的管理，包括下载队列的先后顺序、最大下载任务数量控制、下载队列中的任务创建、取
      
    
    </summary>
    
      <category term="读SDWebImage手札" scheme="http://guohuaden.com/categories/%E8%AF%BBSDWebImage%E6%89%8B%E6%9C%AD/"/>
    
    
      <category term="SDWebImage" scheme="http://guohuaden.com/tags/SDWebImage/"/>
    
  </entry>
  
  <entry>
    <title>读 SDWebImage 三 (SDImageCache)</title>
    <link href="http://guohuaden.com/2018/10/02/Read-SDWebImage-SDImageCache/"/>
    <id>http://guohuaden.com/2018/10/02/Read-SDWebImage-SDImageCache/</id>
    <published>2018-10-02T02:38:36.000Z</published>
    <updated>2018-10-25T11:22:37.616Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h3><p><code>SDImageCache</code> 是 <code>SDWebImage</code> 处理图片缓存的类。图片的存储是针对内存和磁盘有一点区别：内存中直接存储图片，磁盘中存中 <code>imagedata</code><br>在 <code>SDWebImageManager</code> 中使用的存储图片、判断图片是否已存储在磁盘/内存等方法均是调用该类中的方法。<code>SDWebImage</code> 设计时做了很好的分工，以至于去分析代码都带有一种享受感。</p><blockquote><p>简单做个思考，如果自己实现一个缓存类，需要做哪些东西：<br>1、初始化、缓存地址。<br>3、查询、删除、存储方法（增删改查功能）<br>4、计算缓存大小<br>5、计算缓存数量…</p></blockquote><p>然后在接下来的分析中看看跟自己的思路的偏差：</p><p>在 <code>SDImageCache</code> 的 <code>.h</code> 文件中引用了 <code>SDWebImageCompat</code> 和 <code>SDImageCacheConfig</code> 头文件。<code>SDWebImageCompat</code> 类在 <code>SDWebImageManager</code> 结尾已经分析过，该类只包含一个方法，用来实现图片缩放的操作。</p><p><code>SDImageCacheConfig</code> 类则是管理缓存配置信息的，这里先单独拉出来看下</p><h3 id="2、SDImageCacheConfig-类"><a href="#2、SDImageCacheConfig-类" class="headerlink" title="2、SDImageCacheConfig 类"></a>2、<code>SDImageCacheConfig</code> 类</h3><p><code>SDImageCacheConfig</code> 类是用于配置缓存信息的，继承自 <code>NSObject</code>。</p><h4 id="2-1、-h文件"><a href="#2-1、-h文件" class="headerlink" title="2.1、.h文件"></a>2.1、.h文件</h4><p>缓存配置过期类型，枚举<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="type">NS_ENUM</span>(<span class="type">NSUInteger</span>, <span class="type">SDImageCacheConfigExpireType</span>) &#123;</span><br><span class="line">    //访问图片时，它将更新此值 （访问日期）</span><br><span class="line">    <span class="type">SDImageCacheConfigExpireTypeAccessDate</span>,</span><br><span class="line">    //图片从磁盘缓存中获取 （修改日期）</span><br><span class="line">    <span class="type">SDImageCacheConfigExpireTypeModificationDate</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>定义配置属性如下<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解压缩下载和缓存的图片可以提高性能，但会占用大量内存。</span></span><br><span class="line"><span class="comment"> * 默认为YES。 如果由于过多的内存消耗而遇到崩溃，请将此项设置为NO。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//是否解压图片，默认YES</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> shouldDecompressImages;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否禁用iCloud备份，默认YES</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> shouldDisableiCloud;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否使用内存缓存，默认YES</span></span><br><span class="line"><span class="comment"> * 禁用内存缓存时，也会禁用弱内存缓存。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> shouldCacheImagesInMemory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 控制图片的弱内存缓存的选项.启用时, SDImageCache 的内存缓存将使用弱映射表在存储到内存的同时存储图像，并同时删除.</span></span><br><span class="line"><span class="comment"> * 但是当触发内存警告时，由于弱映射表没有强烈的图像实例引用，即使内存缓存本身被清除，UIImageViews或其他实时实例强烈保留的一些图像也可以再次恢复，以避免 稍后从磁盘缓存或网络重新查询。 这可能对这种情况有所帮助，例如，当app进入后台并清除内存时，会在重新输入前景后导致单元格闪烁。</span></span><br><span class="line"><span class="comment"> * 默认为YES。 您可以动态更改此选项。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//是否使用弱内存缓存，默认为YES</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> shouldUseWeakMemoryCache;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从磁盘读取缓存时的读取选项</span></span><br><span class="line"><span class="comment"> * 默认为 0. 可以设置为 `NSDataReadingMappedIfSafe` 以提高性能.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//磁盘缓存读取选项，枚举</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSDataReadingOptions</span> diskCacheReadingOptions;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将缓存写入磁盘时的写入选项</span></span><br><span class="line"><span class="comment"> * 默认为 NSDataWritingAtomic. 可以将其设置为 `NSDataWritingWithoutOverwriting` 以防止覆盖现有文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//磁盘缓存写入选项，枚举</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSDataWritingOptions</span> diskCacheWritingOptions;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在缓存中保留图片的最长时间，秒为单位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSInteger</span> maxCacheAge;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存的最大值，字节为单位，默认为0，表示不做限制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> maxCacheSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清理磁盘缓存时将检查清理缓存的属性</span></span><br><span class="line"><span class="comment"> * 默认修改日期</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//缓存配置过期类型，枚举 ，默认修改日期</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) SDImageCacheConfigExpireType diskCacheExpireType;</span><br></pre></td></tr></table></figure></p><h4 id="2-2、-m文件"><a href="#2-2、-m文件" class="headerlink" title="2.2、.m文件"></a>2.2、.m文件</h4><p>静态不可变 <code>NSInteger</code> 类型的 <code>kDefaultCacheMaxCacheAge</code> 表示在缓存中图像保存时间的最大长度，以秒为单位 默认是一周时间（60 ＊ 60 ＊ 24 ＊ 7）。<br><code>_maxCacheAge</code> 属性在 <code>.h</code> 中声明，可以外部修改。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSInteger</span> kDefaultCacheMaxCacheAge = <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">7</span>; <span class="comment">// 1 week</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//属性初始化赋值</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        _shouldDecompressImages = <span class="literal">YES</span>;</span><br><span class="line">        _shouldDisableiCloud = <span class="literal">YES</span>;</span><br><span class="line">        _shouldCacheImagesInMemory = <span class="literal">YES</span>;</span><br><span class="line">        _shouldUseWeakMemoryCache = <span class="literal">YES</span>;</span><br><span class="line">        _diskCacheReadingOptions = <span class="number">0</span>;</span><br><span class="line">        _diskCacheWritingOptions = <span class="built_in">NSDataWritingAtomic</span>;</span><br><span class="line">        _maxCacheAge = kDefaultCacheMaxCacheAge;</span><br><span class="line">        _maxCacheSize = <span class="number">0</span>;</span><br><span class="line">        _diskCacheExpireType = SDImageCacheConfigExpireTypeModificationDate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、SDImageCache类"><a href="#3、SDImageCache类" class="headerlink" title="3、SDImageCache类"></a>3、<code>SDImageCache</code>类</h3><p><code>SDImageCache</code> 维护内存缓存和可选的磁盘缓存。磁盘缓存写入操作是异步执行的，因此不会给UI增加不必要的延迟。</p><h4 id="3-1、-h文件"><a href="#3-1、-h文件" class="headerlink" title="3.1、.h文件"></a>3.1、.h文件</h4><p><strong>缓存类型，枚举</strong></p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="type">NS_ENUM</span>(<span class="type">NSInteger</span>, <span class="type">SDImageCacheType</span>) &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 图像不能用 <span class="type">SDWebImage</span> 缓存，但能从网上下载 （不缓存）。</span><br><span class="line">     */</span><br><span class="line">    <span class="type">SDImageCacheTypeNone</span>,</span><br><span class="line">    /**</span><br><span class="line">     * 图片从磁盘中获取（缓存到磁盘中）</span><br><span class="line">     */</span><br><span class="line">    <span class="type">SDImageCacheTypeDisk</span>,</span><br><span class="line">    /**</span><br><span class="line">     *图片从内存中获取（缓存到内存中）</span><br><span class="line">     */</span><br><span class="line">    <span class="type">SDImageCacheTypeMemory</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>缓存选项，枚举</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, SDImageCacheOptions) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认情况下，当图像缓存在内存中时，我们不查询磁盘数据。 此选项可以强制同时查询磁盘数据。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SDImageCacheQueryDataWhenInMemory = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认情况下，我们同步查询内存缓存，异步查询磁盘缓存。 此选项可以强制同步查询磁盘缓存。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SDImageCacheQueryDiskSync = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认情况下，图像会根据其原始大小进行解码。在iOS上，此选项会将图像缩小到与设备的受限内存兼容的大小。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SDImageCacheScaleDownLargeImages = <span class="number">1</span> &lt;&lt; <span class="number">2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>三个回调代码块</strong></p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//查询完成的block</span><br><span class="line">typedef void(^<span class="type">SDCacheQueryCompletedBlock</span>)(<span class="type">UIImage</span> * _Nullable image, <span class="type">NSData</span> * _Nullable data, <span class="type">SDImageCacheType</span> cacheType);</span><br><span class="line"></span><br><span class="line">//检查完成的block</span><br><span class="line">typedef void(^<span class="type">SDWebImageCheckCacheCompletionBlock</span>)(<span class="type">BOOL</span> isInCache);</span><br><span class="line"></span><br><span class="line">//计算缓存大小的block</span><br><span class="line">typedef void(^<span class="type">SDWebImageCalculateSizeBlock</span>)(<span class="type">NSUInteger</span> fileCount, <span class="type">NSUInteger</span> totalSize);</span><br></pre></td></tr></table></figure><p><strong>SDImageCache的属性 </strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  缓存配置对象，存储所有类型的设置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>, <span class="keyword">readonly</span>) SDImageCacheConfig *config;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置缓存中最大的消耗的内存，这里计算的是内存中的像素个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> maxMemoryCost;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存应持有的对象的的最大数量。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> maxMemoryCountLimit;</span><br></pre></td></tr></table></figure><p><strong>SDImageCache的单例和初始化</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回全局共享缓存实例</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return SDImageCache全局实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)sharedImageCache;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用特定命名空间初始化一个新的缓存存储，里面就是去获取磁盘缓存路径，然后在进行一系列的初始化操作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param ns 用于此缓存存储的命名空间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)initWithNamespace:(<span class="keyword">nonnull</span> <span class="built_in">NSString</span> *)ns;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用特定的命名空间和目录初始化一个新的缓存存储</span></span><br><span class="line"><span class="comment"> * @param ns 用于此缓存存储的命名空间</span></span><br><span class="line"><span class="comment"> * @param directory 用于缓存磁盘映像的目录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)initWithNamespace:(<span class="keyword">nonnull</span> <span class="built_in">NSString</span> *)ns</span><br><span class="line">                       diskCacheDirectory:(<span class="keyword">nonnull</span> <span class="built_in">NSString</span> *)directory <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br></pre></td></tr></table></figure><p><strong>缓存路径</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化磁盘缓存路径</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)makeDiskCachePath:(<span class="keyword">nonnull</span> <span class="built_in">NSString</span>*)fullNamespace;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加只读缓存路径用来搜索由SDImageCache预先缓存的图片</span></span><br><span class="line"><span class="comment"> * 如果想要预先加载的图片和应用程序捆绑在一起，则非常有用。去找图片也可以在这个路径中添加</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param path 此只读缓存路径使用的路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)addReadOnlyCachePath:(<span class="keyword">nonnull</span> <span class="built_in">NSString</span> *)path;</span><br></pre></td></tr></table></figure><p><strong>存储操作</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据key将图片异步缓存到内存和磁盘中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param image           需要缓存的图片</span></span><br><span class="line"><span class="comment"> * @param key             唯一的缓存图片的key,通常是图像的绝对URL</span></span><br><span class="line"><span class="comment"> * @param completionBlock 操作完成后执行的块</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)storeImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image</span><br><span class="line">            forKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key</span><br><span class="line">        completion:(<span class="keyword">nullable</span> SDWebImageNoParamsBlock)completionBlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据key将图片异步缓存到内存和磁盘中</span></span><br><span class="line"><span class="comment"> * （根据toDisk来判断是否要存储到磁盘中，这里的磁盘缓存是可选的）</span></span><br><span class="line"><span class="comment"> * @param image           需要缓存的图片</span></span><br><span class="line"><span class="comment"> * @param key            唯一的缓存图片的key,通常是图像的绝对URL</span></span><br><span class="line"><span class="comment"> * @param toDisk          是否缓存到磁盘中</span></span><br><span class="line"><span class="comment"> * @param completionBlock 操作完成后执行的块</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)storeImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image</span><br><span class="line">            forKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key</span><br><span class="line">            toDisk:(<span class="built_in">BOOL</span>)toDisk</span><br><span class="line">        completion:(<span class="keyword">nullable</span> SDWebImageNoParamsBlock)completionBlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据key将图片异步缓存到内存和磁盘中</span></span><br><span class="line"><span class="comment"> * （这里面的方法会根据imageData如果没有，但是image有的话，就会考虑到图片格式的问题）</span></span><br><span class="line"><span class="comment"> * @param image         需要缓存的图片</span></span><br><span class="line"><span class="comment"> * @param imageData     服务器返回的图像数据，此表示将用于磁盘存储，而不是将给定的图像对象转换为可存储/压缩的图像格式，以节省质量和CPU</span></span><br><span class="line"><span class="comment"> * @param key            唯一的缓存图片的key,通常是图像的绝对URL</span></span><br><span class="line"><span class="comment"> * @param toDisk          是否缓存到磁盘中</span></span><br><span class="line"><span class="comment"> * @param completionBlock 操作完成后执行的块</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)storeImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image</span><br><span class="line">         imageData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)imageData</span><br><span class="line">            forKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key</span><br><span class="line">            toDisk:(<span class="built_in">BOOL</span>)toDisk</span><br><span class="line">        completion:(<span class="keyword">nullable</span> SDWebImageNoParamsBlock)completionBlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据key将图片data同步缓存到内存和磁盘中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param imageData  需要缓存的图片data</span></span><br><span class="line"><span class="comment"> * @param key       唯一的缓存图片的key,通常是图像的绝对URL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)storeImageDataToDisk:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)imageData forKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key;</span><br></pre></td></tr></table></figure><p><strong>查询和检索操作</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  异步检查磁盘缓存中是否存在图片（不加载图片），回调返回结果</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param key             描述url的key</span></span><br><span class="line"><span class="comment"> *  @param completionBlock 检查完成时要执行的块。</span></span><br><span class="line"><span class="comment"> *  @note  将在主队列上始终执行完成块</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)diskImageExistsWithKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key completion:(<span class="keyword">nullable</span> SDWebImageCheckCacheCompletionBlock)completionBlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  同步检查磁盘缓存中是否存在图片（不加载图片），直接返回结果</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param key             描述url的key</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)diskImageDataExistsWithKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  根据key同步查询图片数据data</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param key 用来存储所需图片唯一的key</span></span><br><span class="line"><span class="comment"> *  @return  根据key返回查找的图片，如果未找到，返回nil</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)diskImageDataForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步查询缓存并在完成后调用完成的操作。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param key      用来存储所需图片唯一的key</span></span><br><span class="line"><span class="comment"> * @param doneBlock The completion block. 如果操作被取消，则不会被调用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return       包含缓存操作的NSOperation实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSOperation</span> *)queryCacheOperationForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key done:(<span class="keyword">nullable</span> SDCacheQueryCompletedBlock)doneBlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步查询缓存并在完成后调用完成的操作。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param key      用来存储所需图片唯一的key</span></span><br><span class="line"><span class="comment"> * @param options  用于指定用于此高速缓存查询的选项</span></span><br><span class="line"><span class="comment"> * @param doneBlock The completion block. 如果操作被取消，则不会被调用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return     包含缓存操作的NSOperation实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSOperation</span> *)queryCacheOperationForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key options:(SDImageCacheOptions)options done:(<span class="keyword">nullable</span> SDCacheQueryCompletedBlock)doneBlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步查询内存缓存</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param key     用来存储所需图片唯一的key</span></span><br><span class="line"><span class="comment"> * @return 根据key返回查找的图片，如果未找到，返回nil</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)imageFromMemoryCacheForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步查询磁盘缓存</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param key 用来存储所需图片唯一的key</span></span><br><span class="line"><span class="comment"> * @return 根据key返回查找的图片，如果未找到，返回nil</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)imageFromDiskCacheForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查缓存后，同步查询缓存（磁盘或内存）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param key 用来存储所需图片唯一的key</span></span><br><span class="line"><span class="comment"> * @return 根据key返回查找的图片，如果未找到，返回nil</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)imageFromCacheForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key;</span><br></pre></td></tr></table></figure><p><strong>移除操作</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从内存或者磁盘缓存中异步移除图片</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key            唯一的图片缓存key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> completion      删除图像后应执行的块（可选）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">removeImageForKey:</span>(nullable NSString *)key <span class="string">withCompletion:</span>(nullable SDWebImageNoParamsBlock)completion;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从内存和可选磁盘缓存中异步移除图片</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key            唯一的图片缓存key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromDisk        是否也从磁盘中移除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> completion      删除图像后应执行的块（可选）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">removeImageForKey:</span>(nullable NSString *)key <span class="string">fromDisk:</span>(BOOL)fromDisk <span class="string">withCompletion:</span>(nullable SDWebImageNoParamsBlock)completion;</span><br></pre></td></tr></table></figure><p><strong>缓存清理操作</strong></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清理所有的内存缓存图片</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">clearMemory</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步清除所有磁盘缓存的图片。 非阻塞方法 - 立即返回。</span></span><br><span class="line"><span class="comment"> * @param completion   缓存过期完成后应执行的块（可选）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">clearDiskOnCompletion</span><span class="selector-pseudo">:(nullable</span> <span class="selector-tag">SDWebImageNoParamsBlock</span>)<span class="selector-tag">completion</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步从磁盘中删除所有过期的缓存图片。 非阻塞方法 - 立即返回。</span></span><br><span class="line"><span class="comment"> * @param completionBlock 缓存过期完成后应执行的块（可选）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">deleteOldFilesWithCompletionBlock</span><span class="selector-pseudo">:(nullable</span> <span class="selector-tag">SDWebImageNoParamsBlock</span>)<span class="selector-tag">completionBlock</span>;</span><br></pre></td></tr></table></figure><p><strong>缓存信息</strong></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取磁盘缓存使用的大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="selector-tag">-</span> (NSUInteger)<span class="selector-tag">getSize</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取磁盘缓存中的图片数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="selector-tag">-</span> (NSUInteger)<span class="selector-tag">getDiskCount</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步计算磁盘缓存的大小。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">calculateSizeWithCompletionBlock</span><span class="selector-pseudo">:(nullable</span> <span class="selector-tag">SDWebImageCalculateSizeBlock</span>)<span class="selector-tag">completionBlock</span>;</span><br></pre></td></tr></table></figure><p><strong>缓存路径</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  需要根路径和key来查询文件所在的位置 (需要缓存路径根文件夹）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param key  the key (可以使用cacheKeyForURL从url获取)</span></span><br><span class="line"><span class="comment"> *  @param path 缓存路径根文件夹</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return 缓存路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)cachePathForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key inPath:(<span class="keyword">nonnull</span> <span class="built_in">NSString</span> *)path;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  根据key获取相应文件的默认的缓存路径</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param key the key (可以使用cacheKeyForURL从url获取)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return 默认的缓存路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)defaultCachePathForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key;</span><br></pre></td></tr></table></figure><h4 id="3-2、-m文件"><a href="#3-2、-m文件" class="headerlink" title="3.2、.m文件"></a>3.2、.m文件</h4><p>C语言函数，本质是计算diskImage所要占用的字节数。<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FOUNDATION_STATIC_INLINE NSUInteger SDCacheCostForImage(UIImage *<span class="built_in">image</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SD_MAC</span></span><br><span class="line">    <span class="built_in">return</span> <span class="built_in">image</span>.<span class="built_in">size</span>.<span class="built_in">height</span> * <span class="built_in">image</span>.<span class="built_in">size</span>.<span class="built_in">width</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> SD_UIKIT || SD_WATCH</span></span><br><span class="line">    <span class="built_in">return</span> <span class="built_in">image</span>.<span class="built_in">size</span>.<span class="built_in">height</span> * <span class="built_in">image</span>.<span class="built_in">size</span>.<span class="built_in">width</span> * <span class="built_in">image</span>.scale * <span class="built_in">image</span>.scale;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>私有</strong><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Private</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SDMemoryCache</span> &lt;<span class="title">KeyType</span>, <span class="title">ObjectType</span>&gt; ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nonnull</span>) SDImageCacheConfig *config;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSMapTable</span>&lt;KeyType, ObjectType&gt; *weakCache; <span class="comment">// strong-weak cache</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nonnull</span>) dispatch_semaphore_t weakCacheLock; <span class="comment">// a lock to keep the access to `weakCache` thread-safe</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init <span class="built_in">NS_UNAVAILABLE</span>;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithConfig:(<span class="keyword">nonnull</span> SDImageCacheConfig *)config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SDMemoryCache</span></span></span><br><span class="line"></span><br><span class="line">目前这似乎没有用在macOS上（macOS使用虚拟内存，并且在内存警告时不清除缓存）。 所以我们只在iOS / tvOS平台上覆盖。</span><br><span class="line"><span class="comment">//但是将来可能会有更多的子类选项和功能。</span></span><br><span class="line"><span class="meta">#if SD_UIKIT</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    <span class="comment">//移除内存警告通知</span></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="keyword">self</span> name:<span class="built_in">UIApplicationDidReceiveMemoryWarningNotification</span> object:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithConfig:(SDImageCacheConfig *)config &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用存储二级缓存的强弱映射表。 按照NSCache不复制密钥的文档</span></span><br><span class="line">        <span class="comment">// 当内存警告，缓存被清除时，这很有用。 但是，图像实例可以由其他实例保留，例如imageViews和alive。</span></span><br><span class="line">        <span class="comment">// 在这种情况下，我们可以同步弱缓存，而不需要从磁盘缓存加载</span></span><br><span class="line">        <span class="keyword">self</span>.weakCache = [[<span class="built_in">NSMapTable</span> alloc] initWithKeyOptions:<span class="built_in">NSPointerFunctionsStrongMemory</span> valueOptions:<span class="built_in">NSPointerFunctionsWeakMemory</span> capacity:<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">self</span>.weakCacheLock = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">self</span>.config = config;</span><br><span class="line">        <span class="comment">//添加内粗警告的通知</span></span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></span><br><span class="line">                                                 selector:<span class="keyword">@selector</span>(didReceiveMemoryWarning:)</span><br><span class="line">                                                     name:<span class="built_in">UIApplicationDidReceiveMemoryWarningNotification</span></span><br><span class="line">                                                   object:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)didReceiveMemoryWarning:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">    <span class="comment">//只删除缓存，但保持弱缓存</span></span><br><span class="line">    [<span class="keyword">super</span> removeAllObjects];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `setObject:forKey:` 只需调用0即可，覆盖这就足够了</span></span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>)obj forKey:(<span class="keyword">id</span>)key cost:(<span class="built_in">NSUInteger</span>)g &#123;</span><br><span class="line">    <span class="comment">//调用系统的NSCache方法</span></span><br><span class="line">    [<span class="keyword">super</span> setObject:obj forKey:key cost:g];</span><br><span class="line">    <span class="comment">//如果缓存配置不使用弱内存缓存，返回</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.config.shouldUseWeakMemoryCache) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key &amp;&amp; obj) &#123;</span><br><span class="line">        <span class="comment">//若果key和obj存在，存储弱缓存</span></span><br><span class="line">        LOCK(<span class="keyword">self</span>.weakCacheLock);</span><br><span class="line">        [<span class="keyword">self</span>.weakCache setObject:obj forKey:key];</span><br><span class="line">        UNLOCK(<span class="keyword">self</span>.weakCacheLock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过key获取object</span></span><br><span class="line">- (<span class="keyword">id</span>)objectForKey:(<span class="keyword">id</span>)key &#123;</span><br><span class="line">    <span class="keyword">id</span> obj = [<span class="keyword">super</span> objectForKey:key];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.config.shouldUseWeakMemoryCache) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key &amp;&amp; !obj) &#123;</span><br><span class="line">        <span class="comment">// 若果key存在，obj不存在，存储弱缓存</span></span><br><span class="line">        LOCK(<span class="keyword">self</span>.weakCacheLock);</span><br><span class="line">        obj = [<span class="keyword">self</span>.weakCache objectForKey:key];</span><br><span class="line">        UNLOCK(<span class="keyword">self</span>.weakCacheLock);</span><br><span class="line">        <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">            <span class="comment">//同步缓存</span></span><br><span class="line">            <span class="built_in">NSUInteger</span> cost = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> ([obj isKindOfClass:[<span class="built_in">UIImage</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">                <span class="comment">//diskImage所要占用的字节数</span></span><br><span class="line">                cost = SDCacheCostForImage(obj);</span><br><span class="line">            &#125;</span><br><span class="line">            [<span class="keyword">super</span> setObject:obj forKey:key cost:cost];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据key移除对象</span></span><br><span class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="keyword">id</span>)key &#123;</span><br><span class="line">    [<span class="keyword">super</span> removeObjectForKey:key];</span><br><span class="line">    <span class="comment">//如果缓存配置不使用弱内存缓存，返回</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.config.shouldUseWeakMemoryCache) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key) &#123;</span><br><span class="line">        <span class="comment">// 如果key存在，移除缓存</span></span><br><span class="line">        LOCK(<span class="keyword">self</span>.weakCacheLock);</span><br><span class="line">        [<span class="keyword">self</span>.weakCache removeObjectForKey:key];</span><br><span class="line">        UNLOCK(<span class="keyword">self</span>.weakCacheLock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移除所有对象</span></span><br><span class="line">- (<span class="keyword">void</span>)removeAllObjects &#123;</span><br><span class="line">    [<span class="keyword">super</span> removeAllObjects];</span><br><span class="line">    <span class="comment">//如果缓存配置不使用弱内存缓存，返回</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.config.shouldUseWeakMemoryCache) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 手动删除也应该删除弱缓存</span></span><br><span class="line">    LOCK(<span class="keyword">self</span>.weakCacheLock);</span><br><span class="line">    [<span class="keyword">self</span>.weakCache removeAllObjects];</span><br><span class="line">    UNLOCK(<span class="keyword">self</span>.weakCacheLock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#else</span></span><br><span class="line"><span class="comment">//如果是macos，直接初始化</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithConfig:(SDImageCacheConfig *)config &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p><strong>属性</strong><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SDImageCache</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - 属性</span></span><br><span class="line"><span class="comment">//内存缓存</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) SDMemoryCache *memCache;</span><br><span class="line"><span class="comment">//磁盘缓存路径</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSString</span> *diskCachePath;</span><br><span class="line"><span class="comment">//自定义路径</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">NSMutableArray</span>&lt;<span class="built_in">NSString</span> *&gt; *customPaths;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">dispatch_queue_t</span> ioQueue;</span><br><span class="line"><span class="comment">//文件管理器</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSFileManager</span> *fileManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p><strong>初始化</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark - 单例, 初始化, dealloc</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)sharedImageCache &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> once;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">id</span> instance;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;once, ^&#123;</span><br><span class="line">        instance = [<span class="keyword">self</span> new];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="comment">//初始化，namespace 默认为：default</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithNamespace:<span class="string">@"default"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)initWithNamespace:(<span class="keyword">nonnull</span> <span class="built_in">NSString</span> *)ns &#123;</span><br><span class="line">    <span class="comment">//获取磁盘缓存路径，默认的是：~/default （ns为default，拼接到缓存路径的最后面）</span></span><br><span class="line">    <span class="built_in">NSString</span> *path = [<span class="keyword">self</span> makeDiskCachePath:ns];</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithNamespace:ns diskCacheDirectory:path];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)initWithNamespace:(<span class="keyword">nonnull</span> <span class="built_in">NSString</span> *)ns</span><br><span class="line">                       diskCacheDirectory:(<span class="keyword">nonnull</span> <span class="built_in">NSString</span> *)directory &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *fullNamespace = [<span class="string">@"com.hackemist.SDWebImageCache."</span> stringByAppendingString:ns];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建IO串行队列</span></span><br><span class="line">        _ioQueue = dispatch_queue_create(<span class="string">"com.hackemist.SDWebImageCache"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//初始化缓存配置</span></span><br><span class="line">        _config = [[SDImageCacheConfig alloc] init];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化内存缓存</span></span><br><span class="line">        _memCache = [[SDMemoryCache alloc] initWithConfig:_config];</span><br><span class="line">        _memCache.name = fullNamespace;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化磁盘缓存</span></span><br><span class="line">        <span class="keyword">if</span> (directory != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">//如果路径不为nil，在路径的结尾拼接fullNamespace</span></span><br><span class="line">            _diskCachePath = [directory stringByAppendingPathComponent:fullNamespace];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//如果路径为nil，获取路径</span></span><br><span class="line">            <span class="built_in">NSString</span> *path = [<span class="keyword">self</span> makeDiskCachePath:ns];</span><br><span class="line">            _diskCachePath = path;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dispatch_sync</span>(_ioQueue, ^&#123;</span><br><span class="line">            <span class="comment">//初始化文件管理器</span></span><br><span class="line">            <span class="keyword">self</span>.fileManager = [<span class="built_in">NSFileManager</span> new];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="meta">#if SD_UIKIT</span></span><br><span class="line">        <span class="comment">//添加删除通知</span></span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></span><br><span class="line">                                                 selector:<span class="keyword">@selector</span>(deleteOldFiles)</span><br><span class="line">                                                     name:<span class="built_in">UIApplicationWillTerminateNotification</span></span><br><span class="line">                                                   object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></span><br><span class="line">                                                 selector:<span class="keyword">@selector</span>(backgroundDeleteOldFiles)</span><br><span class="line">                                                     name:<span class="built_in">UIApplicationDidEnterBackgroundNotification</span></span><br><span class="line">                                                   object:<span class="literal">nil</span>];</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>缓存路径</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加只读缓存路径用来搜索由SDImageCache预先缓存的图片</span></span><br><span class="line">- (<span class="keyword">void</span>)addReadOnlyCachePath:(<span class="keyword">nonnull</span> <span class="built_in">NSString</span> *)path &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.customPaths) &#123;</span><br><span class="line">        <span class="keyword">self</span>.customPaths = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不包含就添加</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span>.customPaths containsObject:path]) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.customPaths addObject:path];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要根路径和key来查询文件所在的位置 (需要缓存路径根文件夹）</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)cachePathForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key inPath:(<span class="keyword">nonnull</span> <span class="built_in">NSString</span> *)path &#123;</span><br><span class="line">    <span class="comment">//根据key获取缓存文件名</span></span><br><span class="line">    <span class="built_in">NSString</span> *filename = [<span class="keyword">self</span> cachedFileNameForKey:key];</span><br><span class="line">    <span class="keyword">return</span> [path stringByAppendingPathComponent:filename];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据key获取默认缓存路径</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)defaultCachePathForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> cachePathForKey:key inPath:<span class="keyword">self</span>.diskCachePath];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据key获取缓存文件名</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)cachedFileNameForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *str = key.UTF8String;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        str = <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> r[CC_MD5_DIGEST_LENGTH];</span><br><span class="line">    CC_MD5(str, (CC_LONG)strlen(str), r);</span><br><span class="line">    <span class="built_in">NSURL</span> *keyURL = [<span class="built_in">NSURL</span> URLWithString:key];</span><br><span class="line">    <span class="built_in">NSString</span> *ext = keyURL ? keyURL.pathExtension : key.pathExtension;</span><br><span class="line">    <span class="built_in">NSString</span> *filename = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%@"</span>,</span><br><span class="line">                          r[<span class="number">0</span>], r[<span class="number">1</span>], r[<span class="number">2</span>], r[<span class="number">3</span>], r[<span class="number">4</span>], r[<span class="number">5</span>], r[<span class="number">6</span>], r[<span class="number">7</span>], r[<span class="number">8</span>], r[<span class="number">9</span>], r[<span class="number">10</span>],</span><br><span class="line">                          r[<span class="number">11</span>], r[<span class="number">12</span>], r[<span class="number">13</span>], r[<span class="number">14</span>], r[<span class="number">15</span>], ext.length == <span class="number">0</span> ? <span class="string">@""</span> : [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@".%@"</span>, ext]];</span><br><span class="line">    <span class="keyword">return</span> filename;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据fullNamespace获取磁盘缓存路径</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)makeDiskCachePath:(<span class="keyword">nonnull</span> <span class="built_in">NSString</span>*)fullNamespace &#123;</span><br><span class="line">    <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *paths = <span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSCachesDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>);</span><br><span class="line">    <span class="keyword">return</span> [paths[<span class="number">0</span>] stringByAppendingPathComponent:fullNamespace];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>存储操作</strong></p><p>根据key将图片异步缓存到内存和磁盘中（默认存到内存和磁盘）<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据key将图片异步缓存到内存和磁盘中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> image           需要缓存的图片</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key             唯一的缓存图片的key,通常是图像的绝对URL</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> completionBlock 操作完成后执行的块</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">storeImage:</span>(nullable UIImage *)image</span><br><span class="line"><span class="symbol">            forKey:</span>(nullable NSString *)key</span><br><span class="line"><span class="symbol">        completion:</span>(nullable SDWebImageNoParamsBlock)completionBlock &#123;</span><br><span class="line">    [self <span class="string">storeImage:</span>image <span class="string">imageData:</span>nil <span class="string">forKey:</span>key <span class="string">toDisk:</span>YES <span class="string">completion:</span>completionBlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据key将图片异步缓存到内存和磁盘中 （默认存储到内存，根据判断是否存储到磁盘中）<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据key将图片异步缓存到内存和磁盘中</span></span><br><span class="line"><span class="comment"> * （根据toDisk来判断是否要存储到磁盘中，这里的磁盘缓存是可选的）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> image           需要缓存的图片</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key            唯一的缓存图片的key,通常是图像的绝对URL</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toDisk          是否缓存到磁盘中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> completionBlock 操作完成后执行的块</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">storeImage:</span>(nullable UIImage *)image</span><br><span class="line"><span class="symbol">            forKey:</span>(nullable NSString *)key</span><br><span class="line"><span class="symbol">            toDisk:</span>(BOOL)toDisk</span><br><span class="line"><span class="symbol">        completion:</span>(nullable SDWebImageNoParamsBlock)completionBlock &#123;</span><br><span class="line">    [self <span class="string">storeImage:</span>image <span class="string">imageData:</span>nil <span class="string">forKey:</span>key <span class="string">toDisk:</span>toDisk <span class="string">completion:</span>completionBlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据key将图片异步缓存到内存和磁盘中 （默认存储到内存，根据判断是否存储到磁盘）<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据key将图片异步缓存到内存和磁盘中</span></span><br><span class="line"><span class="comment"> * （这里面的方法会根据imageData如果没有，但是image有的话，就会考虑到图片格式的问题）</span></span><br><span class="line"><span class="comment"> * @param image         需要缓存的图片</span></span><br><span class="line"><span class="comment"> * @param imageData     服务器返回的图像数据，此表示将用于磁盘存储，而不是将给定的图像对象转换为可存储/压缩的图像格式，以节省质量和CPU</span></span><br><span class="line"><span class="comment"> * @param key            唯一的缓存图片的key,通常是图像的绝对URL</span></span><br><span class="line"><span class="comment"> * @param toDisk          是否缓存到磁盘中</span></span><br><span class="line"><span class="comment"> * @param completionBlock 操作完成后执行的块  typedef void(^SDWebImageNoParamsBlock)(void); 不需要传任何参数</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)storeImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image</span><br><span class="line">         imageData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)imageData</span><br><span class="line">            forKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key</span><br><span class="line">            toDisk:(<span class="built_in">BOOL</span>)toDisk</span><br><span class="line">        completion:(<span class="keyword">nullable</span> SDWebImageNoParamsBlock)completionBlock &#123;</span><br><span class="line">    <span class="comment">//若图片或者key不存在，则不存储，执行回调，返回</span></span><br><span class="line">    <span class="keyword">if</span> (!image || !key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (completionBlock) &#123;</span><br><span class="line">            completionBlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果启用了内存缓存</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.config.shouldCacheImagesInMemory) &#123;</span><br><span class="line">        <span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(image);</span><br><span class="line">        <span class="comment">//根据key缓存image，</span></span><br><span class="line">        [<span class="keyword">self</span>.memCache setObject:image forKey:key cost:cost];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//若需要缓存到磁盘</span></span><br><span class="line">    <span class="keyword">if</span> (toDisk) &#123;</span><br><span class="line">        <span class="comment">//异步执行缓存操作</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</span><br><span class="line">            <span class="keyword">@autoreleasepool</span> &#123; <span class="comment">//自动释放池（里面创建了很多临时变量，当@autoreleasepool结束时，里面的内存就会回收）</span></span><br><span class="line">                <span class="built_in">NSData</span> *data = imageData;</span><br><span class="line">                <span class="keyword">if</span> (!data &amp;&amp; image) &#123;</span><br><span class="line">                    <span class="comment">// 如果我们没有任何数据来检测图像格式，请检查它是否包含使用PNG或JPEG格式的Alpha通道</span></span><br><span class="line">                    SDImageFormat format;</span><br><span class="line">                    <span class="keyword">if</span> (SDCGImageRefContainsAlpha(image.CGImage)) &#123;</span><br><span class="line">                        format = SDImageFormatPNG;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        format = SDImageFormatJPEG;</span><br><span class="line">                    &#125;</span><br><span class="line">                    将图片编码为图片数据，该方法在SDWebImageCoder类中</span><br><span class="line">                    data = [[SDWebImageCodersManager sharedInstance] encodedDataWithImage:image format:format];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//根据key存储imageData</span></span><br><span class="line">                [<span class="keyword">self</span> _storeImageDataToDisk:data forKey:key];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果需要回调，在主线程执行回调</span></span><br><span class="line">            <span class="keyword">if</span> (completionBlock) &#123;</span><br><span class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    completionBlock();</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">//如果不存储磁盘，执行完成回调</span></span><br><span class="line">        <span class="keyword">if</span> (completionBlock) &#123;</span><br><span class="line">            completionBlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据key将图片data同步缓存到磁盘中<br> <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据key将图片data同步缓存到内存和磁盘中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param imageData  需要缓存的图片data</span></span><br><span class="line"><span class="comment"> * @param key       唯一的缓存图片的key,通常是图像的绝对URL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)storeImageDataToDisk:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)imageData forKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">     <span class="comment">//若图片或者key不存在，则不能存储</span></span><br><span class="line">    <span class="keyword">if</span> (!imageData || !key) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> _storeImageDataToDisk:imageData forKey:key];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据key将图片data同步缓存到内存和磁盘中（确保通过调用者调用表单io队列）<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)_storeImageDataToDisk:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)imageData forKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="comment">//若图片或者key不存在，则不能存储</span></span><br><span class="line">    <span class="keyword">if</span> (!imageData || !key) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果文件管理器中不存在磁盘缓存的路径，则创建</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span>.fileManager fileExistsAtPath:_diskCachePath]) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.fileManager createDirectoryAtPath:_diskCachePath withIntermediateDirectories:<span class="literal">YES</span> attributes:<span class="literal">nil</span> error:<span class="literal">NULL</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过key获取缓存路径</span></span><br><span class="line">    <span class="built_in">NSString</span> *cachePathForKey = [<span class="keyword">self</span> defaultCachePathForKey:key];</span><br><span class="line">    <span class="comment">// 转换成 NSUrl</span></span><br><span class="line">    <span class="built_in">NSURL</span> *fileURL = [<span class="built_in">NSURL</span> fileURLWithPath:cachePathForKey];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将图片写入fileURL中（options写入的选项，默认的配置为：NSDataWritingAtomic）</span></span><br><span class="line">    [imageData writeToURL:fileURL options:<span class="keyword">self</span>.config.diskCacheWritingOptions error:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 禁用iCloud备份</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.config.shouldDisableiCloud) &#123;</span><br><span class="line">        <span class="comment">//NSURLIsExcludedFromBackupKey：如果应从备份中排除资源，则为true，否则为false（读写，值类型为boolean NSNumber）。 此属性仅用于排除备份中不需要的缓存和其他应用程序支持文件。 通常对用户文档执行的某些操作将导致此属性重置为false，因此不应在用户文档上使用此属性。</span></span><br><span class="line">        [fileURL setResourceValue:@YES forKey:<span class="built_in">NSURLIsExcludedFromBackupKey</span> error:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>查询和检索操作</strong></p><p>异步检查磁盘缓存中是否存在图片（不加载图片），回调返回结果<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  异步检查串行队列的磁盘缓存中是否存在图片（不加载图片），回调返回结果</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param key             描述url的key</span></span><br><span class="line"><span class="comment"> *  @param completionBlock 检查完成时要执行的块。</span></span><br><span class="line"><span class="comment"> *  @note  将在主队列上始终执行完成块</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)diskImageExistsWithKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key completion:(<span class="keyword">nullable</span> SDWebImageCheckCacheCompletionBlock)completionBlock &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</span><br><span class="line">        <span class="comment">// 根据key判断磁盘中是否图片数据</span></span><br><span class="line">        <span class="built_in">BOOL</span> exists = [<span class="keyword">self</span> _diskImageDataExistsWithKey:key];</span><br><span class="line">        <span class="keyword">if</span> (completionBlock) &#123;</span><br><span class="line">            <span class="comment">//如果回调代码存在，主线程执行完成查询的回调</span></span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                completionBlock(exists);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同步检查磁盘缓存中是否存在图片（不加载图片），直接返回结果<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  同步检查磁盘缓存中是否存在图片（不加载图片），直接返回结果</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param key             描述url的key</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)diskImageDataExistsWithKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="comment">//如果key不存在，返回查询结果为NO ，否则同步根据key同步查询是否存在图片，返回结果</span></span><br><span class="line">    <span class="keyword">if</span> (!key) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    __block <span class="built_in">BOOL</span> exists = <span class="literal">NO</span>;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</span><br><span class="line">        exists = [<span class="keyword">self</span> _diskImageDataExistsWithKey:key];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> exists;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据key判断磁盘中是否存在图片数据<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)_diskImageDataExistsWithKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="comment">//如果key不存在，返回查询结果为NO </span></span><br><span class="line">    <span class="keyword">if</span> (!key) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//key存在，则判断文件管理器中是否存在该key的缓存路径，如果存在返回，</span></span><br><span class="line">    <span class="built_in">BOOL</span> exists = [<span class="keyword">self</span>.fileManager fileExistsAtPath:[<span class="keyword">self</span> defaultCachePathForKey:key]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果不存在，进一步判断是否存在该key删除扩展名的缓存路径，返回判断结果</span></span><br><span class="line">    <span class="keyword">if</span> (!exists) &#123;</span><br><span class="line">        <span class="comment">//stringByDeletingPathExtension：从文件的最后一部分删除扩展名</span></span><br><span class="line">        exists = [<span class="keyword">self</span>.fileManager fileExistsAtPath:[<span class="keyword">self</span> defaultCachePathForKey:key].stringByDeletingPathExtension];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> exists;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据key同步查询图片数据data<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)diskImageDataForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">     <span class="comment">//如果key不存在，返回nil</span></span><br><span class="line">    <span class="keyword">if</span> (!key) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据key搜索所有的路径获取磁盘图片data</span></span><br><span class="line">    __block <span class="built_in">NSData</span> *imageData = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</span><br><span class="line">        imageData = [<span class="keyword">self</span> diskImageDataBySearchingAllPathsForKey:key];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> imageData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据key同步查询内存缓存图片<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)imageFromMemoryCacheForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.memCache objectForKey:key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据key同步查询磁盘缓存图片<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)imageFromDiskCacheForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="comment">//根据key查询磁盘缓存图片，最终调用的是：- (UIImage *)diskImageForKey: data: options:这个方法</span></span><br><span class="line">    <span class="built_in">UIImage</span> *diskImage = [<span class="keyword">self</span> diskImageForKey:key];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果图片存在，并且需要缓存到内存中，则计算所占用字节数，并缓存到内存中</span></span><br><span class="line">    <span class="keyword">if</span> (diskImage &amp;&amp; <span class="keyword">self</span>.config.shouldCacheImagesInMemory) &#123;</span><br><span class="line">        <span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(diskImage);</span><br><span class="line">        [<span class="keyword">self</span>.memCache setObject:diskImage forKey:key cost:cost];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> diskImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>检查缓存后，同步查询缓存（磁盘或内存）<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (nullable UIImage *)imageFromCacheForKey:(nullable NSString *)<span class="built_in">key</span> &#123;</span><br><span class="line">    <span class="comment">// 先从内存中查询缓存图片，如果存在，结束查询并返回图片</span></span><br><span class="line">    UIImage *<span class="built_in">image</span> = [self imageFromMemoryCacheForKey:<span class="built_in">key</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">image</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">image</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果内存中未查到该key的图片，则从磁盘中查询，返回最后查询的结果</span></span><br><span class="line">    <span class="built_in">image</span> = [self imageFromDiskCacheForKey:<span class="built_in">key</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">image</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据key搜索所有的路径获取磁盘图片data<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)diskImageDataBySearchingAllPathsForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="comment">//根据key获取默认的缓存路径</span></span><br><span class="line">    <span class="built_in">NSString</span> *defaultPath = [<span class="keyword">self</span> defaultCachePathForKey:key];</span><br><span class="line">    <span class="comment">//self.config.diskCacheReadingOptions ：默认是0，即：NSDataReadingMappedIfSafe</span></span><br><span class="line">    <span class="comment">//根据缓存路径和磁盘缓存读取选项，获取图片data，若存在则返回data，不存在则继续读取该key删除扩展名的缓存路径</span></span><br><span class="line">    <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfFile:defaultPath options:<span class="keyword">self</span>.config.diskCacheReadingOptions error:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取该key删除扩展名的缓存路径，获取图片data，若存在则返回data</span></span><br><span class="line">    data = [<span class="built_in">NSData</span> dataWithContentsOfFile:defaultPath.stringByDeletingPathExtension options:<span class="keyword">self</span>.config.diskCacheReadingOptions error:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">    如果上面均未读取tupiandata，则依据上面的方法查找自定义路径，若存在返回data，如果仍未找到则返回<span class="literal">nil</span></span><br><span class="line">    <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *customPaths = [<span class="keyword">self</span>.customPaths <span class="keyword">copy</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *path <span class="keyword">in</span> customPaths) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *filePath = [<span class="keyword">self</span> cachePathForKey:key inPath:path];</span><br><span class="line">        <span class="built_in">NSData</span> *imageData = [<span class="built_in">NSData</span> dataWithContentsOfFile:filePath options:<span class="keyword">self</span>.config.diskCacheReadingOptions error:<span class="literal">nil</span>];</span><br><span class="line">        <span class="keyword">if</span> (imageData) &#123;</span><br><span class="line">            <span class="keyword">return</span> imageData;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        imageData = [<span class="built_in">NSData</span> dataWithContentsOfFile:filePath.stringByDeletingPathExtension options:<span class="keyword">self</span>.config.diskCacheReadingOptions error:<span class="literal">nil</span>];</span><br><span class="line">        <span class="keyword">if</span> (imageData) &#123;</span><br><span class="line">            <span class="keyword">return</span> imageData;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据key获取磁盘图片<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">缓存图片到磁盘是存储的imageData；到内存是存储的image。</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)diskImageForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="comment">//现获取imagedata，再转换成image</span></span><br><span class="line">    <span class="built_in">NSData</span> *data = [<span class="keyword">self</span> diskImageDataForKey:key];</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> diskImageForKey:key data:data];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据key和data得到磁盘图片<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)diskImageForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key data:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> diskImageForKey:key data:data options:<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>//最终调用的方法，根据key和data、选项获取磁盘图片<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (nullable <span class="type">UIImage</span> *)diskImageForKey:(nullable <span class="type">NSString</span> *)key <span class="class"><span class="keyword">data</span>:(<span class="title">nullable</span> <span class="type">NSData</span> *)<span class="keyword">data</span> options:(<span class="type">SDImageCacheOptions</span>)options &#123;</span></span><br><span class="line"><span class="class">    //如果图片的<span class="title">data</span>存在，进行进一步的转换，否则返回<span class="title">nil</span></span></span><br><span class="line"><span class="class">    <span class="title">if</span> (<span class="title">data</span>) &#123;</span></span><br><span class="line"><span class="class">        //将<span class="title">data</span>转换成<span class="title">image</span></span></span><br><span class="line"><span class="class">        <span class="type">UIImage</span> *<span class="title">image</span> = [[<span class="type">SDWebImageCodersManager</span> <span class="title">sharedInstance</span>] <span class="title">decodedImageWithData</span>:<span class="title">data</span>];</span></span><br><span class="line"><span class="class">        //对图片进行缩放操作</span></span><br><span class="line"><span class="class">        <span class="title">image</span> = [<span class="title">self</span> <span class="title">scaledImageForKey</span>:<span class="title">key</span> <span class="title">image</span>:<span class="title">image</span>];</span></span><br><span class="line"><span class="class">        //如果需要解压缩操作，就进行其操作，否则直接返回图片</span></span><br><span class="line"><span class="class">        <span class="title">if</span> (<span class="title">self</span>.<span class="title">config</span>.<span class="title">shouldDecompressImages</span>) &#123;</span></span><br><span class="line"><span class="class">            //默认情况下，图像会根据其原始大小进行解码。在<span class="title">iOS</span>上，此选项会将图像缩小到与设备的受限内存兼容的大小。</span></span><br><span class="line"><span class="class">            <span class="type">BOOL</span> <span class="title">shouldScaleDown</span> = <span class="title">options</span> &amp; <span class="type">SDImageCacheScaleDownLargeImages</span>;</span></span><br><span class="line"><span class="class">            /**</span></span><br><span class="line"><span class="class">              *- (<span class="title">nullable</span> <span class="type">UIImage</span> *)<span class="title">decompressedImageWithImage</span>:(<span class="title">nullable</span> <span class="type">UIImage</span> *)<span class="title">image</span></span></span><br><span class="line"><span class="class">                                            <span class="title">data</span>:(<span class="type">NSData</span> * <span class="title">_Nullable</span> * <span class="title">_Nonnull</span>)<span class="title">data</span></span></span><br><span class="line"><span class="class">                                         <span class="title">options</span>:(<span class="title">nullable</span> <span class="type">NSDictionary</span>&lt;<span class="type">NSString</span>*, <span class="type">NSObject</span>*&gt;*)<span class="title">optionsDict</span>;</span></span><br><span class="line"><span class="class">              * 使用原始图像和图像数据解压缩图像。</span></span><br><span class="line"><span class="class">              *</span></span><br><span class="line"><span class="class">              * @<span class="title">param</span> <span class="title">image</span>要解压缩的原始图像</span></span><br><span class="line"><span class="class">              * @<span class="title">param</span> <span class="title">data</span>指向原始图像数据的指针。 指针本身是非空的，但图像数据可以为空。 如果需要，此数据将设置为缓存。 如果您不需要同时修改数据，请忽略此参数。</span></span><br><span class="line"><span class="class">              * @<span class="title">param</span> <span class="title">optionsDict</span>包含任何解压缩选项的字典。 通过&#123;<span class="type">SDWebImageCoderScaleDownLargeImagesKey</span>：@（<span class="type">YES</span>）&#125;缩小大图像</span></span><br><span class="line">              * @return解压缩的图像</span><br><span class="line">              */</span><br><span class="line">            </span><br><span class="line">            image = [[<span class="type">SDWebImageCodersManager</span> sharedInstance] decompressedImageWithImage:image <span class="class"><span class="keyword">data</span>:&amp;<span class="keyword">data</span> options:@&#123;<span class="type">SDWebImageCoderScaleDownLargeImagesKey</span>: @(<span class="title">shouldScaleDown</span>)&#125;];</span></span><br><span class="line">        &#125;</span><br><span class="line">        return image;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>//图片缩放操作<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)scaledImageForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key image:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image &#123;</span><br><span class="line">    <span class="keyword">return</span> SDScaledImageForKey(key, image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>异步查询缓存并在完成后调用完成的操作<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步查询缓存并在完成后调用完成的操作。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key      用来存储所需图片唯一的key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> doneBlock The completion block. 如果操作被取消，则不会被调用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>       包含缓存操作的NSOperation实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (NSOperation *)<span class="string">queryCacheOperationForKey:</span>(NSString *)key <span class="string">done:</span>(SDCacheQueryCompletedBlock)doneBlock &#123;</span><br><span class="line">    <span class="keyword">return</span> [self <span class="string">queryCacheOperationForKey:</span>key <span class="string">options:</span><span class="number">0</span> <span class="string">done:</span>doneBlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>异步查询缓存并在完成后调用完成的操作<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步查询缓存并在完成后调用完成的操作。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param key      用来存储所需图片唯一的key</span></span><br><span class="line"><span class="comment"> * @param options  用于指定用于此高速缓存查询的选项</span></span><br><span class="line"><span class="comment"> * @param doneBlock The completion block. 如果操作被取消，则不会被调用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return     包含缓存操作的NSOperation实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSOperation</span> *)queryCacheOperationForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key options:(SDImageCacheOptions)options done:(<span class="keyword">nullable</span> SDCacheQueryCompletedBlock)doneBlock &#123;</span><br><span class="line">    <span class="comment">//如果key不存在，返回查询操作为nil，如果执行回调，则image，data传nil，类型传SDImageCacheTypeNone</span></span><br><span class="line">    <span class="keyword">if</span> (!key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (doneBlock) &#123;</span><br><span class="line">            doneBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, SDImageCacheTypeNone);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 先从内存中查找图片，</span></span><br><span class="line">    <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> imageFromMemoryCacheForKey:key];</span><br><span class="line">    <span class="built_in">BOOL</span> shouldQueryMemoryOnly = (image &amp;&amp; !(options &amp; SDImageCacheQueryDataWhenInMemory));</span><br><span class="line">    如果image存在，并且只从内存中查找，返回<span class="built_in">NSOperation</span>为<span class="literal">nil</span>，，如果执行回调，则传image为查找的image，data传<span class="literal">nil</span>，类型传SDImageCacheTypeMemory</span><br><span class="line">    <span class="keyword">if</span> (shouldQueryMemoryOnly) &#123;</span><br><span class="line">        <span class="keyword">if</span> (doneBlock) &#123;</span><br><span class="line">            doneBlock(image, <span class="literal">nil</span>, SDImageCacheTypeMemory);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建一个NSOperation来获取磁盘图片</span></span><br><span class="line">    <span class="built_in">NSOperation</span> *operation = [<span class="built_in">NSOperation</span> new];</span><br><span class="line">    <span class="keyword">void</span>(^queryDiskBlock)(<span class="keyword">void</span>) =  ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (operation.isCancelled) &#123;</span><br><span class="line">            <span class="comment">// 如果操作被取消，则不执行回调</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//在自动释放池中执行，当@autoreleasepool结束时，里面的内存就会回收</span></span><br><span class="line">        <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">            <span class="comment">//获取缓存data</span></span><br><span class="line">            <span class="built_in">NSData</span> *diskData = [<span class="keyword">self</span> diskImageDataBySearchingAllPathsForKey:key];</span><br><span class="line">            <span class="built_in">UIImage</span> *diskImage;</span><br><span class="line">            SDImageCacheType cacheType = SDImageCacheTypeDisk;</span><br><span class="line">            <span class="keyword">if</span> (image) &#123;</span><br><span class="line">                <span class="comment">// 如果从内存中查找的image存在，赋值给diskImage，缓存类型为SDImageCacheTypeMemory</span></span><br><span class="line">                diskImage = image;</span><br><span class="line">                cacheType = SDImageCacheTypeMemory;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (diskData) &#123;</span><br><span class="line">                <span class="comment">// 如果内存缓存未找到image，并且缓存data存在，通过diskData转换为image</span></span><br><span class="line">                diskImage = [<span class="keyword">self</span> diskImageForKey:key data:diskData options:options];</span><br><span class="line">                <span class="keyword">if</span> (diskImage &amp;&amp; <span class="keyword">self</span>.config.shouldCacheImagesInMemory) &#123;</span><br><span class="line">                    <span class="comment">//磁盘图片存在，并且需要缓存到内存，则做内存存储图片操作</span></span><br><span class="line">                    <span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(diskImage);</span><br><span class="line">                    [<span class="keyword">self</span>.memCache setObject:diskImage forKey:key cost:cost];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//完成回调存在，如果选项为：SDImageCacheQueryDiskSync（此选项可以强制同步查询磁盘缓存），则执行同步回调，否则在主线程执行回调</span></span><br><span class="line">            <span class="keyword">if</span> (doneBlock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (options &amp; SDImageCacheQueryDiskSync) &#123;</span><br><span class="line">                    doneBlock(diskImage, diskData, cacheType);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                        doneBlock(diskImage, diskData, cacheType);</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果选项为：SDImageCacheQueryDiskSync（此选项可以强制同步查询磁盘缓存），则执行同步执行上面的queryDiskBlock代码块，否则异步执行</span></span><br><span class="line">    <span class="keyword">if</span> (options &amp; SDImageCacheQueryDiskSync) &#123;</span><br><span class="line">        queryDiskBlock();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, queryDiskBlock);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>移除操作</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从内存或者磁盘缓存中异步移除图片</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param key            唯一的图片缓存key</span></span><br><span class="line"><span class="comment"> * @param completion      删除图像后应执行的块（可选）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeImageForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key withCompletion:(<span class="keyword">nullable</span> SDWebImageNoParamsBlock)completion &#123;</span><br><span class="line">    [<span class="keyword">self</span> removeImageForKey:key fromDisk:<span class="literal">YES</span> withCompletion:completion];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从内存和可选磁盘缓存中异步移除图片</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param key            唯一的图片缓存key</span></span><br><span class="line"><span class="comment"> * @param fromDisk        是否也从磁盘中移除</span></span><br><span class="line"><span class="comment"> * @param completion      删除图像后应执行的块（可选）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)removeImageForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key fromDisk:(<span class="built_in">BOOL</span>)fromDisk withCompletion:(<span class="keyword">nullable</span> SDWebImageNoParamsBlock)completion &#123;</span><br><span class="line">    <span class="comment">//key为空，返回</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果缓存配置允许缓存到内存上，则需要在内存上也删除该key的缓存</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.config.shouldCacheImagesInMemory) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.memCache removeObjectForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果需要从磁盘上移除缓存，则执行磁盘移除缓存操作</span></span><br><span class="line">    <span class="keyword">if</span> (fromDisk) &#123;</span><br><span class="line">        <span class="comment">//异步执行移除磁盘缓存操作</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</span><br><span class="line">            [<span class="keyword">self</span>.fileManager removeItemAtPath:[<span class="keyword">self</span> defaultCachePathForKey:key] error:<span class="literal">nil</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//主线程执行完成回调</span></span><br><span class="line">            <span class="keyword">if</span> (completion) &#123;</span><br><span class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    completion();</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (completion)&#123;</span><br><span class="line">        <span class="comment">//执行完成回调</span></span><br><span class="line">        completion();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>缓存清理操作</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//清理缓存</span></span><br><span class="line">- (<span class="keyword">void</span>)clearMemory &#123;</span><br><span class="line">    <span class="comment">//清理所有内存缓存</span></span><br><span class="line">    [<span class="keyword">self</span>.memCache removeAllObjects];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//异步清理磁盘缓存，回调结果</span></span><br><span class="line">- (<span class="keyword">void</span>)clearDiskOnCompletion:(<span class="keyword">nullable</span> SDWebImageNoParamsBlock)completion &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</span><br><span class="line">        <span class="comment">//删除该磁盘缓存路径，之后再重新创建一个作为新的缓存路径（其实就是同一个路径，目的就是删除缓存数据）</span></span><br><span class="line">        [<span class="keyword">self</span>.fileManager removeItemAtPath:<span class="keyword">self</span>.diskCachePath error:<span class="literal">nil</span>];</span><br><span class="line">        [<span class="keyword">self</span>.fileManager createDirectoryAtPath:<span class="keyword">self</span>.diskCachePath</span><br><span class="line">                withIntermediateDirectories:<span class="literal">YES</span></span><br><span class="line">                                 attributes:<span class="literal">nil</span></span><br><span class="line">                                      error:<span class="literal">NULL</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (completion) &#123;</span><br><span class="line">            <span class="comment">//主线程执行完成回调</span></span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                completion();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除过期的文件</span></span><br><span class="line">- (<span class="keyword">void</span>)deleteOldFiles &#123;</span><br><span class="line">    [<span class="keyword">self</span> deleteOldFilesWithCompletionBlock:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//异步从磁盘中删除所有过期的缓存图片</span></span><br><span class="line">- (<span class="keyword">void</span>)deleteOldFilesWithCompletionBlock:(<span class="keyword">nullable</span> SDWebImageNoParamsBlock)completionBlock &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</span><br><span class="line">        <span class="comment">//获取磁盘缓存的默认根目录</span></span><br><span class="line">        <span class="built_in">NSURL</span> *diskCacheURL = [<span class="built_in">NSURL</span> fileURLWithPath:<span class="keyword">self</span>.diskCachePath isDirectory:<span class="literal">YES</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算用于测试的内容日期key</span></span><br><span class="line">        <span class="built_in">NSURLResourceKey</span> cacheContentDateKey = <span class="built_in">NSURLContentModificationDateKey</span>;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">self</span>.config.diskCacheExpireType) &#123;</span><br><span class="line">            <span class="keyword">case</span> SDImageCacheConfigExpireTypeAccessDate:</span><br><span class="line">                cacheContentDateKey = <span class="built_in">NSURLContentAccessDateKey</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> SDImageCacheConfigExpireTypeModificationDate:</span><br><span class="line">                cacheContentDateKey = <span class="built_in">NSURLContentModificationDateKey</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//记录遍历需要预先获取文件的哪些属性</span></span><br><span class="line">        <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *resourceKeys = @[<span class="built_in">NSURLIsDirectoryKey</span>, cacheContentDateKey, <span class="built_in">NSURLTotalFileAllocatedSizeKey</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// diskCacheURL 和 resourceKeys 这两个变量主要是为了下面生成NSDirectoryEnumerator准备的</span></span><br><span class="line">        <span class="comment">//此枚举器为我们的缓存文件预取有用的属性。</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * 递归地遍历diskCachePath这个文件夹中的所有目录，此处不是直接使用diskCachePath，而是使用其生成的NSURL</span></span><br><span class="line"><span class="comment">          * 此处使用includingPropertiesForKeys:resourceKeys，这样每个file的resourceKeys对应的属性也会在遍历时预先获取到</span></span><br><span class="line"><span class="comment">          * NSDirectoryEnumerationSkipsHiddenFiles表示不遍历隐藏文件</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSDirectoryEnumerator</span> *fileEnumerator = [<span class="keyword">self</span>.fileManager enumeratorAtURL:diskCacheURL</span><br><span class="line">                                                   includingPropertiesForKeys:resourceKeys</span><br><span class="line">                                                                      options:<span class="built_in">NSDirectoryEnumerationSkipsHiddenFiles</span></span><br><span class="line">                                                                 errorHandler:<span class="literal">NULL</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * 获取文件的过期时间，SDWebImage中默认是一个星期</span></span><br><span class="line"><span class="comment">          * expirationDate为过期时间，例如：现在时间是2018/10/16/00:00:00，当前时间减去1个星期，得到</span></span><br><span class="line"><span class="comment">          * 2018/10/09/00:00:00，这个时间为函数中的expirationDate</span></span><br><span class="line"><span class="comment">          * 用这个expirationDate和最后一次修改时间modificationDate比较看谁更晚就行</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">        <span class="built_in">NSDate</span> *expirationDate = [<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:-<span class="keyword">self</span>.config.maxCacheAge];</span><br><span class="line">        <span class="comment">//用来存储对应文件的一些属性，比如文件所需磁盘空间</span></span><br><span class="line">        <span class="built_in">NSMutableDictionary</span>&lt;<span class="built_in">NSURL</span> *, <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *&gt; *cacheFiles = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">        <span class="comment">//记录党建已经使用的磁盘缓存大小</span></span><br><span class="line">        <span class="built_in">NSUInteger</span> currentCacheSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在缓存的目录开始遍历文件.  此次遍历有两个目的:</span></span><br><span class="line">        <span class="comment">//  1. 移除过期的文件</span></span><br><span class="line">        <span class="comment">//  2. 同时存储每个文件的属性（比如该file是否是文件夹、该file所需磁盘大小，修改时间）</span></span><br><span class="line">        <span class="built_in">NSMutableArray</span>&lt;<span class="built_in">NSURL</span> *&gt; *urlsToDelete = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSURL</span> *fileURL <span class="keyword">in</span> fileEnumerator) &#123;</span><br><span class="line">            <span class="built_in">NSError</span> *error;</span><br><span class="line">            <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *resourceValues = [fileURL resourceValuesForKeys:resourceKeys error:&amp;error];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前扫描的是目录，就跳过</span></span><br><span class="line">            <span class="keyword">if</span> (error || !resourceValues || [resourceValues[<span class="built_in">NSURLIsDirectoryKey</span>] boolValue]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 移除过期文件(这里判断过期的方式：对比文件的最后一次修改日期和expirationDate谁更晚，如果expirationDate更晚，就认为该文件已经过期)</span></span><br><span class="line">            <span class="built_in">NSDate</span> *modifiedDate = resourceValues[cacheContentDateKey];</span><br><span class="line">            <span class="keyword">if</span> ([[modifiedDate laterDate:expirationDate] isEqualToDate:expirationDate]) &#123;</span><br><span class="line">                [urlsToDelete addObject:fileURL];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 计算当前已经使用的cache大小,并将对应file的属性存到cacheFiles中</span></span><br><span class="line">            <span class="built_in">NSNumber</span> *totalAllocatedSize = resourceValues[<span class="built_in">NSURLTotalFileAllocatedSizeKey</span>];</span><br><span class="line">            currentCacheSize += totalAllocatedSize.unsignedIntegerValue;</span><br><span class="line">            cacheFiles[fileURL] = resourceValues;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据需要移除文件的url来移除对应file</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSURL</span> *fileURL <span class="keyword">in</span> urlsToDelete) &#123;</span><br><span class="line">            [<span class="keyword">self</span>.fileManager removeItemAtURL:fileURL error:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 如果我们当前cache的大小已经超过了允许配置的缓存大小，那就删除已经缓存的文件</span></span><br><span class="line">         <span class="comment">// 删除策略就是，首先删除修改时间更早的缓存文件</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.config.maxCacheSize &gt; <span class="number">0</span> &amp;&amp; currentCacheSize &gt; <span class="keyword">self</span>.config.maxCacheSize) &#123;</span><br><span class="line">            <span class="comment">// 直接将当前cache大小降到允许最大的cache大小的一般</span></span><br><span class="line">            <span class="comment">//预期的缓存大小</span></span><br><span class="line">            <span class="keyword">const</span> <span class="built_in">NSUInteger</span> desiredCacheSize = <span class="keyword">self</span>.config.maxCacheSize / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 根据文件修改时间来给所有缓存文件排序，按照修改时间越早越在前的规则排序</span></span><br><span class="line">            <span class="built_in">NSArray</span>&lt;<span class="built_in">NSURL</span> *&gt; *sortedFiles = [cacheFiles keysSortedByValueWithOptions:<span class="built_in">NSSortConcurrent</span></span><br><span class="line">                                                                     usingComparator:^<span class="built_in">NSComparisonResult</span>(<span class="keyword">id</span> obj1, <span class="keyword">id</span> obj2) &#123;</span><br><span class="line">                                                                         <span class="keyword">return</span> [obj1[<span class="built_in">NSURLContentModificationDateKey</span>] compare:obj2[<span class="built_in">NSURLContentModificationDateKey</span>]];</span><br><span class="line">                                                                     &#125;];</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 每次删除file后，就计算此时的cache的大小.</span></span><br><span class="line">            <span class="comment">//如果此时的cache大小已经降到期望的大小了，就停止删除文件了</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSURL</span> *fileURL <span class="keyword">in</span> sortedFiles) &#123;</span><br><span class="line">                <span class="keyword">if</span> ([<span class="keyword">self</span>.fileManager removeItemAtURL:fileURL error:<span class="literal">nil</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 获取该文件对应的属性</span></span><br><span class="line">                    <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *resourceValues = cacheFiles[fileURL];</span><br><span class="line">                    <span class="comment">// 根据resourceValues获取该文件所需磁盘空间大小</span></span><br><span class="line">                    <span class="built_in">NSNumber</span> *totalAllocatedSize = resourceValues[<span class="built_in">NSURLTotalFileAllocatedSizeKey</span>];</span><br><span class="line">                    <span class="comment">// 计算当前cache大小</span></span><br><span class="line">                    currentCacheSize -= totalAllocatedSize.unsignedIntegerValue;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (currentCacheSize &lt; desiredCacheSize) &#123;</span><br><span class="line">                        如果当前的缓存小于预期的缓存，结束删除file操作</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果有completionBlock，就在主线程中调用</span></span><br><span class="line">        <span class="keyword">if</span> (completionBlock) &#123;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                completionBlock();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#if SD_UIKIT</span></span><br><span class="line"><span class="comment">//后台删除过期文件</span></span><br><span class="line">- (<span class="keyword">void</span>)backgroundDeleteOldFiles &#123;</span><br><span class="line">    Class <span class="built_in">UIApplicationClass</span> = <span class="built_in">NSClassFromString</span>(<span class="string">@"UIApplication"</span>);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">UIApplicationClass</span> || ![<span class="built_in">UIApplicationClass</span> respondsToSelector:<span class="keyword">@selector</span>(sharedApplication)]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">UIApplication</span> *application = [<span class="built_in">UIApplication</span> performSelector:<span class="keyword">@selector</span>(sharedApplication)];</span><br><span class="line">    <span class="comment">//如果backgroundTask对应的时间结束了，任务还没有处理完成，则直接终止任务</span></span><br><span class="line">    __block <span class="built_in">UIBackgroundTaskIdentifier</span> bgTask = [application beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class="line">        <span class="comment">//通过标记您的位置来清理任何未完成的任务业务</span></span><br><span class="line">        <span class="comment">//完全停止或结束任务。</span></span><br><span class="line">        <span class="comment">//当任务非正常终止的时候，做清理工作</span></span><br><span class="line">        [application endBackgroundTask:bgTask];</span><br><span class="line">        bgTask = <span class="built_in">UIBackgroundTaskInvalid</span>;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动长时间运行的任务并立即返回。</span></span><br><span class="line">    <span class="comment">//图片清理结束以后，处理完成</span></span><br><span class="line">    [<span class="keyword">self</span> deleteOldFilesWithCompletionBlock:^&#123;</span><br><span class="line">        <span class="comment">//清理完成以后，终止任务</span></span><br><span class="line">        [application endBackgroundTask:bgTask];</span><br><span class="line">        bgTask = <span class="built_in">UIBackgroundTaskInvalid</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><p><strong>缓存信息</strong></p><p>获取磁盘缓存使用的大小</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSUInteger</span>)getSize &#123;</span><br><span class="line">    __block <span class="built_in">NSUInteger</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 需要同步操作：等待队列self.ioQueue中的任务执行完后（有可能队列中的任务正在添加图片或者删除图片操作），再进行获取文件大小计算</span></span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSDirectoryEnumerator</span> *fileEnumerator = [<span class="keyword">self</span>.fileManager enumeratorAtPath:<span class="keyword">self</span>.diskCachePath];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSString</span> *fileName <span class="keyword">in</span> fileEnumerator) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *filePath = [<span class="keyword">self</span>.diskCachePath stringByAppendingPathComponent:fileName];</span><br><span class="line">            <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *attrs = [<span class="keyword">self</span>.fileManager attributesOfItemAtPath:filePath error:<span class="literal">nil</span>];</span><br><span class="line">            size += [attrs fileSize];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取磁盘缓存中的图片数量</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (NSUInteger)getDiskCount &#123;</span><br><span class="line">    __block NSUInteger <span class="built_in">count</span> = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">    <span class="keyword">dispatch_sync(self.ioQueue, </span>^&#123;</span><br><span class="line">        NSDirectoryEnumerator *fileEnumerator = [self.fileManager enumeratorAtPath:self.<span class="keyword">diskCachePath];</span></span><br><span class="line"><span class="keyword"> </span>       <span class="built_in">count</span> = fileEnumerator.allObjects.count<span class="comment">;</span></span><br><span class="line">    &#125;)<span class="comment">;</span></span><br><span class="line">    return <span class="built_in">count</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异步计算磁盘缓存的大小</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)calculateSizeWithCompletionBlock:(<span class="keyword">nullable</span> SDWebImageCalculateSizeBlock)completionBlock &#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *diskCacheURL = [<span class="built_in">NSURL</span> fileURLWithPath:<span class="keyword">self</span>.diskCachePath isDirectory:<span class="literal">YES</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSUInteger</span> fileCount = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">NSUInteger</span> totalSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSDirectoryEnumerator</span> *fileEnumerator = [<span class="keyword">self</span>.fileManager enumeratorAtURL:diskCacheURL</span><br><span class="line">                                                   includingPropertiesForKeys:@[<span class="built_in">NSFileSize</span>]</span><br><span class="line">                                                                      options:<span class="built_in">NSDirectoryEnumerationSkipsHiddenFiles</span></span><br><span class="line">                                                                 errorHandler:<span class="literal">NULL</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSURL</span> *fileURL <span class="keyword">in</span> fileEnumerator) &#123;</span><br><span class="line">            <span class="built_in">NSNumber</span> *fileSize;</span><br><span class="line">            [fileURL getResourceValue:&amp;fileSize forKey:<span class="built_in">NSURLFileSizeKey</span> error:<span class="literal">NULL</span>];</span><br><span class="line">            totalSize += fileSize.unsignedIntegerValue;</span><br><span class="line">            fileCount += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (completionBlock) &#123;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                completionBlock(fileCount, totalSize);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>属性Get和Set方法</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//缓存中最大的消耗的内存，这里计算的是内存中的像素个数</span></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)maxMemoryCost &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.memCache.totalCostLimit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置缓存中最大的消耗的内存，这里计算的是内存中的像素个数</span></span><br><span class="line">- (<span class="keyword">void</span>)setMaxMemoryCost:(<span class="built_in">NSUInteger</span>)maxMemoryCost &#123;</span><br><span class="line">    <span class="keyword">self</span>.memCache.totalCostLimit = maxMemoryCost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缓存应持有的对象的的最大数量</span></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)maxMemoryCountLimit &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.memCache.countLimit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置缓存应持有的对象的的最大数量</span></span><br><span class="line">- (<span class="keyword">void</span>)setMaxMemoryCountLimit:(<span class="built_in">NSUInteger</span>)maxCountLimit &#123;</span><br><span class="line">    <span class="keyword">self</span>.memCache.countLimit = maxCountLimit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、介绍&quot;&gt;&lt;a href=&quot;#1、介绍&quot; class=&quot;headerlink&quot; title=&quot;1、介绍&quot;&gt;&lt;/a&gt;1、介绍&lt;/h3&gt;&lt;p&gt;&lt;code&gt;SDImageCache&lt;/code&gt; 是 &lt;code&gt;SDWebImage&lt;/code&gt; 处理图片缓存的类。图
      
    
    </summary>
    
      <category term="读SDWebImage手札" scheme="http://guohuaden.com/categories/%E8%AF%BBSDWebImage%E6%89%8B%E6%9C%AD/"/>
    
    
      <category term="SDWebImage" scheme="http://guohuaden.com/tags/SDWebImage/"/>
    
  </entry>
  
  <entry>
    <title>读SDWebImage 二 (SDWebImageManager)</title>
    <link href="http://guohuaden.com/2018/10/01/Read-SDWebImage-SDWebImageManager/"/>
    <id>http://guohuaden.com/2018/10/01/Read-SDWebImage-SDWebImageManager/</id>
    <published>2018-10-01T01:38:06.000Z</published>
    <updated>2018-10-25T11:23:22.054Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、整体框架"><a href="#1、整体框架" class="headerlink" title="1、整体框架"></a>1、整体框架</h2><p>看下整体的框架图：<br><img src="http://obzx0h1re.bkt.clouddn.com/SDWebImageClassDiagram.png" alt="SDWebImage框架"><br>从图中可以更清晰的看出，<code>SDWebImage</code>库是围绕<code>SDWebImageManager</code>、<code>SDWebImageCache</code>、<code>SDWebImageDownloader</code>三个类展开的，而这三个类又是以<code>SDWebImageManager</code>作为核心类。</p><p>下面就重点分析<code>SDWebImageManager</code>：<br><code>SDWebImageManager</code>是 <code>SDWebImage</code> 的管理以及操作类。也是<code>SDWebImage</code>的核心类，拥有一个<code>SDWebImageCache</code> 和 <code>SDWebImageDownloader</code> 属性，分别用于图片缓存和下载处理。</p><h2 id="2、SDWebImageManager类分析"><a href="#2、SDWebImageManager类分析" class="headerlink" title="2、SDWebImageManager类分析"></a>2、<code>SDWebImageManager</code>类分析</h2><h3 id="先看下-h文件"><a href="#先看下-h文件" class="headerlink" title="先看下.h文件"></a>先看下.h文件</h3><h3 id="2-1、公共枚举"><a href="#2-1、公共枚举" class="headerlink" title="2.1、公共枚举"></a>2.1、公共枚举</h3><p>该枚举定义了图像加载的可选项:<br><strong>options 选项（枚举类型）</strong></p><blockquote><p><code>SDWebImageRetryFailed = 1 &lt;&lt; 0,</code><br> 默认情况下当通过URL下载图片失败后，该URL就被加入黑名单，之后SDWebImage不会再去尝试下载。此标志作用就是禁用该黑名单，也就是说使用SDWebImageRetryFailed后，图片下载失败仍会尝试下载</p></blockquote><blockquote><p><code>SDWebImageLowPriority = 1 &lt;&lt; 1,</code><br> 默认情况下图片在UI交互期间下载，此标志的作用就是禁用该功能。例如：在UIScrollView减速时导致延迟下载。</p></blockquote><blockquote><p><code>SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2,</code><br> 此标志作用是：图片下载完成后仅缓存到内存，不缓存在磁盘上</p></blockquote><blockquote><p><code>SDWebImageProgressiveDownload = 1 &lt;&lt; 3,</code><br> 此标志启用渐进式下载，图像在下载过程中逐步显示，就像浏览器一样。<br> 默认情况下，图像仅在完全下载后显示。</p></blockquote><blockquote><p><code>SDWebImageRefreshCached = 1 &lt;&lt; 4,</code><br> 即使缓存中存在该图片，也尊重HTTP响应缓存控制，在需要时从远程刷新图片。<br> 磁盘缓存将由 <code>NSURLCache</code> 替代 <code>SDWebImage</code> 去处理，这样也将导致性能略有下降。<br> 该选项有助于处理同一个URL请求但更换图片的情况，例如Facebook图形api配置文件的图片。<br>如果刷新了缓存图片，则使用缓存图片调用一次完成block代码块，再使用最终的图片调用完成block代码块。<br>仅当你无法使用嵌入式缓存清除参数使URL保持静态时，才使用该标志。</p></blockquote><blockquote><p><code>SDWebImageContinueInBackground = 1 &lt;&lt; 5,</code><br>在<code>iOS 4+</code>中，如果app进入后台也继续下载图片，这是通过询问系统实现的。<br>在后台有额外的时间让请求完成，如果后台任务到期，则操作被取消。</p></blockquote><blockquote><p><code>SDWebImageHandleCookies = 1 &lt;&lt; 6,</code><br>通过<code>NSMutableURLRequest.HTTPShouldHandleCookies = YES</code>设置处理在 <code>NSHTTPCookieStore</code>中的cookies。</p></blockquote><blockquote><p><code>SDWebImageAllowInvalidSSLCertificates = 1 &lt;&lt; 7,</code><br>启用允许不受信任的SSL证书（用于测试目的，在生产中谨慎使用）</p></blockquote><blockquote><p><code>SDWebImageHighPriority = 1 &lt;&lt; 8,</code><br>默认情况下，图像按其排队顺序加载，此标志将它们移动到队列的前面</p></blockquote><blockquote><p><code>SDWebImageDelayPlaceholder = 1 &lt;&lt; 9,</code><br> 默认情况下，加载图像时会加载占位符。 此标志将延迟加载占位符图像，直到图像加载完毕。</p></blockquote><blockquote><p><code>SDWebImageTransformAnimatedImage = 1 &lt;&lt; 10,</code><br>我们通常不会在动画图像上调用transformDownloadedImage委托方法，因为大多数转换代码会破坏它。如果使用必须使用此标志来转换它们。</p></blockquote><blockquote><p><code>SDWebImageAvoidAutoSetImage = 1 &lt;&lt; 11,</code><br>默认情况下，下载后会将图像添加到imageView。 但在某些情况下，我们想要<br>在设置图像之前手动处理一些东西（例如应用滤镜或添加交叉渐变动画）请使用此标志</p></blockquote><blockquote><p><code>SDWebImageScaleDownLargeImages = 1 &lt;&lt; 12,</code><br>默认情况下，图像会根据其原始大小进行解码。 在iOS上，此标志将缩小图像尺寸与设备的受限内存兼容。（如果设置了“SDWebImageProgressiveDownload”标志，则停用缩小比例。）</p></blockquote><blockquote><p><code>SDWebImageQueryDataWhenInMemory = 1 &lt;&lt; 13,</code><br>默认情况下，当图像缓存在内存中时，我们不查询磁盘数据。 此掩码可以强制同时查询磁盘数据。<br>建议将此标志与<code>SDWebImageQueryDiskSync</code>一起使用，以确保图像在同一个runloop中加载。</p></blockquote><blockquote><p><code>SDWebImageQueryDiskSync = 1 &lt;&lt; 14,</code><br>默认情况下，我们同步查询内存缓存，异步查询磁盘缓存。 此掩码可以强制同步查询磁盘缓存，以确保在同一个runloop中加载映像。<br>如果禁用内存缓存或在某些其他情况下，此标志可以避免在单元重用期间闪烁。</p></blockquote><blockquote><p><code>SDWebImageFromCacheOnly = 1 &lt;&lt; 15,</code><br>默认情况下，当缓存丢失时，将从网络下载映像。此标志可以阻止网络仅从缓存加载。</p></blockquote><blockquote><p><code>SDWebImageForceTransition = 1 &lt;&lt; 16</code><br>默认情况下，当您使用 <code>SDWebImageTransition</code> 在图像加载完成后进行某些视图转换时，此转换仅适用于从网络下载图像。 此掩码也可以强制为内存和磁盘缓存应用视图转换。</p></blockquote><h3 id="2-2、公共类型定义"><a href="#2-2、公共类型定义" class="headerlink" title="2.2、公共类型定义"></a>2.2、公共类型定义</h3><p>四个回调代码块：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//用于外部分类中完成回调的block</span><br><span class="line">typedef void(^<span class="type">SDExternalCompletionBlock</span>)(<span class="type">UIImage</span> * _Nullable image, <span class="type">NSError</span> * _Nullable error, <span class="type">SDImageCacheType</span> cacheType, <span class="type">NSURL</span> * _Nullable imageURL);</span><br><span class="line"></span><br><span class="line">//用于该类内部完成回调的block</span><br><span class="line">typedef void(^<span class="type">SDInternalCompletionBlock</span>)(<span class="type">UIImage</span> * _Nullable image, <span class="type">NSData</span> * _Nullable data, <span class="type">NSError</span> * _Nullable error, <span class="type">SDImageCacheType</span> cacheType, <span class="type">BOOL</span> finished, <span class="type">NSURL</span> * _Nullable imageURL);</span><br><span class="line"></span><br><span class="line">//将url处理成缓存图像用的key的方法，返回字符串作为存储时的key，可以删除url中的产讯字段</span><br><span class="line">//用于在使用某url生成key之前，先把url的某些动态信息除掉，以便可以用简洁一点的url来生成key。因此这个block的内容就是对url的操作，返回值是一个简洁版的url。</span><br><span class="line">typedef <span class="type">NSString</span> * _Nullable(^<span class="type">SDWebImageCacheKeyFilterBlock</span>)(<span class="type">NSURL</span> * _Nullable url);</span><br><span class="line"></span><br><span class="line">//将图像缓存到磁盘的解码算法，返回的是data。</span><br><span class="line">typedef <span class="type">NSData</span> * _Nullable(^<span class="type">SDWebImageCacheSerializerBlock</span>)(<span class="type">UIImage</span> * _Nonnull image, <span class="type">NSData</span> * _Nullable data, <span class="type">NSURL</span> * _Nullable imageURL);</span><br></pre></td></tr></table></figure><h3 id="2-3、协议：SDWebImageManagerDelegate"><a href="#2-3、协议：SDWebImageManagerDelegate" class="headerlink" title="2.3、协议：SDWebImageManagerDelegate"></a>2.3、协议：<code>SDWebImageManagerDelegate</code></h3><p>使用协议的优点在于：</p><ol><li>不需要担心循环引用问题</li><li>有利于程序的结构化与层次化</li><li>有利于代码的封装</li></ol><p><code>SDWebImageManager</code>提供的三个都是可选协议，这也是我们平时常用的方式，遵守协议的类根据需要实现协议方法，不需要编译器警告提示。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当缓存没有发现当前图片，会查看调用者是否实现该方法，如果返回NO，则不会继续下载该图片</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param imageManager 当前的 `SDWebImageManager`</span></span><br><span class="line"><span class="comment"> * @param imageURL    应该下载的图像的URL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return  返回结果，返回NO时阻止去下载，如果不执行，默认的是YES</span></span><br><span class="line"><span class="comment"> Return NO to prevent the downloading of the image on cache misses. If not implemented, YES is implied.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)imageManager:(<span class="keyword">nonnull</span> SDWebImageManager *)imageManager shouldDownloadImageForURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)imageURL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当图片下载失败时，会查看调用者是否将该图片URL标记为失败，如果返回YES，则将此URL标记为失败。</span></span><br><span class="line"><span class="comment"> 注意：如果委托实现此方法，将不会使用内置方式根据错误代码将URL标记为失败;</span></span><br><span class="line"><span class="comment"> @param imageManager 当前的`SDWebImageManager`</span></span><br><span class="line"><span class="comment"> @param imageURL 图像的网址</span></span><br><span class="line"><span class="comment"> @param error URL下载的错误</span></span><br><span class="line"><span class="comment"> @return 是否阻止失败的URL再去下载，返回YES，将URL标记为失败，不再下载</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)imageManager:(<span class="keyword">nonnull</span> SDWebImageManager *)imageManager shouldBlockFailedURL:(<span class="keyword">nonnull</span> <span class="built_in">NSURL</span> *)imageURL withError:(<span class="keyword">nonnull</span> <span class="built_in">NSError</span> *)error;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 允许在下载后立即转换图像，然后将图像缓存到磁盘和内存中。</span></span><br><span class="line"><span class="comment"> * 注意：从全局队列调用此方法，以便不阻止主线程。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param imageManager  当前的`SDWebImageManager`</span></span><br><span class="line"><span class="comment"> * @param image        要转换的图像</span></span><br><span class="line"><span class="comment"> * @param imageURL     要转换的图像的网址</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return 转换后的图像对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)imageManager:(<span class="keyword">nonnull</span> SDWebImageManager *)imageManager transformDownloadedImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image withURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)imageURL;</span><br></pre></td></tr></table></figure><h3 id="2-4、协议：属性和方法"><a href="#2-4、协议：属性和方法" class="headerlink" title="2.4、协议：属性和方法"></a>2.4、协议：属性和方法</h3><p>声明属性：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代理</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="keyword">id</span> &lt;SDWebImageManagerDelegate&gt; delegate;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图片缓存</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) SDImageCache *imageCache;</span><br><span class="line"><span class="comment">//图片下载</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) SDWebImageDownloader *imageDownloader;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缓存过滤器代码块（每次SDWebImageManager将URL转换为缓存所需要的key时使用的代码块，这个可以用于删除图片URL的动态部分）</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) SDWebImageCacheKeyFilterBlock cacheKeyFilter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//高速缓存序列化器，用于将解码图像（愿下载数据）转换为用于存储到磁盘高速缓存的世纪数据的代码块，如果返回nil，则表示从图像实例生成数据。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) SDWebImageCacheSerializerBlock cacheSerializer;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局SDWebImageManager实例。</span></span><br><span class="line">+ (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)sharedManager;</span><br><span class="line"></span><br><span class="line"><span class="comment">//允许指定与图像管理器一起使用的缓存和图像下载器的实例。</span></span><br><span class="line"><span class="comment">//返回带有指定缓存和下载器的`SDWebImageManager`的新实例。</span></span><br><span class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)initWithCache:(<span class="keyword">nonnull</span> SDImageCache *)cache downloader:(<span class="keyword">nonnull</span> SDWebImageDownloader *)downloader <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果缓存中不存在，就下载给定URL的图像，存在就返回缓存的版本</span></span><br><span class="line"><span class="comment"> Downloads the image at the given URL if not present in cache or return the cached version otherwise.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param url           图像的URL</span></span><br><span class="line"><span class="comment"> * @param options       用于指定此请求的选项掩码</span></span><br><span class="line"><span class="comment"> * @param progressBlock 下载图像时调用的代码块（在后台队列上执行的进度代码块）</span></span><br><span class="line"><span class="comment"> *                      </span></span><br><span class="line"><span class="comment"> * @param completedBlock  操作完成时调用的代码块</span></span><br><span class="line"><span class="comment">* @return 返回 SDWebImageDownloaderOperation 的一个实例</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">completedBlock 即：typedef void(^SDInternalCompletionBlock)(UIImage * _Nullable image, NSData * _Nullable data, NSError * _Nullable error, SDImageCacheType cacheType, BOOL finished, NSURL * _Nullable imageURL);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> 该代码块没有返回值，将请求到的UIImage作为第一个参数；NSData作为第二个参数；如果出错，则image参数为nil，第三个参数可能包含NSError；第四个参数是一个`SDImageCacheType`枚举，指明图像的来源（本地缓存中检索、内存缓存、网络下载。）第五个参数用来判断下载是否完成；最后一个参数为原始图像的URL</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;SDWebImageOperation&gt;)loadImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">                                              options:(SDWebImageOptions)options</span><br><span class="line">                                             progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                            completed:(<span class="keyword">nullable</span> SDInternalCompletionBlock)completedBlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将图像保存到给定的URL的缓存中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param image要缓存的图像</span></span><br><span class="line"><span class="comment"> * @param url   图像的URL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">- (<span class="keyword">void</span>)saveImageToCache:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image forURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">//取消当前所有的操作</span></span><br><span class="line">- (<span class="keyword">void</span>)cancelAll;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//检查一个或多个正在运行的操作</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isRunning;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  异步检查图像是否已被缓存</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param url              图像 url</span></span><br><span class="line"><span class="comment"> *  @param completionBlock  检查完成时要执行的代码块</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  @note 完成代码块总是在主队列上执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)cachedImageExistsForURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">                     completion:(<span class="keyword">nullable</span> SDWebImageCheckCacheCompletionBlock)completionBlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  异步检查图像是否已仅缓存在磁盘上</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param url             图像 url</span></span><br><span class="line"><span class="comment"> *  @param completionBlock  检查完成时要执行的代码块</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @note 完成代码块总是在主队列上执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)diskImageExistsForURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">                   completion:(<span class="keyword">nullable</span> SDWebImageCheckCacheCompletionBlock)completionBlock;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回给定URL的缓存key</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)cacheKeyForURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url;</span><br></pre></td></tr></table></figure><h3 id="再看-m文件-的声明"><a href="#再看-m文件-的声明" class="headerlink" title="再看.m文件 的声明"></a>再看.m文件 的声明</h3><h3 id="2-5-SDWebImageCombinedOperation的属性声明和协议方法实现"><a href="#2-5-SDWebImageCombinedOperation的属性声明和协议方法实现" class="headerlink" title="2.5 SDWebImageCombinedOperation的属性声明和协议方法实现"></a>2.5 <code>SDWebImageCombinedOperation</code>的属性声明和协议方法实现</h3><p>定义一个<code>SDWebImageCombinedOperation</code>类，该类遵循 <code>SDWebImageOperation</code>协议 ，该协议仅定义了一个cancel的方法。<br>之所以在这里定义这个类，而不是直接使用<code>SDWebImageDownloaderOperation</code>类来表示下载任务，原因有两方面：</p><ol><li>为了可以在下面使用中修改<code>cancelled</code>属性的值，在<code>SDWebImageDownloaderOperation</code>中 <code>cancelled</code>属于对外是只读的</li><li>一个操作表示一个获取图像的动作，通常优先从缓存中取出图像，缓存中没鱼哦才需要下载，而<code>SDWebImageDownloderOperation</code>是专门用来下载的，没有包含查找缓存的功能。</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SDWebImageCombinedOperation</span> : <span class="title">NSObject</span> &lt;<span class="title">SDWebImageOperation</span>&gt;</span></span><br><span class="line"><span class="comment">//是否已取消</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>, <span class="keyword">getter</span> = isCancelled) <span class="built_in">BOOL</span> cancelled;</span><br><span class="line"><span class="comment">//下载任务</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) SDWebImageDownloadToken *downloadToken;</span><br><span class="line"><span class="comment">//取消操作</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">NSOperation</span> *cacheOperation;</span><br><span class="line"><span class="comment">//管理类</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) SDWebImageManager *manager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>实现<code>SDWebImageOperation</code>协议的cancel的方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SDWebImageCombinedOperation</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)cancel &#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">//设置为取消状态</span></span><br><span class="line">        <span class="keyword">self</span>.cancelled = <span class="literal">YES</span>;</span><br><span class="line">        <span class="comment">//取消的操作存在，就执行该取消操作，并置为nil</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.cacheOperation) &#123;</span><br><span class="line">            [<span class="keyword">self</span>.cacheOperation cancel];</span><br><span class="line">            <span class="keyword">self</span>.cacheOperation = <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在管理类的下载任务中取消该下载任务</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.downloadToken) &#123;</span><br><span class="line">            <span class="comment">//在下载SDWebImageDownloader类中执行取消任务操作</span></span><br><span class="line">            [<span class="keyword">self</span>.manager.imageDownloader cancel:<span class="keyword">self</span>.downloadToken];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//安全移除该操作</span></span><br><span class="line">        [<span class="keyword">self</span>.manager safelyRemoveOperationFromRunning:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)safelyRemoveOperationFromRunning:(<span class="keyword">nullable</span> SDWebImageCombinedOperation*)operation &#123;</span><br><span class="line">    <span class="keyword">if</span> (!operation) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加锁是为了安全，防止正在移除该操作时有变化</span></span><br><span class="line">    LOCK(<span class="keyword">self</span>.runningOperationsLock);</span><br><span class="line">    [<span class="keyword">self</span>.runningOperations removeObject:operation];</span><br><span class="line">    UNLOCK(<span class="keyword">self</span>.runningOperationsLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-SDWebImageManager的属性声明"><a href="#2-6-SDWebImageManager的属性声明" class="headerlink" title="2.6 SDWebImageManager的属性声明"></a>2.6 <code>SDWebImageManager</code>的属性声明</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SDWebImageManager</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>, <span class="keyword">nonnull</span>) SDImageCache *imageCache;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>, <span class="keyword">nonnull</span>) SDWebImageDownloader *imageDownloader;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSMutableSet</span>&lt;<span class="built_in">NSURL</span> *&gt; *failedURLs;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) dispatch_semaphore_t failedURLsLock; <span class="comment">// a lock to keep the access to `failedURLs` thread-safe</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSMutableSet</span>&lt;SDWebImageCombinedOperation *&gt; *runningOperations;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) dispatch_semaphore_t runningOperationsLock; <span class="comment">// a lock to keep the access to `runningOperations` thread-safe</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p><code>imageCache</code> 和 <code>imageDownloader</code> 在.h文件中已经声明，但是只读类型。这里重复声明成读写类型，实现外部为只读，内部为读写类型。</p><p>两个可变集合体<code>failedURLs</code> 和 <code>runningOperations</code> 前者存储<code>NSURL</code> 类型，记录失败的urls，后者存储<code>SDWebImageCombinedOperation</code>类型，记录正在运行的操作。</p><p>两个信号量<code>failedURLsLock</code> 和 <code>runningOperationsLock</code>锁，为了保持访问<code>failedURLs</code> 和 <code>runningOperations</code>线程安全的。</p><h3 id="2-7、SDWebImageManager的方法实现"><a href="#2-7、SDWebImageManager的方法实现" class="headerlink" title="2.7、SDWebImageManager的方法实现"></a>2.7、<code>SDWebImageManager</code>的方法实现</h3><h4 id="2-7-1、初始化"><a href="#2-7-1、初始化" class="headerlink" title="2.7.1、初始化"></a>2.7.1、初始化</h4><p>三个初始化方法，单例模式确保全局只有一个实例，避免每次调用时创建新的实例。</p><p>使用GCD中的<code>dispatch_once</code>创建的实例对象必须确保只有一个，所以使用static修饰 <code>static dispatch_once_t once; static id instance;</code><br><code>dispatch_once</code>可以简化代码且保证线程安全，开发者无需担心加锁或同步。所有问题都在GCD底层处理。此外，<code>dispatch_once</code>更高效。它没有使用重量级的同步机制。使用同步机制，每次运行代码都需要获取锁。<code>dispatch_once</code>采用“原子访问”来查询标记，判断代码是否执行过。</p><p><code>[self new]</code>是一种比较老式的写法，而<code>alloc/init</code>的引入则是因为<code>new</code>不够灵活，因为使用<code>new</code>的话，会使得初始化方法被固定死只能调用<code>init</code>。而这里就是使用的<code>new</code>方法，所以调用的顺序只能是<code>sharedManager ---&gt; init ---&gt; initWithCache: downloader:</code>。</p><p>在<code>init</code>初始化中，可以看出<code>cache</code> 和 <code>downloader</code>也是单例模式，其实也是使用的<code>new</code>方法，原理和这里的相同。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单例模式</span></span><br><span class="line">+ (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)sharedManager &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> once;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">id</span> instance;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;once, ^&#123;</span><br><span class="line">        instance = [<span class="keyword">self</span> new];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化 cache 和 downloader</span></span><br><span class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    SDImageCache *cache = [SDImageCache sharedImageCache];</span><br><span class="line">    SDWebImageDownloader *downloader = [SDWebImageDownloader sharedDownloader];</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithCache:cache downloader:downloader];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里实现一些属性的初始化。</span></span><br><span class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)initWithCache:(<span class="keyword">nonnull</span> SDImageCache *)cache downloader:(<span class="keyword">nonnull</span> SDWebImageDownloader *)downloader &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) &#123;</span><br><span class="line">        _imageCache = cache;</span><br><span class="line">        _imageDownloader = downloader;</span><br><span class="line">        _failedURLs = [<span class="built_in">NSMutableSet</span> new];</span><br><span class="line">        _failedURLsLock = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">        _runningOperations = [<span class="built_in">NSMutableSet</span> new];</span><br><span class="line">        _runningOperationsLock = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-7-2、功能实现方法"><a href="#2-7-2、功能实现方法" class="headerlink" title="2.7.2、功能实现方法"></a>2.7.2、功能实现方法</h4><ol><li>通过URL获取缓存时使用的key<br>利用Image的URL生成一个缓存时需要的key.<br>如果检测到cacheKeyFilter不为空时,利用cacheKeyFilter来处理URL生成一个key；否则直接返回URL的string内容,当做key.</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)cacheKeyForURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url &#123;</span><br><span class="line">    <span class="keyword">if</span> (!url) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">@""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.cacheKeyFilter) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.cacheKeyFilter(url);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> url.absoluteString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>图像放缩操作：根据图片中的图片组 或 scale 重新计算返回图片。该方法专门使用了一个类（<code>SDWebImageCompat</code>）来实现。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)scaledImageForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key image:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image &#123;</span><br><span class="line">    <span class="keyword">return</span> SDScaledImageForKey(key, image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>缓存图像</p></li></ol><p>通过URL缓存图像到内存</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)cachedImageExistsForURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">                     completion:(<span class="keyword">nullable</span> SDWebImageCheckCacheCompletionBlock)completionBlock &#123;</span><br><span class="line">    <span class="comment">//获取缓存所需的key</span></span><br><span class="line">    <span class="built_in">NSString</span> *key = [<span class="keyword">self</span> cacheKeyForURL:url];</span><br><span class="line">    <span class="comment">//判断内存中是否已缓存该图像</span></span><br><span class="line">    <span class="built_in">BOOL</span> isInMemoryCache = ([<span class="keyword">self</span>.imageCache imageFromMemoryCacheForKey:key] != <span class="literal">nil</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果已经缓存，在主线程中执行完成回调代码块</span></span><br><span class="line">    <span class="keyword">if</span> (isInMemoryCache) &#123;</span><br><span class="line">        <span class="comment">// making sure we call the completion block on the main queue</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="keyword">if</span> (completionBlock) &#123;</span><br><span class="line">                completionBlock(<span class="literal">YES</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果还未缓存，则调用 diskImageExistsWithKey，该方法会将图像缓存到磁盘中（在存储之前也会判断磁盘中是否已缓存该图像），该方法在异步线程执行。</span></span><br><span class="line">    [<span class="keyword">self</span>.imageCache diskImageExistsWithKey:key completion:^(<span class="built_in">BOOL</span> isInDiskCache) &#123;</span><br><span class="line">        <span class="comment">// the completion block of checkDiskCacheForImageWithKey:completion: is always called on the main queue, no need to further dispatch</span></span><br><span class="line">        <span class="keyword">if</span> (completionBlock) &#123;</span><br><span class="line">            completionBlock(isInDiskCache);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将图像缓存到磁盘中</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)diskImageExistsForURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">                   completion:(<span class="keyword">nullable</span> SDWebImageCheckCacheCompletionBlock)completionBlock &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *key = [<span class="keyword">self</span> cacheKeyForURL:url];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.imageCache diskImageExistsWithKey:key completion:^(<span class="built_in">BOOL</span> isInDiskCache) &#123;</span><br><span class="line">        <span class="comment">// the completion block of checkDiskCacheForImageWithKey:completion: is always called on the main queue, no need to further dispatch</span></span><br><span class="line">        <span class="keyword">if</span> (completionBlock) &#123;</span><br><span class="line">            completionBlock(isInDiskCache);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将图像缓存到内存中</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)saveImageToCache:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image forURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url &#123;</span><br><span class="line">    <span class="keyword">if</span> (image &amp;&amp; url) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *key = [<span class="keyword">self</span> cacheKeyForURL:url];</span><br><span class="line">        [<span class="keyword">self</span>.imageCache storeImage:image forKey:key toDisk:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>取消掉所有正在执行的操作Operation</li></ol><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)cancelAll &#123;</span><br><span class="line">    LOCK(self.runningOperations<span class="class">Lock);</span></span><br><span class="line">    NSSet&lt;SDWebImageCombinedOperation *&gt; *copiedOperations = [self.runningOperations copy];</span><br><span class="line">    UNLOCK(self.runningOperations<span class="class">Lock);</span></span><br><span class="line">    [copiedOperations makeObjectsPerformSelector:@selector(cancel)]; // This will call `safelyRemoveOperationFromRunning:`<span class="built_in"> and </span>remove from the array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>判断是否有正在运行的操作Operation</li></ol><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">BOOL)isRunning </span>&#123;</span><br><span class="line">    <span class="keyword">BOOL </span>isRunning = NO<span class="comment">;</span></span><br><span class="line">    LOCK(self.runningOperationsLock)<span class="comment">;</span></span><br><span class="line">    isRunning = (self.runningOperations.count &gt; <span class="number">0</span>)<span class="comment">;</span></span><br><span class="line">    UNLOCK(self.runningOperationsLock)<span class="comment">;</span></span><br><span class="line">    return isRunning<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>安全移除正在运行的操作Operation</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)safelyRemoveOperationFromRunning:(<span class="keyword">nullable</span> SDWebImageCombinedOperation*)operation &#123;</span><br><span class="line">    <span class="keyword">if</span> (!operation) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LOCK(<span class="keyword">self</span>.runningOperationsLock);</span><br><span class="line">    [<span class="keyword">self</span>.runningOperations removeObject:operation];</span><br><span class="line">    UNLOCK(<span class="keyword">self</span>.runningOperationsLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li>回调方法</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)callCompletionBlockForOperation:(<span class="keyword">nullable</span> SDWebImageCombinedOperation*)operation</span><br><span class="line">                             completion:(<span class="keyword">nullable</span> SDInternalCompletionBlock)completionBlock</span><br><span class="line">                                  error:(<span class="keyword">nullable</span> <span class="built_in">NSError</span> *)error</span><br><span class="line">                                    url:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url &#123;</span><br><span class="line">    [<span class="keyword">self</span> callCompletionBlockForOperation:operation completion:completionBlock image:<span class="literal">nil</span> data:<span class="literal">nil</span> error:error cacheType:SDImageCacheTypeNone finished:<span class="literal">YES</span> url:url];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)callCompletionBlockForOperation:(<span class="keyword">nullable</span> SDWebImageCombinedOperation*)operation</span><br><span class="line">                             completion:(<span class="keyword">nullable</span> SDInternalCompletionBlock)completionBlock</span><br><span class="line">                                  image:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image</span><br><span class="line">                                   data:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)data</span><br><span class="line">                                  error:(<span class="keyword">nullable</span> <span class="built_in">NSError</span> *)error</span><br><span class="line">                              cacheType:(SDImageCacheType)cacheType</span><br><span class="line">                               finished:(<span class="built_in">BOOL</span>)finished</span><br><span class="line">                                    url:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url &#123;</span><br><span class="line">    dispatch_main_async_safe(^&#123;</span><br><span class="line">        <span class="keyword">if</span> (operation &amp;&amp; !operation.isCancelled &amp;&amp; completionBlock) &#123;</span><br><span class="line">            completionBlock(image, data, error, cacheType, finished, url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>通过url建立一个operation用来下载图片. 返回operation</li></ol><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><span class="line">- (id &lt;SDWebImageOperation&gt;)<span class="string">loadImageWithURL:</span>(nullable NSURL *)url</span><br><span class="line"><span class="symbol">                                     options:</span>(SDWebImageOptions)options</span><br><span class="line"><span class="symbol">                                    progress:</span>(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line"><span class="symbol">                                   completed:</span>(nullable SDInternalCompletionBlock)completedBlock &#123;</span><br><span class="line">    <span class="comment">// Invoking this method without a completedBlock is pointless</span></span><br><span class="line">    NSAssert(completedBlock != nil, @<span class="string">"If you mean to prefetch the image, use -[SDWebImagePrefetcher prefetchURLs] instead"</span>);</span><br><span class="line">     <span class="comment">//在没有completedBlock的情况下调用此方法毫无意义 ， NSAssert（completedBlock！= nil，@“如果你的意思是预取图像，请使用 - [SDWebImagePrefetcher prefetchURLs]代替”）;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Very common mistake is to send the URL using NSString object instead of NSURL. For some strange reason, Xcode won't</span></span><br><span class="line">    <span class="comment">// throw any warning for this type mismatch. Here we failsafe this error by allowing URLs to be passed as NSString.</span></span><br><span class="line">  （非常常见的错误是使用NSString对象而不是NSURL发送URL。 出于某些奇怪的原因，Xcode不会抛出此类型不匹配的任何警告。在这里，我们通过允许URL作为NSString传递来确保此错误。）</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> ([url <span class="string">isKindOfClass:</span>NSString.<span class="keyword">class</span>]) &#123;</span><br><span class="line">        <span class="comment">//如果传入的url是字符串类型，则转换成NSURL类型</span></span><br><span class="line">        url = [NSURL <span class="string">URLWithString:</span>(NSString *)url];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prevents app crashing on argument type error like sending NSNull instead of NSURL</span></span><br><span class="line">    <span class="comment">//防止应用程序崩溃类型错误，如发送NSNull而不是NSURL，则url置为nil</span></span><br><span class="line">    <span class="keyword">if</span> (![url <span class="string">isKindOfClass:</span>NSURL.<span class="keyword">class</span>]) &#123;</span><br><span class="line">        url = nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    初始化一个SDWebImageCombinedOperation对象</span><br><span class="line">    SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation <span class="keyword">new</span>];</span><br><span class="line">    <span class="comment">//设置它的SDWebImageManager 等于self</span></span><br><span class="line">    operation.manager = self;</span><br><span class="line"></span><br><span class="line">    BOOL isFailedUrl = NO;</span><br><span class="line">    <span class="comment">//如果url存在，判断该url是否失败过，并赋值给isFailedUrl；加锁是为了安全，防止在判断的过程中被其他线程修改</span></span><br><span class="line">    <span class="keyword">if</span> (url) &#123;</span><br><span class="line">        LOCK(self.failedURLsLock);</span><br><span class="line">        isFailedUrl = [self.failedURLs <span class="string">containsObject:</span>url];</span><br><span class="line">        UNLOCK(self.failedURLsLock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断条件：如果url不存在，或者options不是SDWebImageRetryFailed（失败重试）并且isFailedUrl 为 YES。就回调一个error的block （异常处理），并返回operation</span></span><br><span class="line">    <span class="comment">//error为：[NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil]</span></span><br><span class="line">    <span class="keyword">if</span> (url.absoluteString.length == <span class="number">0</span> || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) &#123;</span><br><span class="line">        [self <span class="string">callCompletionBlockForOperation:</span>operation <span class="string">completion:</span>completedBlock <span class="string">error:</span>[NSError <span class="string">errorWithDomain:</span>NSURLErrorDomain <span class="string">code:</span>NSURLErrorFileDoesNotExist <span class="string">userInfo:</span>nil] <span class="string">url:</span>url];</span><br><span class="line">        <span class="keyword">return</span> operation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建互斥锁，执行runningOperations添加operation操作</span></span><br><span class="line">    LOCK(self.runningOperationsLock);</span><br><span class="line">    [self.runningOperations <span class="string">addObject:</span>operation];</span><br><span class="line">    UNLOCK(self.runningOperationsLock);</span><br><span class="line">    <span class="comment">//获取缓存所需要的key</span></span><br><span class="line">    NSString *key = [self <span class="string">cacheKeyForURL:</span>url];</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 下面都是判断我们的cacheOptions里包含哪些SDWebImageOptions,然后给我们的cacheOptions相应的添加对应的SDImageCacheOptions. cacheOptions |= SDImageCacheQueryDataWhenInMemory这种表达式的意思等同于cacheOptions = cacheOptions | SDImageCacheQueryDataWhenInMemory</span></span><br><span class="line">     </span><br><span class="line">    SDImageCacheOptions cacheOptions = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (options &amp; SDWebImageQueryDataWhenInMemory) cacheOptions |= SDImageCacheQueryDataWhenInMemory;</span><br><span class="line">    <span class="keyword">if</span> (options &amp; SDWebImageQueryDiskSync) cacheOptions |= SDImageCacheQueryDiskSync;</span><br><span class="line">    <span class="keyword">if</span> (options &amp; SDWebImageScaleDownLargeImages) cacheOptions |= SDImageCacheScaleDownLargeImages;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//弱引用</span></span><br><span class="line">    __weak SDWebImageCombinedOperation *weakOperation = operation;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *如果图片是从内存加载，则返回的cacheOperation是nil，</span></span><br><span class="line"><span class="comment">    *如果是从磁盘加载，则返回的cacheOperation是`NSOperation`对象。</span></span><br><span class="line"><span class="comment">    *如果是从网络加载，则返回的cacheOperation对象是`SDWebImageDownloaderOperation`对象。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    operation.cacheOperation = [self.imageCache <span class="string">queryCacheOperationForKey:</span>key <span class="string">options:</span>cacheOptions <span class="string">done:</span>^(UIImage *cachedImage, NSData *cachedData, SDImageCacheType cacheType) &#123;</span><br><span class="line">        <span class="comment">//强引用，防止被提前释放</span></span><br><span class="line">        __strong __typeof(weakOperation) strongOperation = weakOperation;</span><br><span class="line">        <span class="comment">//operation不存在或者已经被取消，返回并移除该operation对象</span></span><br><span class="line">        <span class="keyword">if</span> (!strongOperation || strongOperation.isCancelled) &#123;</span><br><span class="line">            [self <span class="string">safelyRemoveOperationFromRunning:</span>strongOperation];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Check whether we should download image from network</span></span><br><span class="line">        <span class="comment">//检查是否应该从网络下载图像</span></span><br><span class="line">        BOOL shouldDownload = (!(options &amp; SDWebImageFromCacheOnly))</span><br><span class="line">            &amp;&amp; (!cachedImage || options &amp; SDWebImageRefreshCached)</span><br><span class="line">            &amp;&amp; (![self.delegate <span class="string">respondsToSelector:</span><span class="meta">@selector</span>(<span class="string">imageManager:</span><span class="string">shouldDownloadImageForURL:</span>)] || [self.delegate <span class="string">imageManager:</span>self <span class="string">shouldDownloadImageForURL:</span>url]);</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//应该从网络下载图像  </span></span><br><span class="line">        <span class="keyword">if</span> (shouldDownload) &#123;</span><br><span class="line">            <span class="comment">//如果缓存图像存在，但options设置为SDWebImageRetryFailed。则先返回缓存图像</span></span><br><span class="line">            <span class="keyword">if</span> (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</span><br><span class="line">                <span class="comment">// If image was found in the cache but SDWebImageRefreshCached is provided, notify about the cached image</span></span><br><span class="line">                <span class="comment">// AND try to re-download it in order to let a chance to NSURLCache to refresh it from server.</span></span><br><span class="line">                <span class="comment">//构建回调block</span></span><br><span class="line">                [self <span class="string">callCompletionBlockForOperation:</span>strongOperation <span class="string">completion:</span>completedBlock <span class="string">image:</span>cachedImage <span class="string">data:</span>cachedData <span class="string">error:</span>nil <span class="string">cacheType:</span>cacheType <span class="string">finished:</span>YES <span class="string">url:</span>url];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// download if no image or requested to refresh anyway, and download allowed by delegate</span></span><br><span class="line">             <span class="comment">/*</span></span><br><span class="line"><span class="comment">             把图片加载的`SDWebImageOptions`类型枚举转换为图片下载的`SDWebImageDownloaderOptions`类型的枚举</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            SDWebImageDownloaderOptions downloaderOptions = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (options &amp; SDWebImageLowPriority) downloaderOptions |= SDWebImageDownloaderLowPriority;</span><br><span class="line">            <span class="keyword">if</span> (options &amp; SDWebImageProgressiveDownload) downloaderOptions |= SDWebImageDownloaderProgressiveDownload;</span><br><span class="line">            <span class="keyword">if</span> (options &amp; SDWebImageRefreshCached) downloaderOptions |= SDWebImageDownloaderUseNSURLCache;</span><br><span class="line">            <span class="keyword">if</span> (options &amp; SDWebImageContinueInBackground) downloaderOptions |= SDWebImageDownloaderContinueInBackground;</span><br><span class="line">            <span class="keyword">if</span> (options &amp; SDWebImageHandleCookies) downloaderOptions |= SDWebImageDownloaderHandleCookies;</span><br><span class="line">            <span class="keyword">if</span> (options &amp; SDWebImageAllowInvalidSSLCertificates) downloaderOptions |= SDWebImageDownloaderAllowInvalidSSLCertificates;</span><br><span class="line">            <span class="keyword">if</span> (options &amp; SDWebImageHighPriority) downloaderOptions |= SDWebImageDownloaderHighPriority;</span><br><span class="line">            <span class="keyword">if</span> (options &amp; SDWebImageScaleDownLargeImages) downloaderOptions |= SDWebImageDownloaderScaleDownLargeImages;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             如果设置了强制刷新缓存的选项。则`SDWebImageDownloaderProgressiveDownload`选项失效并且添加`SDWebImageDownloaderIgnoreCachedResponse`选项。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</span><br><span class="line">                <span class="comment">// force progressive off if image already cached but forced refreshing</span></span><br><span class="line">                <span class="comment">//如果图像已缓存但强制刷新，则强制渐进关闭</span></span><br><span class="line">                downloaderOptions &amp;= ~SDWebImageDownloaderProgressiveDownload;</span><br><span class="line">                <span class="comment">// ignore image read from NSURLCache if image if cached but force refreshing</span></span><br><span class="line">                <span class="comment">//忽略从NSURLCache读取的图像，如果图像缓存但强制刷新</span></span><br><span class="line">                downloaderOptions |= SDWebImageDownloaderIgnoreCachedResponse;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// `SDWebImageCombinedOperation` -&gt; `SDWebImageDownloadToken` -&gt; `downloadOperationCancelToken`, which is a `SDCallbacksDictionary` and retain the completed block below, so we need weak-strong again to avoid retain cycle</span></span><br><span class="line">            __weak typeof(strongOperation) weakSubOperation = strongOperation;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             新建一个网络下载的操作。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            strongOperation.downloadToken = [self.imageDownloader <span class="string">downloadImageWithURL:</span>url <span class="string">options:</span>downloaderOptions <span class="string">progress:</span>progressBlock <span class="string">completed:</span>^(UIImage *downloadedImage, NSData *downloadedData, NSError *error, BOOL finished) &#123;</span><br><span class="line">                __strong typeof(weakSubOperation) strongSubOperation = weakSubOperation;</span><br><span class="line">                <span class="comment">//如果操作被取消或者不存在，则不执行任何操作</span></span><br><span class="line">                <span class="keyword">if</span> (!strongSubOperation || strongSubOperation.isCancelled) &#123;</span><br><span class="line">                    <span class="comment">// Do nothing if the operation was cancelled</span></span><br><span class="line">                    <span class="comment">// See #699 for more details</span></span><br><span class="line">                    <span class="comment">// if we would call the completedBlock, there could be a race condition between this block and another completedBlock for the same object, so if this one is called second, we will overwrite the new data</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                    <span class="comment">//如果加载出错。则直接返回回调。并且添加到failedURLs中</span></span><br><span class="line">                    [self <span class="string">callCompletionBlockForOperation:</span>strongSubOperation <span class="string">completion:</span>completedBlock <span class="string">error:</span>error <span class="string">url:</span>url];</span><br><span class="line">                    BOOL shouldBlockFailedURL;</span><br><span class="line">                    <span class="comment">// Check whether we should block failed url</span></span><br><span class="line">                    <span class="comment">//检查我们是否应该阻止失败的网址</span></span><br><span class="line">                    <span class="keyword">if</span> ([self.delegate <span class="string">respondsToSelector:</span><span class="meta">@selector</span>(<span class="string">imageManager:</span><span class="string">shouldBlockFailedURL:</span><span class="string">withError:</span>)]) &#123;</span><br><span class="line">                        shouldBlockFailedURL = [self.delegate <span class="string">imageManager:</span>self <span class="string">shouldBlockFailedURL:</span>url <span class="string">withError:</span>error];</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        shouldBlockFailedURL = (   error.code != NSURLErrorNotConnectedToInternet</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorCancelled</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorTimedOut</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorInternationalRoamingOff</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorDataNotAllowed</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorCannotFindHost</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorCannotConnectToHost</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorNetworkConnectionLost);</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//如果shouldBlockFailedURL为YES，即阻止失败的网址，添加到failedURLs中</span></span><br><span class="line">                    <span class="keyword">if</span> (shouldBlockFailedURL) &#123;</span><br><span class="line">                        LOCK(self.failedURLsLock);</span><br><span class="line">                        [self.failedURLs <span class="string">addObject:</span>url];</span><br><span class="line">                        UNLOCK(self.failedURLsLock);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//加载图片成功，</span></span><br><span class="line">                    <span class="comment">//如果options选项设置为SDWebImageRetryFailed，则把url从failedURLS中移除</span></span><br><span class="line">                    <span class="keyword">if</span> ((options &amp; SDWebImageRetryFailed)) &#123;</span><br><span class="line">                        LOCK(self.failedURLsLock);</span><br><span class="line">                        [self.failedURLs <span class="string">removeObject:</span>url];</span><br><span class="line">                        UNLOCK(self.failedURLsLock);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//是否缓存在磁盘上</span></span><br><span class="line">                    BOOL cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// We've done the scale process in SDWebImageDownloader with the shared manager, this is used for custom manager and avoid extra scale.（我们已经使用共享管理器在SDWebImageDownloader中完成了缩放过程，这用于自定义管理器并避免额外的扩展。）</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//如果self不为SDWebImageManager单例，并且cacheKeyFilter（缓存可以代码块存在，下载的图像存在），则缩放下载的图像</span></span><br><span class="line">                    <span class="keyword">if</span> (self != [SDWebImageManager sharedManager] &amp;&amp; self.cacheKeyFilter &amp;&amp; downloadedImage) &#123;</span><br><span class="line">                        downloadedImage = [self <span class="string">scaledImageForKey:</span>key <span class="string">image:</span>downloadedImage];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果options选项为SDWebImageRefreshCached，并且缓存图像存在，下载图像不存在。图像刷新命中NSURLCache缓存，不调用完成块</span></span><br><span class="line">                    <span class="keyword">if</span> (options &amp; SDWebImageRefreshCached &amp;&amp; cachedImage &amp;&amp; !downloadedImage) &#123;</span><br><span class="line">                        <span class="comment">// Image refresh hit the NSURLCache cache, do not call the completion block</span></span><br><span class="line">                        <span class="comment">//图像刷新命中NSURLCache缓存，不调用完成块</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [self.delegate <span class="string">respondsToSelector:</span><span class="meta">@selector</span>(<span class="string">imageManager:</span><span class="string">transformDownloadedImage:</span><span class="string">withURL:</span>)]) &#123;</span><br><span class="line">                     <span class="comment">//如果成功下载图片。并且图片是动态图片。并且设置了SDWebImageTransformAnimatedImage属性。则处理图片</span></span><br><span class="line">                     </span><br><span class="line">                        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123;</span><br><span class="line">                            <span class="comment">//获取transform以后的图片</span></span><br><span class="line">                            UIImage *transformedImage = [self.delegate <span class="string">imageManager:</span>self <span class="string">transformDownloadedImage:</span>downloadedImage <span class="string">withURL:</span>url];</span><br><span class="line">                            <span class="comment">//存储transform以后的的图片</span></span><br><span class="line">                            <span class="keyword">if</span> (transformedImage &amp;&amp; finished) &#123;</span><br><span class="line">                                BOOL imageWasTransformed = ![transformedImage <span class="string">isEqual:</span>downloadedImage];</span><br><span class="line">                                NSData *cacheData;</span><br><span class="line">                                <span class="comment">// pass nil if the image was transformed, so we can recalculate the data from the image（如果图像被转换，则传递nil，因此我们可以重新计算图像中的数据）</span></span><br><span class="line">                                </span><br><span class="line">                                <span class="comment">//cacheSerializer：将图像缓存到磁盘的解码算法，返回的是data。如果self.cacheSerializer存在，则重新计算图像中的数据。</span></span><br><span class="line">                                <span class="keyword">if</span> (self.cacheSerializer) &#123;</span><br><span class="line">                                    cacheData = self.cacheSerializer(transformedImage, (imageWasTransformed ? nil : downloadedData), url);</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    cacheData = (imageWasTransformed ? nil : downloadedData);</span><br><span class="line">                                &#125;</span><br><span class="line">                               <span class="comment">//存储transform以后的图片</span></span><br><span class="line">                                [self.imageCache <span class="string">storeImage:</span>transformedImage <span class="string">imageData:</span>cacheData <span class="string">forKey:</span>key <span class="string">toDisk:</span>cacheOnDisk <span class="string">completion:</span>nil];</span><br><span class="line">                            &#125;</span><br><span class="line">                             <span class="comment">//回调拼接</span></span><br><span class="line">                            [self <span class="string">callCompletionBlockForOperation:</span>strongSubOperation <span class="string">completion:</span>completedBlock <span class="string">image:</span>transformedImage <span class="string">data:</span>downloadedData <span class="string">error:</span>nil <span class="string">cacheType:</span>SDImageCacheTypeNone <span class="string">finished:</span>finished <span class="string">url:</span>url];</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果成功下载图片。并且图片不是图片。则直接缓存和回调</span></span><br><span class="line">                        <span class="keyword">if</span> (downloadedImage &amp;&amp; finished) &#123;</span><br><span class="line">                            <span class="comment">//cacheSerializer：将图像缓存到磁盘的解码算法，返回的是data。如果self.cacheSerializer存在，则重新计算图像中的数据。</span></span><br><span class="line">                            <span class="keyword">if</span> (self.cacheSerializer) &#123;</span><br><span class="line">                                dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123;</span><br><span class="line">                                    NSData *cacheData = self.cacheSerializer(downloadedImage, downloadedData, url);</span><br><span class="line">                                     <span class="comment">//存储transform以后的图片</span></span><br><span class="line">                                    [self.imageCache <span class="string">storeImage:</span>downloadedImage <span class="string">imageData:</span>cacheData <span class="string">forKey:</span>key <span class="string">toDisk:</span>cacheOnDisk <span class="string">completion:</span>nil];</span><br><span class="line">                                &#125;);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="comment">//存储transform以后的图片</span></span><br><span class="line">                                [self.imageCache <span class="string">storeImage:</span>downloadedImage <span class="string">imageData:</span>downloadedData <span class="string">forKey:</span>key <span class="string">toDisk:</span>cacheOnDisk <span class="string">completion:</span>nil];</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                         <span class="comment">//回调拼接</span></span><br><span class="line">                        [self <span class="string">callCompletionBlockForOperation:</span>strongSubOperation <span class="string">completion:</span>completedBlock <span class="string">image:</span>downloadedImage <span class="string">data:</span>downloadedData <span class="string">error:</span>nil <span class="string">cacheType:</span>SDImageCacheTypeNone <span class="string">finished:</span>finished <span class="string">url:</span>url];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//从正在加载的图片操作集合中移除当前操作</span></span><br><span class="line">                <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">                    [self <span class="string">safelyRemoveOperationFromRunning:</span>strongSubOperation];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cachedImage) &#123;</span><br><span class="line">            <span class="comment">//如果缓存的图像存在，回调拼接，安全移除Operation对象</span></span><br><span class="line">            [self <span class="string">callCompletionBlockForOperation:</span>strongOperation <span class="string">completion:</span>completedBlock <span class="string">image:</span>cachedImage <span class="string">data:</span>cachedData <span class="string">error:</span>nil <span class="string">cacheType:</span>cacheType <span class="string">finished:</span>YES <span class="string">url:</span>url];</span><br><span class="line">            [self <span class="string">safelyRemoveOperationFromRunning:</span>strongOperation];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Image not in cache and download disallowed by delegate（委托不允许图像不在缓存和下载中）</span></span><br><span class="line">             <span class="comment">//如果缓存的图像不存在，回调拼接，安全移除Operation对象</span></span><br><span class="line">            [self <span class="string">callCompletionBlockForOperation:</span>strongOperation <span class="string">completion:</span>completedBlock <span class="string">image:</span>nil <span class="string">data:</span>nil <span class="string">error:</span>nil <span class="string">cacheType:</span>SDImageCacheTypeNone <span class="string">finished:</span>YES <span class="string">url:</span>url];</span><br><span class="line">            [self <span class="string">safelyRemoveOperationFromRunning:</span>strongOperation];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-8、SDWebImageCompat的图像缩放操作"><a href="#2-8、SDWebImageCompat的图像缩放操作" class="headerlink" title="2.8、SDWebImageCompat的图像缩放操作"></a>2.8、<code>SDWebImageCompat</code>的图像缩放操作</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  放缩操作：根据图片中的图片组 或 scale 重新计算返回图片</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment"> *  @param key   键：就是图片的地址</span></span><br><span class="line"><span class="comment"> *  @param image UIImage</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment"> *  @return UIImage</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">inline</span> UIImage *SDScaledImageForKey(NSString * _Nullable key, UIImage * _Nullable <span class="built_in">image</span>) &#123;</span><br><span class="line">    <span class="comment">//图片为空，返回nil</span></span><br><span class="line">    <span class="built_in">if</span> (!<span class="built_in">image</span>) &#123;</span><br><span class="line">        <span class="built_in">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SD_MAC <span class="comment">//如果是MAC，直接返回图片</span></span></span><br><span class="line">    <span class="built_in">return</span> <span class="built_in">image</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> SD_UIKIT || SD_WATCH <span class="comment">//iOS或者watch</span></span></span><br><span class="line">    <span class="built_in">if</span> ((<span class="built_in">image</span>.images).count &gt; <span class="number">0</span>) &#123;<span class="comment">//动态图</span></span><br><span class="line">        NSMutableArray&lt;UIImage *&gt; *scaledImages = [NSMutableArray <span class="keyword">array</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">for</span> (UIImage *tempImage in <span class="built_in">image</span>.images) &#123;</span><br><span class="line">            <span class="comment">//动态图还是执行该方法，处理单个图片</span></span><br><span class="line">            [scaledImages addObject:SDScaledImageForKey(key, tempImage)];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建一个动态图片，动态图片持续的时间为duration</span></span><br><span class="line">        UIImage *animatedImage = [UIImage animatedImageWithImages:scaledImages duration:<span class="built_in">image</span>.duration];</span><br><span class="line">        <span class="built_in">if</span> (animatedImage) &#123;</span><br><span class="line">            animatedImage.sd_imageLoopCount = <span class="built_in">image</span>.sd_imageLoopCount;</span><br><span class="line">            animatedImage.sd_imageFormat = <span class="built_in">image</span>.sd_imageFormat;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> animatedImage;</span><br><span class="line">    &#125; <span class="built_in">else</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SD_WATCH</span></span><br><span class="line">        <span class="built_in">if</span> ([[WKInterfaceDevice currentDevice] respondsToSelector:@selector(screenScale)]) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> SD_UIKIT</span></span><br><span class="line">        <span class="built_in">if</span> ([[UIScreen mainScreen] respondsToSelector:@selector(scale)]) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">           <span class="comment">// 比如屏幕为320x480时，scale为1，屏幕为640x960时，scale为2</span></span><br><span class="line">            CGFloat scale = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// “@2x.png”的长度为7，所以此处添加了这个判断，很巧妙</span></span><br><span class="line">            <span class="built_in">if</span> (key.length &gt;= <span class="number">8</span>) &#123;</span><br><span class="line">                <span class="comment">//根据后缀给scale赋值</span></span><br><span class="line">                NSRange range = [key rangeOfString:@<span class="string">"@2x."</span>];</span><br><span class="line">                <span class="built_in">if</span> (range.location != NSNotFound) &#123;</span><br><span class="line">                    scale = <span class="number">2.0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                range = [key rangeOfString:@<span class="string">"@3x."</span>];</span><br><span class="line">                <span class="built_in">if</span> (range.location != NSNotFound) &#123;</span><br><span class="line">                    scale = <span class="number">3.0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 使用initWithCGImage来根据Core Graphics的图片构建UIImage。</span></span><br><span class="line">            <span class="comment">// 这个函数可以使用scale和orientation</span></span><br><span class="line">            UIImage *scaledImage = [[UIImage alloc] initWithCGImage:<span class="built_in">image</span>.CGImage scale:scale orientation:<span class="built_in">image</span>.imageOrientation];</span><br><span class="line">            scaledImage.sd_imageFormat = <span class="built_in">image</span>.sd_imageFormat;</span><br><span class="line">            <span class="built_in">image</span> = scaledImage;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> <span class="built_in">image</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NSString *<span class="keyword">const</span> SDWebImageErrorDomain = @<span class="string">"SDWebImageErrorDomain"</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、整体框架&quot;&gt;&lt;a href=&quot;#1、整体框架&quot; class=&quot;headerlink&quot; title=&quot;1、整体框架&quot;&gt;&lt;/a&gt;1、整体框架&lt;/h2&gt;&lt;p&gt;看下整体的框架图：&lt;br&gt;&lt;img src=&quot;http://obzx0h1re.bkt.clouddn.co
      
    
    </summary>
    
      <category term="读SDWebImage手札" scheme="http://guohuaden.com/categories/%E8%AF%BBSDWebImage%E6%89%8B%E6%9C%AD/"/>
    
    
      <category term="SDWebImage" scheme="http://guohuaden.com/tags/SDWebImage/"/>
    
  </entry>
  
  <entry>
    <title>读 SDWebImage 一 使用分析</title>
    <link href="http://guohuaden.com/2018/09/29/Read-SDWebImage-note1/"/>
    <id>http://guohuaden.com/2018/09/29/Read-SDWebImage-note1/</id>
    <published>2018-09-29T06:32:04.000Z</published>
    <updated>2018-10-25T11:22:24.733Z</updated>
    
    <content type="html"><![CDATA[<p>SDWebImage整体的框架：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">SDWebImage</span><br><span class="line">    -</span><br><span class="line">    |<span class="string">--SDWebImageCompat :一些兼容性相关的宏定义 </span></span><br><span class="line"><span class="string">    </span>|<span class="string">--SDWebImageOperation :只有一个 cancel 方法的 protocal</span></span><br><span class="line"><span class="string">    </span>|</span><br><span class="line">    |<span class="string">--Downloader :下载模块</span></span><br><span class="line"><span class="string">    </span>|<span class="string">   </span>|<span class="string">-- SDWebImageDownloader</span></span><br><span class="line"><span class="string">    </span>|<span class="string">   </span>|<span class="string">-- SDWebImageDownloaderOperation</span></span><br><span class="line"><span class="string">    </span>|<span class="string">   </span></span><br><span class="line"><span class="string">    </span>|<span class="string">--Cache :内存和硬盘缓存模块</span></span><br><span class="line"><span class="string">    </span>|<span class="string">   </span>|<span class="string">-- SDImageCache</span></span><br><span class="line"><span class="string">    </span>|</span><br><span class="line">    |<span class="string">--Utils :</span></span><br><span class="line"><span class="string">    </span>|<span class="string">   </span>|<span class="string">-- SDWebImageManager 将缓存和下载模块结合起来使用</span></span><br><span class="line"><span class="string">    </span>|<span class="string">   </span>|<span class="string">-- SDWebImagePrefetcher 预下载图片</span></span><br><span class="line"><span class="string">    </span>|<span class="string">   </span>|<span class="string">-- SDWebImageDecoder</span></span><br><span class="line"><span class="string">    </span>|</span><br><span class="line">    |<span class="string">--Categories : UIKit 相关的Category,方便使用,还支持 MKAnnotationView</span></span><br><span class="line"><span class="string">        </span>|<span class="string">-- MKAnnotationView+WebCache</span></span><br><span class="line"><span class="string">        </span>|<span class="string">-- UIButton+WebCache</span></span><br><span class="line"><span class="string">        </span>|<span class="string">-- UIImageView+WebCache</span></span><br><span class="line"><span class="string">    -</span></span><br><span class="line"><span class="string">    ... ...</span></span><br></pre></td></tr></table></figure><h2 id="1、使用配置"><a href="#1、使用配置" class="headerlink" title="1、使用配置"></a>1、使用配置</h2><p>为项目添加一个通用的只读缓存的存储路径:</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">NSString</span> *bundlePath = [[<span class="symbol">NSBundle</span> mainBundle].resourcePath stringByAppendingPathComponent:@<span class="string">"CustomPathImages"</span>];</span><br><span class="line"> </span><br><span class="line">[[<span class="symbol">SDImageCache</span> sharedImageCache] addReadOnlyCachePath:bundlePath];</span><br></pre></td></tr></table></figure><h2 id="2、-身份鉴定"><a href="#2、-身份鉴定" class="headerlink" title="2、 身份鉴定"></a>2、 身份鉴定</h2><p>如果请求的图片需要身份鉴定才可以获取，SDWebImage提供了两种方法：</p><p>一种是直接设置用户名和密码：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[SDWebImageManager <span class="keyword">sharedManager].imageDownloader.username </span>= @<span class="string">"httpwatch"</span><span class="comment">;</span></span><br><span class="line">[SDWebImageManager <span class="keyword">sharedManager].imageDownloader.password </span>= @<span class="string">"httpwatch01"</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p>另一种是通过 <code>NSURLCredential</code> 属性去配置用户名和密码</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSURLCredential *<span class="keyword">new</span><span class="type">Credential</span> = [NSURLCredential credentialWithUser:<span class="type"></span>@<span class="string">"httpwatch"</span> password:<span class="type"></span>@<span class="string">"httpwatch01"</span> persistence:<span class="type">NSURLCredentialPersistenceNone</span>];</span><br><span class="line">[SDWebImageManager sharedManager].imageDownloader.urlCredential = <span class="keyword">new</span><span class="type">Credential</span>;</span><br></pre></td></tr></table></figure><p>这里做下测试：<br>图片地址（需要身份验证才可以查看）：<a href="http://www.httpwatch.com/httpgallery/authentication/authenticatedimage/default.aspx?0.35786508303135633" target="_blank" rel="noopener">http://www.httpwatch.com/httpgallery/authentication/authenticatedimage/default.aspx?0.35786508303135633</a></p><p>浏览器去打开会弹出提示框让输入验证信息，如下：<br><img src="http://obzx0h1re.bkt.clouddn.com/Authentication_Image_SDWebImage.jpg" alt="Authentication_Image_SDWebImage"></p><p>这种情况下，在项目中就需要配置身份验证信息，否则图片无法显示。</p><h2 id="3、设置要附加到每个下载HTTP请求的HTTP标头的值"><a href="#3、设置要附加到每个下载HTTP请求的HTTP标头的值" class="headerlink" title="3、设置要附加到每个下载HTTP请求的HTTP标头的值"></a>3、设置要附加到每个下载HTTP请求的HTTP标头的值</h2><p>如果想要自定义图片请求的Request Header时，可以使用以下方法：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置要附加到每个下载HTTP请求的HTTP标头的值。</span></span><br><span class="line">  [SDWebImageManager.sharedManager.imageDownloader <span class="string">setValue:</span>@<span class="string">"&amp;&amp;Jason&amp;&amp;"</span> <span class="string">forHTTPHeaderField:</span>@<span class="string">"****SDWebImageM****"</span>];</span><br></pre></td></tr></table></figure><p>通过charles抓包可以看到设置的Request Header：</p><p><img src="http://obzx0h1re.bkt.clouddn.com/setValue_1_SDWebImageManager.jpg" alt="setValue_1_SDWebImageManager"></p><p><img src="http://obzx0h1re.bkt.clouddn.com/setValue_2_SDWebImageManager.jpg" alt="setValue_2_SDWebImageManager"></p><h2 id="4、图片下载执行顺序"><a href="#4、图片下载执行顺序" class="headerlink" title="4、图片下载执行顺序"></a>4、图片下载执行顺序</h2><p>执行顺序分：LIFO（先入后出） 和 FIFO（先进先出）两种<br>默认值为 <code>FIFO</code> 。</p><p><code>SDWebImageDownloaderExecutionOrder</code> ：枚举类型</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SDWebImageManager.<span class="keyword">sharedManager.imageDownloader.executionOrder </span>= SDWebImageDownloaderLIFOExecutionOrder<span class="comment">;</span></span><br></pre></td></tr></table></figure><h2 id="5、手动清理缓存"><a href="#5、手动清理缓存" class="headerlink" title="5、手动清理缓存"></a>5、手动清理缓存</h2><p>SDWebImage提供了手动清理缓存操作，从SDWebImage的工作原理可以想到清理缓存需清理两处：内存和磁盘。</p><p>注：这里清理的仅仅是SDWebImage的缓存，并没有清理整个app的缓存</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[SDWebImageManager.sharedManager.imageCache clearMemory]</span><span class="comment">;</span></span><br><span class="line"><span class="section">[SDWebImageManager.sharedManager.imageCache clearDiskOnCompletion:nil]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><hr><h2 id="6、将图片显示到ImgaeView-Button上"><a href="#6、将图片显示到ImgaeView-Button上" class="headerlink" title="6、将图片显示到ImgaeView / Button上"></a>6、将图片显示到ImgaeView / Button上</h2><p>Button图片或者背景图的显示和ImageView同理，只是多了几个额外的参数,下面以ImageView为例。</p><h3 id="6-1、图片显示动画"><a href="#6-1、图片显示动画" class="headerlink" title="6.1、图片显示动画"></a>6.1、图片显示动画</h3><p>图片显示过渡类型：<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.customImageView.sd_imageTransition = SDWebImageTransition.curlUpTransition<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>SDWebImage提供了七种动画过渡类型，分别是：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Fade transition. 淡出过渡</span></span><br><span class="line"><span class="meta">@property</span> (nonatomic, <span class="class"><span class="keyword">class</span>, <span class="type">nonnull</span>, <span class="type">readonly) SDWebImageTransition *fadeTransition;</span></span></span><br><span class="line"><span class="comment">/// Flip from left transition. 从左过渡翻转。</span></span><br><span class="line"><span class="meta">@property</span> (nonatomic, <span class="class"><span class="keyword">class</span>, <span class="type">nonnull</span>, <span class="type">readonly) SDWebImageTransition *flipFromLeftTransition;</span></span></span><br><span class="line"><span class="comment">/// Flip from right transition. 从右过渡翻转。</span></span><br><span class="line"><span class="meta">@property</span> (nonatomic, <span class="class"><span class="keyword">class</span>, <span class="type">nonnull</span>, <span class="type">readonly) SDWebImageTransition *flipFromRightTransition;</span></span></span><br><span class="line"><span class="comment">/// Flip from top transition. 从顶部过渡翻转。</span></span><br><span class="line"><span class="meta">@property</span> (nonatomic, <span class="class"><span class="keyword">class</span>, <span class="type">nonnull</span>, <span class="type">readonly) SDWebImageTransition *flipFromTopTransition;</span></span></span><br><span class="line"><span class="comment">/// Flip from bottom transition. 从底部过渡翻转。</span></span><br><span class="line"><span class="meta">@property</span> (nonatomic, <span class="class"><span class="keyword">class</span>, <span class="type">nonnull</span>, <span class="type">readonly) SDWebImageTransition *flipFromBottomTransition;</span></span></span><br><span class="line"><span class="comment">/// Curl up transition. 向上卷起过渡。</span></span><br><span class="line"><span class="meta">@property</span> (nonatomic, <span class="class"><span class="keyword">class</span>, <span class="type">nonnull</span>, <span class="type">readonly) SDWebImageTransition *curlUpTransition;</span></span></span><br><span class="line"><span class="comment">/// Curl down transition. 向下卷起过渡。</span></span><br><span class="line"><span class="meta">@property</span> (nonatomic, <span class="class"><span class="keyword">class</span>, <span class="type">nonnull</span>, <span class="type">readonly) SDWebImageTransition *curlDownTransition;</span></span></span><br></pre></td></tr></table></figure><h3 id="6-2-、图片显示方法"><a href="#6-2-、图片显示方法" class="headerlink" title="6.2 、图片显示方法"></a>6.2 、图片显示方法</h3><p>SDWebImage提供7种方法去显示图片，我们只看第7个，因为其他6种方法最后都是通过该方法图显示图片的。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">          placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</span><br><span class="line">                   options:(SDWebImageOptions)options</span><br><span class="line">                  progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                 completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock;</span><br></pre></td></tr></table></figure><p><strong>通过给定的URL加载图片并将其加载到此imageView中。它适用于静态和动态图像。<br>先从缓存和磁盘中寻找该图片，有则直接显示，无就下载显示并缓存。<br>下载是异步和缓存的，SDWebImage会先显示传入的占位符，直到请求完成</strong></p><h4 id="6-2-1分析参数"><a href="#6-2-1分析参数" class="headerlink" title="6.2.1分析参数"></a>6.2.1分析参数</h4><ol><li>@param url  ：图片URL</li><li>@param placeholder ：占位符（最初要设置的图像，直到图像请求完成。）</li><li>@param options ：下载图像时使用的选项。</li><li>@param progressBlock ：下载图像时调用的block代码块（稍后分析）</li><li>@param completedBlock ： 操作完成时调用的代码块。 该代码块没有返回值（稍后分析）</li></ol><p><strong>解析 options 选项（枚举类型）</strong></p><blockquote><p><code>SDWebImageRetryFailed = 1 &lt;&lt; 0,</code><br>  默认情况下当通过URL下载图片失败后，该URL就被加入黑名单，之后SDWebImage不会再去尝试下载。此标志作用就是禁用该黑名单，也就是说使用SDWebImageRetryFailed后，图片下载失败仍会尝试下载</p><p> <code>SDWebImageLowPriority = 1 &lt;&lt; 1,</code><br>  默认情况下图片在UI交互期间下载，此标志的作用就是禁用该功能。例如：在UIScrollView减速时导致延迟下载。</p><p><code>SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2,</code><br>  此标志作用是：图片下载完成后仅缓存到内存，不缓存在磁盘上</p><p><code>SDWebImageProgressiveDownload = 1 &lt;&lt; 3,</code><br>  此标志启用渐进式下载，图像在下载过程中逐步显示，就像浏览器一样。<br>  默认情况下，图像仅在完全下载后显示。</p><p><code>SDWebImageRefreshCached = 1 &lt;&lt; 4,</code><br>  即使缓存中存在该图片，也尊重HTTP响应缓存控制，在需要时从远程刷新图片。<br>  磁盘缓存将由 <code>NSURLCache</code> 替代 <code>SDWebImage</code> 去处理，这样也将导致性能略有下降。<br>  该选项有助于处理同一个URL请求但更换图片的情况，例如Facebook图形api配置文件的图片。<br>  如果刷新了缓存图片，则使用缓存图片调用一次完成block代码块，再使用最终的图片调用完成block代码块。<br>  仅当你无法使用嵌入式缓存清除参数使URL保持静态时，才使用该标志。</p><p><code>SDWebImageContinueInBackground = 1 &lt;&lt; 5,</code><br>  在<code>iOS 4+</code>中，如果app进入后台也继续下载图片，这是通过询问系统实现的。<br>  在后台有额外的时间让请求完成，如果后台任务到期，则操作被取消。</p><p><code>SDWebImageHandleCookies = 1 &lt;&lt; 6,</code><br>  通过<code>NSMutableURLRequest.HTTPShouldHandleCookies = YES</code>设置处理在 <code>NSHTTPCookieStore</code>中的cookies。</p><p>  <code>SDWebImageAllowInvalidSSLCertificates = 1 &lt;&lt; 7,</code><br>  启用允许不受信任的SSL证书（用于测试目的，在生产中谨慎使用）</p><p><code>SDWebImageHighPriority = 1 &lt;&lt; 8,</code><br>  默认情况下，图像按其排队顺序加载，此标志将它们移动到队列的前面</p><p><code>SDWebImageDelayPlaceholder = 1 &lt;&lt; 9,</code><br>  默认情况下，加载图像时会加载占位符。 此标志将延迟加载占位符图像，直到图像加载完毕。</p><p><code>SDWebImageTransformAnimatedImage = 1 &lt;&lt; 10,</code><br>  我们通常不会在动画图像上调用transformDownloadedImage委托方法，因为大多数转换代码会破坏它。如果使用必须使用此标志来转换它们。  </p><p><code>SDWebImageAvoidAutoSetImage = 1 &lt;&lt; 11,</code><br>  默认情况下，下载后会将图像添加到imageView。 但在某些情况下，我们想要<br>  在设置图像之前手动处理一些东西（例如应用滤镜或添加交叉渐变动画）请使用此标志</p><p><code>SDWebImageScaleDownLargeImages = 1 &lt;&lt; 12,</code><br>  默认情况下，图像会根据其原始大小进行解码。 在iOS上，此标志将缩小<br>  图像尺寸与设备的受限内存兼容。（如果设置了“SDWebImageProgressiveDownload”标志，则停用缩小比例。）</p><p><code>SDWebImageQueryDataWhenInMemory = 1 &lt;&lt; 13,</code><br>  默认情况下，当图像缓存在内存中时，我们不查询磁盘数据。 此掩码可以强制同时查询磁盘数据。<br>  建议将此标志与<code>SDWebImageQueryDiskSync</code>一起使用，以确保图像在同一个runloop中加载。 </p><p><code>SDWebImageQueryDiskSync = 1 &lt;&lt; 14,</code><br>  默认情况下，我们同步查询内存缓存，异步查询磁盘缓存。 此掩码可以强制同步查询磁盘缓存，以确保在同一个runloop中加载映像。<br>  如果禁用内存缓存或在某些其他情况下，此标志可以避免在单元重用期间闪烁。</p><p><code>SDWebImageFromCacheOnly = 1 &lt;&lt; 15,</code><br>  默认情况下，当缓存丢失时，将从网络下载映像。此标志可以阻止网络仅从缓存加载。</p><p><code>SDWebImageForceTransition = 1 &lt;&lt; 16</code><br>  默认情况下，当您使用 <code>SDWebImageTransition</code> 在图像加载完成后进行某些视图转换时，此转换仅适用于从网络下载图像。 此掩码也可以强制为内存和磁盘缓存应用视图转换。</p></blockquote><p><strong>解析progressBlock代码块</strong><br>下载图像时重复调用的代码块,在后台队列上执行,包含三个参数，分别是：<br>NSInteger receivedSize：接收到的图片大小<br>NSInteger expectedSize：预期的图片大小<br>NSURL * _Nullable targetURL：目标图片的URL</p><p><strong>completedBlock代码块</strong><br>包含四个参数：<br>(UIImage <em> _Nullable image, NSError </em> _Nullable error, SDImageCacheType cacheType, NSURL * _Nullable imageURL)</p><ol><li>第一个参数是：请求得到的UIImage，如果请求失败，该图像参数是为nil</li><li>第二个参数： 请求结果中可能包含的NSError</li><li>第三个参数： 是枚举，缓存类型，通过类型判断图片从哪里获取。分三种： SDImageCacheTypeNone 、SDImageCacheTypeDisk、SDImageCacheTypeMemory 。</li><li>第四个参数：图片的URL。</li></ol><p>以下是其他6种显示图片的方法，只做简单的分析：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *通过给定的URL加载图片并将其加载到此imageView中。它适用于静态和动态图像</span></span><br><span class="line"><span class="comment"> * 先从缓存和磁盘中寻找，有则显示，无就下载显示并缓存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">          placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder ;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">          placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</span><br><span class="line">                   options:(SDWebImageOptions)options ;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">                 completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">          placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</span><br><span class="line">                 completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock ;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">          placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</span><br><span class="line">                   options:(SDWebImageOptions)options</span><br><span class="line">                 completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">          placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</span><br><span class="line">                   options:(SDWebImageOptions)options</span><br><span class="line">                  progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                 completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock;</span><br></pre></td></tr></table></figure></p><hr><h2 id="7、图像显示的最终调用方法解析"><a href="#7、图像显示的最终调用方法解析" class="headerlink" title="7、图像显示的最终调用方法解析"></a>7、图像显示的最终调用方法解析</h2><p>通过上面的七种方法来加载图像，其实前6种都是调用第7种完善的方法。而这7种方法都是调用的另一种方法。如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)sd_internalSetImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">                  placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</span><br><span class="line">                           options:(SDWebImageOptions)options</span><br><span class="line">                      operationKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)operationKey</span><br><span class="line">                     setImageBlock:(<span class="keyword">nullable</span> SDSetImageBlock)setImageBlock</span><br><span class="line">                          progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                         completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock</span><br><span class="line">                           context:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)context;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ol><li>@param url  ：图像URL</li><li>@param placeholder ：初始化image，知道图像请求完成</li><li>@param options ：图像下载时的选项</li><li>@param operationKey ：用作操作key的字符串。 如果为nil，将使用类名（ImageView加载图像时直接传的nil，Button加载图像时传【字符串和UIControlState状态的拼接】）</li><li>@param setImageBlock ： 用于自定义设置图像的代码块</li><li>@param progressBlock ： 下载图像时调用的代码块</li><li>@param completedBlock ： 操作完成时调用的代码块。 该块没有返回值</li><li>@param context ： 具有执行特定更改或过程的额外信息的上下文。</li></ol><p>其实可以看出：除了参数4、5、8之外，剩下的都是和ImageView加载图像时参数一样，因为这本就是ImageView加载图像最终调用的方法。而参数4、5、8则是Button加载图像传入的参数，这也证明了代码的高内聚力。</p><p><strong>SDSetImageBlock：</strong><br>包含两个参数：<br>(UIImage <em>image, NSData </em>imageData)<br>我们通常在该回调中自定义图像（比如说压缩、剪切、加滤镜、加蒙层等）<br>或者直接简单的显示图像：<code>[weakSelf setImage:image forState:state];</code></p><p>看下整体的代码：<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="literal">self</span> sd_internalSetImageWithURL:url</span><br><span class="line">                    placeholderImage:placeholder</span><br><span class="line">                             options:options</span><br><span class="line">                        operationKey:imageOperationKeyForState(<span class="keyword">state</span>)</span><br><span class="line">                       <span class="built_in">set</span>ImageBlock:^(UIImage *image, NSData *imageData) &#123;</span><br><span class="line">                           [weakSelf <span class="built_in">set</span>Image:image <span class="keyword">for</span>State:<span class="keyword">state</span>]; //自定义图像</span><br><span class="line">                       &#125;</span><br><span class="line">                            progress:nil</span><br><span class="line">                           completed:completedBlock];</span><br></pre></td></tr></table></figure></p><p> <strong>context ： 上下文信息</strong></p><p>这个是最后才加上的，为的是获取额外的信息（加载的过程信息、更改信息等）</p><h3 id="7-1、分析最终的加载图像的方法"><a href="#7-1、分析最终的加载图像的方法" class="headerlink" title="7.1、分析最终的加载图像的方法"></a>7.1、分析最终的加载图像的方法</h3><p>该方法是针对UIView的子类进行图像加载的（例如：UIImageView、UIButton）<br>下面会拆成代码片段一步一步看</p><h4 id="7-1-1、第一步"><a href="#7-1-1、第一步" class="headerlink" title="7.1.1、第一步"></a>7.1.1、第一步</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> imageURLKey;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *validOperationKey = operationKey ?: <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]);</span><br><span class="line">[<span class="keyword">self</span> sd_cancelImageLoadOperationWithKey:validOperationKey];</span><br><span class="line">objc_setAssociatedObject(<span class="keyword">self</span>, &amp;imageURLKey, url, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br></pre></td></tr></table></figure><ol><li>初始化一个有效的操作key，如果传入的 <code>operationKey</code> 为nil，则赋值为类名 <code>NSStringFromClass([self class])</code> </li><li>通过 <code>operationKey</code> 从队列中取消正在进行的下载操作。</li><li>最后将该类与图像的URL关联起来，关联类型是 ：<code>OBJC_ASSOCIATION_RETAIN_NONATOMIC</code> (指定对关联对象的强引用。)</li></ol><p>以下列出所有的关联类型</p><table><thead><tr><th style="text-align:left">关联策略</th><th style="text-align:left">等价属性</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">OBJC_ASSOCIATION_ASSIGN</td><td style="text-align:left">@property (assign) or @property (unsafe_unretained)</td><td style="text-align:left">弱引用关联对象</td></tr><tr><td style="text-align:left">OBJC_ASSOCIATION_RETAIN_NONATOMIC</td><td style="text-align:left">@property (strong, nonatomic)</td><td style="text-align:left">强引用关联对象，且为非原子操作</td></tr><tr><td style="text-align:left">OBJC_ASSOCIATION_COPY_NONATOMIC</td><td style="text-align:left">@property (copy, nonatomic)</td><td style="text-align:left">复制关联对象，且为非原子操作</td></tr><tr><td style="text-align:left">OBJC_ASSOCIATION_RETAIN</td><td style="text-align:left">@property (strong, atomic)</td><td style="text-align:left">强引用关联对象，且为原子操作</td></tr><tr><td style="text-align:left">OBJC_ASSOCIATION_COPY</td><td style="text-align:left">@property (copy, atomic)</td><td style="text-align:left">复制关联对象，且为原子操作</td></tr></tbody></table><p>再回到第2条看下怎么通过 <code>operationKey</code> 取消对应正在进行下载的操作（顺便附上加载图像的操作，因为两者正好始和末）：<br>代码：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置加载图像的操作</span></span><br><span class="line">- (<span class="keyword">void</span>)sd_setImageLoadOperation:(<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;SDWebImageOperation&gt;)operation forKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">if</span> (key) &#123;</span><br><span class="line">        [<span class="keyword">self</span> sd_cancelImageLoadOperationWithKey:key];</span><br><span class="line">        <span class="keyword">if</span> (operation) &#123;</span><br><span class="line">            SDOperationsDictionary *operationDictionary = [<span class="keyword">self</span> sd_operationDictionary];</span><br><span class="line">            <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">                [operationDictionary setObject:operation forKey:key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置取消加载图像的操作</span></span><br><span class="line">- (<span class="keyword">void</span>)sd_cancelImageLoadOperationWithKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">if</span> (key) &#123;</span><br><span class="line">        <span class="comment">// Cancel in progress downloader from queue</span></span><br><span class="line">        SDOperationsDictionary *operationDictionary = [<span class="keyword">self</span> sd_operationDictionary];</span><br><span class="line">        <span class="keyword">id</span>&lt;SDWebImageOperation&gt; operation;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">            operation = [operationDictionary objectForKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (operation) &#123;</span><br><span class="line">            <span class="keyword">if</span> ([operation conformsToProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">SDWebImageOperation</span>)]) </span>&#123;</span><br><span class="line">                [operation cancel];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">                [operationDictionary removeObjectForKey:key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>分析：<br><strong>首先</strong>，获取当前的一个 <code>NSMapTable</code> ，可以说是一个广义的字典，官方文档是这样解释 <code>NSMapTable</code> 的：</p><blockquote><p>An NSMapTable is modeled after a dictionary, although, because of its options, is not a dictionary because it will behave differently.  The major option is to have keys and/or values held “weakly” in a manner that entries will be removed at some indefinite point after one of the objects is reclaimed.  In addition to being held weakly, keys or values may be copied on input or may use pointer identity for equality and hashing.<br> An NSMapTable can also be configured to operate on arbitrary pointers and not just objects.We recommend the C function API for “void *” access</p></blockquote><p>大体可以理解为：<br> <code>NSMapTable</code> 是在字典之后的一个可变集合模型化的类，但由于它的选项是使 <code>key</code> 和/或 <code>valus</code> 保持“弱有化”，以便在回收其中一个对象之后在某个不确定点删除条目，所以它不是字典，因为它的行为会有所不同。 除了被弱化之外，可以在输入上复制 <code>key</code> 或 <code>valus</code>，或者可以使用指针标识来进行相等和 <code>hash</code>（散列or哈希）操作。<br> <code>NSMapTable</code> 也可以配置为对任意指针进行操作，而不仅仅是对象。 Apple建议使用C函数API进行 <code>void *</code> 访问。</p><p> SDWebImage是这样定义 <code>NSMapTable</code> 的：<br> <figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// key is copy, value is weak because operation<span class="built_in"> instance </span>is retained by SDWebImageManager's runningOperations property</span><br><span class="line">typedef NSMapTable&lt;NSString *, id&lt;SDWebImageOperation&gt;&gt; SDOperationsDictionary;</span><br></pre></td></tr></table></figure></p><p> key使用的是copy，value则使用的是weak，并给出了解释：操作实例由SDWebImageManager的runningOperations属性保留</p><p><strong>注：</strong>获取当前的 <code>NSMapTable</code> ，以下用 <code>operationDictionary</code> 叙述。</p><p> <strong>其次</strong>，将该图像的加载操作存放入 <code>operationDictionary</code> 中，而key正是我们上面分析的 <code>operationKey</code> 。这里为了防止在操作是被篡改，使用 <code>@synchronized</code> 做了互斥锁处理。</p><p> <strong>最后</strong>，现在再看取消加载图像的操作流程就显得清晰了，大体如下：</p><ol><li>获取当前的一个 <code>operationDictionary</code> 通过key取得操作。</li><li>如果该操作存在，就通过 <code>conformsToProtocol:@protocol()</code> 检查对象是否实现了指定协议类的方法。</li><li>如果存在就直接取消，最后从移除 <code>operationDictionary</code> 该操作</li></ol><p><strong>扩展：<code>objc_setAssociatedObject</code></strong></p><ul><li>在 Objective-C 中可以通过 Category 给一个现有的类添加属性，却不能添加实例变量，这成了 Objective-C 的一个明显短板。但可以通过 Associated Objects 来弥补这一不足。</li><li>相关函数：<br>与 Associated Objects 相关的函数主要有三个:<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_setAssociatedObject</span>(<span class="params">id <span class="keyword">object</span>, <span class="keyword">const</span> <span class="keyword">void</span> *key, id <span class="keyword">value</span>, objc_AssociationPolicy policy</span>)</span>;</span><br><span class="line"><span class="function">id <span class="title">objc_getAssociatedObject</span>(<span class="params">id <span class="keyword">object</span>, <span class="keyword">const</span> <span class="keyword">void</span> *key</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_removeAssociatedObjects</span>(<span class="params">id <span class="keyword">object</span></span>)</span>;</span><br></pre></td></tr></table></figure></li></ul><p>在使用是需要引入 <code>objc/runtime.h</code> 头文件</p><ul><li>函数的作用：<br>objc_setAssociatedObject 用于给对象添加关联对象，传入 nil 则可以移除已有的关联对象；<br>objc_getAssociatedObject 用于获取关联对象；<br>objc_removeAssociatedObjects 用于移除一个对象的所有关联对象。</li><li>key值使用：<br>推荐的方法大体有三种：<br>（1）声明 static char kAssociatedObjectKey; 使用 &amp;kAssociatedObjectKey 作为 key 值;<br>（2）声明 static void *kAssociatedObjectKey = &kAssociatedObjectKey; 使用 kAssociatedObjectKey 作为 key 值；<br>（3）用 selector ，使用 getter 方法的名称作为 key 值。</li></ul><p>我们看到的SDWebInage是使用的 <code>static char kAssociatedObjectKey</code> 这种方法。而 <code>static char</code> 这种声明是C语言的写法，意思是：声明一个局部静态变量。</p><p>附上一个讲的很不错的文章：<a href="http://blog.leichunfeng.com/blog/2015/06/26/objective-c-associated-objects-implementation-principle/" target="_blank" rel="noopener">Objective-C Associated Objects 的实现原理</a></p><h4 id="7-1-2、第二步"><a href="#7-1-2、第二步" class="headerlink" title="7.1.2、第二步"></a>7.1.2、第二步</h4><p>代码片段：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">        dispatch_main_async_safe(^&#123;</span><br><span class="line">            [self <span class="string">sd_setImage:</span>placeholder <span class="string">imageData:</span>nil <span class="string">basedOnClassOrViaCustomSetImageBlock:</span>setImageBlock];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>解析：<br>条件语句判断options选项是否为 <code>SDWebImageDelayPlaceholder</code> 若不是则执行条件语句里的内容。（条件语句中执行的是设置占位符图像，但该选项是延迟占位符加载，所以需要加以判断。）</p><p><code>dispatch_main_async_safe(^{})</code> 宏定义主线程异步安全加载，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> dispatch_main_async_safe</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dispatch_main_async_safe(block) dispatch_queue_async_safe(dispatch_get_main_queue(), block)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> dispatch_queue_async_safe</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dispatch_queue_async_safe(queue, block)\</span></span><br><span class="line">    <span class="keyword">if</span> (dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL) == dispatch_queue_get_label(<span class="built_in">queue</span>)) &#123;\</span><br><span class="line">        block();\</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;\</span><br><span class="line">        dispatch_async(<span class="built_in">queue</span>, block);\</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>dispatch_main_async_safe</code> 安全的分发任务到主线程里面运行<br><code>dispatch_queue_get_label</code> 用来取队列的名字，进而判断如果当前已经是主队列，那么直接执行，否则回调到主队列之后再执行。</p><p>原因是：如果当前队列已经是主队列，那么再调用 <code>dispatch_async(dispatch_get_main_queue(), block)</code>有可能会出现<code>crash</code>。而该方法则很好的做了预防工作。</p><p>下面看条件语句中的执行方法：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)sd_setImage:(<span class="built_in">UIImage</span> *)image imageData:(<span class="built_in">NSData</span> *)imageData basedOnClassOrViaCustomSetImageBlock:(SDSetImageBlock)setImageBlock &#123;</span><br><span class="line"><span class="meta">#if SD_UIKIT || SD_MAC</span></span><br><span class="line">    [<span class="keyword">self</span> sd_setImage:image imageData:imageData basedOnClassOrViaCustomSetImageBlock:setImageBlock transition:<span class="literal">nil</span> cacheType:<span class="number">0</span> imageURL:<span class="literal">nil</span>];</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">    <span class="comment">// watchOS does not support view transition. Simplify the logic</span></span><br><span class="line">    <span class="keyword">if</span> (setImageBlock) &#123;</span><br><span class="line">        setImageBlock(image, imageData);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">self</span> isKindOfClass:[<span class="built_in">UIImageView</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="built_in">UIImageView</span> *imageView = (<span class="built_in">UIImageView</span> *)<span class="keyword">self</span>;</span><br><span class="line">        [imageView setImage:image];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该方法目的为了执行加载占位符图像。分了两种情况 <code>iOS和VTOS 、masOS系统</code> 和 其他。分类型的原因 <code>SDWebImage</code> 给了简单说明： <code>watchOS</code> 不支持 <code>view</code> 的翻转动画，所以 <code>SDWebImage</code> 做了一个简单的加载显示处理。而其他类型则和图像URL的加载显示共用了一套方法（具体实现在加载URL图像时细看）。<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>sd_setImage:<span class="params">(UIImage *)</span>image imageData:<span class="params">(NSData *)</span>imageData basedOnClassOrViaCustomSetImageBlock:<span class="params">(SDSetImageBlock)</span>setImageBlock transition:<span class="params">(SDWebImageTransition *)</span>transition cacheType:<span class="params">(SDImageCacheType)</span>cacheType imageURL:<span class="params">(NSURL *)</span>imageURL</span><br></pre></td></tr></table></figure></p><h4 id="7-1-3、第三步-正式准备加载URL图像"><a href="#7-1-3、第三步-正式准备加载URL图像" class="headerlink" title="7.1.3、第三步 正式准备加载URL图像"></a>7.1.3、第三步 正式准备加载URL图像</h4><p>同样分两种情况，根据所传的 <code>url</code> 是否存在做区分</p><ol><li><strong><code>url</code> 不存在情况</strong><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        dispatch_main_async_safe(^&#123;</span><br><span class="line"><span class="meta">#if SD_UIKIT</span></span><br><span class="line">            [self sd_removeActivityIndicator];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="keyword">if</span> (completedBlock) &#123;</span><br><span class="line">                NSError *<span class="built_in">error</span> = [NSError errorWithDomain:SDWebImageErrorDomain <span class="built_in">code</span>:<span class="number">-1</span> userInfo:<span class="comment">@&#123;NSLocalizedDescriptionKey : @</span><span class="string">"Trying to load a nil url"</span>&#125;];</span><br><span class="line">                completedBlock(nil, <span class="built_in">error</span>, SDImageCacheTypeNone, url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></li></ol><p>分析：<br>首先确保在线程安全的情况下，如果<code>iOS和VTOS系统</code>就做下移除<strong>加载指示器</strong>操作。<br>如果<code>completedBlock</code>代码块存在，就获取错误信息，执行回调内的操作。<br><code>SDExternalCompletionBlock</code> 的声明:<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^<span class="type">SDExternalCompletionBlock</span>)(<span class="type">UIImage</span> * _Nullable image, <span class="type">NSError</span> * _Nullable error, <span class="type">SDImageCacheType</span> cacheType, <span class="type">NSURL</span> * _Nullable imageURL);</span><br></pre></td></tr></table></figure></p><p>下面是url传nil时的情况：<br><img src="http://obzx0h1re.bkt.clouddn.com/SDWebImage_Error.jpg" alt="SDWebImage_Error"></p><ol start="2"><li><strong><code>url</code> 存在情况</strong></li></ol><ul><li>1、如果是<code>iOS和VTOS</code>的系统，则判断使用显示加载指示器，如果显示则创建并添加到View上。<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#if SD_UIKIT</span></span><br><span class="line">        //<span class="built_in"> check </span>if activityView is enabled<span class="built_in"> or </span>not</span><br><span class="line">       <span class="built_in"> if </span>([self sd_showActivityIndicatorView]) &#123;</span><br><span class="line">            [self sd_addActivityIndicator];</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">#endif</span></span><br></pre></td></tr></table></figure></li></ul><p>配置加载指示器：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[self.customImageView sd_setShowActivityIndicatorView:YES]</span><span class="comment">;</span></span><br><span class="line"><span class="section">[self.customImageView sd_setIndicatorStyle:UIActivityIndicatorViewStyleGray]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p><ul><li>2、根据上下文获取 <code>SDWebImageManager</code></li></ul><p>根据上下文（<code>context</code>）获取 <code>SDWebImageManager</code>，没有则创建。<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SDWebImageManager *manager<span class="comment">;</span></span><br><span class="line">if ([<span class="built_in">context</span> valueForKey:SDWebImageExternalCustomManagerKey]) &#123;</span><br><span class="line">    manager = (SDWebImageManager *)[<span class="built_in">context</span> valueForKey:SDWebImageExternalCustomManagerKey]<span class="comment">;</span></span><br><span class="line">&#125; else &#123;</span><br><span class="line">    manager = [SDWebImageManager <span class="keyword">sharedManager];</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure></p><p><code>SDWebImageManager</code>是 <code>SDWebImage</code> 管理以及操作的类。该类是<code>SDWebImage</code>的核心类，拥有一个SDWebImageCache 和 SDWebImageDownloader 属性，分别用于图片缓存和下载处理。</p><p>关于 <code>SDWebImageManager</code> 这里不细说，分出去单独研究。</p><ul><li>3 加载进度回调（或者说加载进度回调中…）</li></ul><p>下载图像时重复调用该代码块，在后台队列上执行。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reset the progress</span></span><br><span class="line"><span class="keyword">self</span>.sd_imageProgress.totalUnitCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">self</span>.sd_imageProgress.completedUnitCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">__<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)wself = <span class="keyword">self</span>;</span><br><span class="line">SDWebImageDownloaderProgressBlock combinedProgressBlock = ^(<span class="built_in">NSInteger</span> receivedSize, <span class="built_in">NSInteger</span> expectedSize, <span class="built_in">NSURL</span> * _Nullable targetURL) &#123;</span><br><span class="line">    wself.sd_imageProgress.totalUnitCount = expectedSize;</span><br><span class="line">    wself.sd_imageProgress.completedUnitCount = receivedSize;</span><br><span class="line">    <span class="keyword">if</span> (progressBlock) &#123;</span><br><span class="line">        progressBlock(receivedSize, expectedSize, targetURL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>代码块中会判断传入的 <code>progressBlock</code> 是否为空，不为空的话执行回调操作，回调方法中开发者可以处理一些其他操作。看下图：</p><p><img src="http://obzx0h1re.bkt.clouddn.com/SDWebImage_progressBlock.jpg" alt="SDWebImage_progressBlock"></p><h4 id="7-1-4、第四步-加载URL图像"><a href="#7-1-4、第四步-加载URL图像" class="headerlink" title="7.1.4、第四步 加载URL图像"></a>7.1.4、第四步 加载URL图像</h4><p>加载图像的代码比较多，接下来就在代码中加注释分析。<br>加载图像的方法是在 <code>SDWebImageManager</code>类中完成的，这里只是执行加载完成后的代码块中的内容。<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(id &lt;SDWebImageOperation&gt;)</span>loadImageWithURL:<span class="params">(nullable NSURL *)</span>url</span><br><span class="line">                                     options:<span class="params">(SDWebImageOptions)</span>options</span><br><span class="line">                                    progress:<span class="params">(nullable SDWebImageDownloaderProgressBlock)</span>progressBlock</span><br><span class="line">                                   completed:<span class="params">(nullable SDInternalCompletionBlock)</span>completedBlock</span><br></pre></td></tr></table></figure></p><p>加载图像的过程先不去考虑，先看加载完成后的代码块中执行的内容：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> &lt;SDWebImageOperation&gt; operation = [manager loadImageWithURL:url options:options progress:combinedProgressBlock completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="built_in">BOOL</span> finished, <span class="built_in">NSURL</span> *imageURL) &#123;</span><br><span class="line">        </span><br><span class="line">    __<span class="keyword">strong</span> __<span class="keyword">typeof</span> (wself) sself = wself; <span class="comment">//代码块中创建强引用</span></span><br><span class="line">    <span class="keyword">if</span> (!sself) &#123; <span class="keyword">return</span>; &#125; <span class="comment">//如果强引用的self不存在，退出block</span></span><br><span class="line"><span class="meta">#if SD_UIKIT</span></span><br><span class="line">    [sself sd_removeActivityIndicator]; <span class="comment">//不是iOS and tvOS系统的话，移除加载指示器</span></span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    <span class="comment">// if the progress not been updated, mark it to complete state （如果进度未更新，请将其标记为完成状态）</span></span><br><span class="line">    <span class="keyword">if</span> (finished &amp;&amp; !error &amp;&amp; sself.sd_imageProgress.totalUnitCount == <span class="number">0</span> &amp;&amp; sself.sd_imageProgress.completedUnitCount == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//如果加载结束、没错误、sd_imageProgress.totalUnitCount 和 sd_imageProgress.completedUnitCount 都为0，则设置两者的值为未知值</span></span><br><span class="line">        sself.sd_imageProgress.totalUnitCount = SDWebImageProgressUnitCountUnknown;</span><br><span class="line">        sself.sd_imageProgress.completedUnitCount = SDWebImageProgressUnitCountUnknown;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   是否应该回调CompletedBlock （ 加载完成 或者 传入的 options 选项 为 SDWebImageAvoidAutoSetImage）</span><br><span class="line">    <span class="built_in">BOOL</span> shouldCallCompletedBlock = finished || (options &amp; SDWebImageAvoidAutoSetImage);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断是否应该不设置Image （如果有图片但设置了SDWebImageAvoidAutoSetImage 或者没有图片并且没有设置SDWebImageDelayPlaceholder）</span></span><br><span class="line">    <span class="built_in">BOOL</span> shouldNotSetImage = ((image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage)) ||</span><br><span class="line">                              (!image &amp;&amp; !(options &amp; SDWebImageDelayPlaceholder)));</span><br><span class="line">                              </span><br><span class="line">    SDWebImageNoParamsBlock callCompletedBlockClojure = ^&#123;</span><br><span class="line">        <span class="comment">//如果view不存在，终止执行</span></span><br><span class="line">        <span class="keyword">if</span> (!sself) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">        </span><br><span class="line">        需要设置Image，就刷新视图</span><br><span class="line">        <span class="keyword">if</span> (!shouldNotSetImage) &#123;</span><br><span class="line">            [sself sd_setNeedsLayout];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果传入了completedBlock并且应该回调，则执行回调</span></span><br><span class="line">        <span class="keyword">if</span> (completedBlock &amp;&amp; shouldCallCompletedBlock) &#123;</span><br><span class="line">        <span class="comment">//回调</span></span><br><span class="line">            completedBlock(image, error, cacheType, url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// case 1a: we got an image, but the SDWebImageAvoidAutoSetImage flag is set （我们得到了一个图像，但设置了SDWebImageAvoidAutoSetImage标志）</span></span><br><span class="line">    <span class="comment">// OR</span></span><br><span class="line">    <span class="comment">// case 1b: we got no image and the SDWebImageDelayPlaceholder is not set（我们没有图像，并且没有设置SDWebImageDelayPlaceholder标志）</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">//如果不需要设置图片就在主线程队列种调用上面生成的完成回调代码块，然后停止执行</span></span><br><span class="line">    <span class="keyword">if</span> (shouldNotSetImage) &#123;</span><br><span class="line">        dispatch_main_async_safe(callCompletedBlockClojure);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化变量</span></span><br><span class="line">    <span class="built_in">UIImage</span> *targetImage = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSData</span> *targetData = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (image) &#123;</span><br><span class="line">        <span class="comment">// case 2a: we got an image and the SDWebImageAvoidAutoSetImage is not set （我们得到了一个图像，并且没有设置SDWebImageAvoidAutoSetImage）</span></span><br><span class="line">        <span class="comment">//如果图片下载成功就将其保存到变量中</span></span><br><span class="line">        targetImage = image;</span><br><span class="line">        targetData = data;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options &amp; SDWebImageDelayPlaceholder) &#123;</span><br><span class="line">        <span class="comment">// case 2b: we got no image and the SDWebImageDelayPlaceholder flag is set（我们没有图像，并且设置了SDWebImage Delay Placeholder标志）</span></span><br><span class="line">        如果图片下载失败并且设置了延迟加载占位符图像，就保存占位符图像</span><br><span class="line">        targetImage = placeholder;</span><br><span class="line">        targetData = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line"><span class="meta">#if SD_UIKIT || SD_MAC （iOS and tvOS macOS）</span></span><br><span class="line">    <span class="comment">// check whether we should use the image transition（检查我们是否应该使用图像过渡转换）</span></span><br><span class="line">    SDWebImageTransition *transition = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">//如果加载结束并且options选项为：SDWebImageForceTransition 或者 缓存类型为：SDImageCacheTypeNone</span></span><br><span class="line">    <span class="keyword">if</span> (finished &amp;&amp; (options &amp; SDWebImageForceTransition || cacheType == SDImageCacheTypeNone)) &#123;</span><br><span class="line">    <span class="comment">//保存图像过渡转换</span></span><br><span class="line">        transition = sself.sd_imageTransition;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">    dispatch_main_async_safe(^&#123;</span><br><span class="line">    <span class="comment">//主线程队列种设置图像</span></span><br><span class="line"><span class="meta">#if SD_UIKIT || SD_MAC （iOS and tvOS macOS）</span></span><br><span class="line">            设置图像</span><br><span class="line">            [sself sd_setImage:targetImage imageData:targetData basedOnClassOrViaCustomSetImageBlock:setImageBlock transition:transition cacheType:cacheType imageURL:imageURL];</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">            <span class="comment">//iWatchOS系统设置图像</span></span><br><span class="line">            [sself sd_setImage:targetImage imageData:targetData basedOnClassOrViaCustomSetImageBlock:setImageBlock];</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">            <span class="comment">//设置完成后调用完成回调代码块</span></span><br><span class="line">            callCompletedBlockClojure();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">//SDOperationsDictionary存储当前的操作。</span></span><br><span class="line">    [<span class="keyword">self</span> sd_setImageLoadOperation:operation forKey:validOperationKey];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面再使用纯描述的方式，过一遍流程：（为了简便，以下：<code>SD_UIKIT || SD_MAC</code> 简称：<code>iOS_tvOS_MAC</code>; <code>SD_MAC</code>简称：<code>MAC</code>  <code>SD_UIKIT</code> 简称 ：<code>iOS_tvOS</code>）</p><p><code>__strong</code>在<code>Block</code>内部修饰的对象,会保证,在使用这个对象在block内,这个对象都不会被释放。</p><p>之前分析过，加载指示器只能在<code>iOS_tvOS</code>的情况下添加，所以加载完成后需要移除。如下：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SD_UIKIT</span></span><br><span class="line">            [<span class="meta">sself sd_removeActivityIndicator</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><p>如果加载已经完成并且没有错误；iamge进度的总单元和完成单元都是0，就设置<code>imageProgress</code> 的总单元和完成单元值为未知。</p><p>创建 “应该执行完成加载的回调” 和 “不应该设置Image” 两个布尔值。<br><code>SDWebImageAvoidAutoSetImage</code>: 在设置图像之前手动处理一些东西（例如应用滤镜或添加交叉渐变动画）请使用此标志<br><code>SDWebImageDelayPlaceholder</code> : 延迟显示占位符图像</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载完成 或者 传入的 options 选项为 SDWebImageAvoidAutoSetImage</span></span><br><span class="line">BOOL shouldCallCompletedBlock = finished <span class="string">|| (options &amp; SDWebImageAvoidAutoSetImage);</span></span><br><span class="line"><span class="comment">//图片存在并且选项为 SDWebImageAvoidAutoSetImage 或者 图片不存在并且选项不为SDWebImageDelayPlaceholder</span></span><br><span class="line">BOOL shouldNotSetImage = ((image <span class="meta">&amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage)) ||</span></span><br><span class="line">                                    (!image <span class="meta">&amp;&amp; !(options &amp; SDWebImageDelayPlaceholder)));</span></span><br></pre></td></tr></table></figure><p><code>SDWebImageNoParamsBlock</code> 回调<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SDWebImageNoParamsBlock callCompletedBlockClojure = ^&#123;</span><br><span class="line">                <span class="keyword">if</span> (!sself) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">                <span class="keyword">if</span> (!shouldNotSetImage) &#123;</span><br><span class="line">                    <span class="comment">//需要设置Image</span></span><br><span class="line">                    [sself sd_setNeedsLayout];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//completedBlock存在并且需要回调</span></span><br><span class="line">                <span class="keyword">if</span> (completedBlock &amp;&amp; shouldCallCompletedBlock) &#123;</span><br><span class="line">                    completedBlock(<span class="keyword">image</span>, <span class="keyword">error</span>, cacheType, url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure></p><p>不需要设置Image，执行callCompletedBlockClojure回调代码<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shouldNotSetImage) &#123;</span><br><span class="line">     dispatch_main_async_safe(callCompletedBlockClojure);</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>图像和图像Data赋值：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UIImage</span> *targetImage = <span class="keyword">nil</span>;</span><br><span class="line"><span class="type">NSData</span> *targetData = <span class="keyword">nil</span>;</span><br><span class="line"><span class="keyword">if</span> (image) &#123;</span><br><span class="line">    // <span class="keyword">case</span> <span class="number">2</span>a: we got an image <span class="keyword">and</span> the <span class="type">SDWebImageAvoidAutoSetImage</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="built_in">set</span></span><br><span class="line">    targetImage = image;</span><br><span class="line">    targetData = data;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (options &amp; <span class="type">SDWebImageDelayPlaceholder</span>) &#123;</span><br><span class="line">    // <span class="keyword">case</span> <span class="number">2</span>b: we got no image <span class="keyword">and</span> the <span class="type">SDWebImageDelayPlaceholder</span> flag <span class="keyword">is</span> <span class="built_in">set</span></span><br><span class="line">    targetImage = placeholder;</span><br><span class="line">    targetData = <span class="keyword">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果系统类型为：<code>iOS_tvOS_MAC</code>，图像过渡动画赋值<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#if SD_UIKIT || SD_MAC</span></span><br><span class="line">    //<span class="built_in"> check </span>whether we should use the image transition</span><br><span class="line">    SDWebImageTransition *transition = nil;</span><br><span class="line">   <span class="built_in"> if </span>(finished &amp;&amp; (options &amp; SDWebImageForceTransition || cacheType == SDImageCacheTypeNone)) &#123;</span><br><span class="line">        transition = sself.sd_imageTransition;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">#endif</span></span><br></pre></td></tr></table></figure></p><p>执行异步安全加载，根据不同的系统执行不同的方法。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">dispatch_main_async_safe(^&#123;</span></span><br><span class="line"><span class="comment">#if SD_UIKIT || SD_MAC</span></span><br><span class="line">                <span class="string">[sself</span> <span class="attr">sd_setImage:targetImage</span> <span class="attr">imageData:targetData</span> <span class="attr">basedOnClassOrViaCustomSetImageBlock:setImageBlock</span> <span class="attr">transition:transition</span> <span class="attr">cacheType:cacheType</span> <span class="attr">imageURL:imageURL];</span></span><br><span class="line"><span class="comment">#else</span></span><br><span class="line">                <span class="string">[sself</span> <span class="attr">sd_setImage:targetImage</span> <span class="attr">imageData:targetData</span> <span class="attr">basedOnClassOrViaCustomSetImageBlock:setImageBlock];</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">                <span class="string">callCompletedBlockClojure();</span></span><br><span class="line">            <span class="string">&#125;);</span></span><br><span class="line">        <span class="string">&#125;];</span></span><br></pre></td></tr></table></figure></p><p>以上就是大体加载图像所展示的流程</p><p>接下来看一下需要动画翻转过渡的代码（可以使用动画过渡的是<code>iOS_tvOS_MAC</code>）<br>其实就是多加了一个转换动画的执行代码。其他的就是UIImageView和UIButton 的图像设置。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#if SD_UIKIT || SD_MAC</span></span><br><span class="line">- (<span class="keyword">void</span>)sd_setImage:(<span class="built_in">UIImage</span> *)image imageData:(<span class="built_in">NSData</span> *)imageData basedOnClassOrViaCustomSetImageBlock:(SDSetImageBlock)setImageBlock transition:(SDWebImageTransition *)transition cacheType:(SDImageCacheType)cacheType imageURL:(<span class="built_in">NSURL</span> *)imageURL &#123;</span><br><span class="line">    <span class="built_in">UIView</span> *view = <span class="keyword">self</span>;</span><br><span class="line">    <span class="comment">//最终的图像设置block</span></span><br><span class="line">    SDSetImageBlock finalSetImageBlock;</span><br><span class="line">    <span class="comment">//若setImageBlock，说明是Button需要自定义图像。</span></span><br><span class="line">    <span class="keyword">if</span> (setImageBlock) &#123;</span><br><span class="line">        finalSetImageBlock = setImageBlock;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([view isKindOfClass:[<span class="built_in">UIImageView</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">    <span class="comment">//若View为ImageView，执行block回调，为imageView赋值</span></span><br><span class="line">        <span class="built_in">UIImageView</span> *imageView = (<span class="built_in">UIImageView</span> *)view;</span><br><span class="line">        finalSetImageBlock = ^(<span class="built_in">UIImage</span> *setImage, <span class="built_in">NSData</span> *setImageData) &#123;</span><br><span class="line">            imageView.image = setImage;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#if SD_UIKIT</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([view isKindOfClass:[<span class="built_in">UIButton</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">     <span class="comment">//若View为button，执行block回调，为button赋值</span></span><br><span class="line">        <span class="built_in">UIButton</span> *button = (<span class="built_in">UIButton</span> *)view;</span><br><span class="line">        finalSetImageBlock = ^(<span class="built_in">UIImage</span> *setImage, <span class="built_in">NSData</span> *setImageData)&#123;</span><br><span class="line">            [button setImage:setImage forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//动画过渡执行代码</span></span><br><span class="line">    <span class="keyword">if</span> (transition) &#123;</span><br><span class="line"><span class="meta">#if SD_UIKIT</span></span><br><span class="line">        [<span class="built_in">UIView</span> transitionWithView:view duration:<span class="number">0</span> options:<span class="number">0</span> animations:^&#123;</span><br><span class="line">            <span class="comment">// 0 duration to let UIKit render placeholder and prepares block</span></span><br><span class="line">            <span class="keyword">if</span> (transition.prepares) &#123;</span><br><span class="line">                transition.prepares(view, image, imageData, cacheType, imageURL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">            [<span class="built_in">UIView</span> transitionWithView:view duration:transition.duration options:transition.animationOptions animations:^&#123;</span><br><span class="line">                <span class="keyword">if</span> (finalSetImageBlock &amp;&amp; !transition.avoidAutoSetImage) &#123;</span><br><span class="line">                    finalSetImageBlock(image, imageData);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (transition.animations) &#123;</span><br><span class="line">                    transition.animations(view, image);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; completion:transition.completion];</span><br><span class="line">        &#125;];</span><br><span class="line"><span class="meta">#elif SD_MAC</span></span><br><span class="line">        [<span class="built_in">NSAnimationContext</span> runAnimationGroup:^(<span class="built_in">NSAnimationContext</span> * _Nonnull prepareContext) &#123;</span><br><span class="line">            <span class="comment">// 0 duration to let AppKit render placeholder and prepares block</span></span><br><span class="line">            prepareContext.duration = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (transition.prepares) &#123;</span><br><span class="line">                transition.prepares(view, image, imageData, cacheType, imageURL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; completionHandler:^&#123;</span><br><span class="line">            [<span class="built_in">NSAnimationContext</span> runAnimationGroup:^(<span class="built_in">NSAnimationContext</span> * _Nonnull context) &#123;</span><br><span class="line">                context.duration = transition.duration;</span><br><span class="line">                context.timingFunction = transition.timingFunction;</span><br><span class="line">                context.allowsImplicitAnimation = (transition.animationOptions &amp; SDWebImageAnimationOptionAllowsImplicitAnimation);</span><br><span class="line">                <span class="keyword">if</span> (finalSetImageBlock &amp;&amp; !transition.avoidAutoSetImage) &#123;</span><br><span class="line">                    finalSetImageBlock(image, imageData);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (transition.animations) &#123;</span><br><span class="line">                    transition.animations(view, image);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; completionHandler:^&#123;</span><br><span class="line">                <span class="keyword">if</span> (transition.completion) &#123;</span><br><span class="line">                    transition.completion(<span class="literal">YES</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;];</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (finalSetImageBlock) &#123;</span><br><span class="line">            finalSetImageBlock(image, imageData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><p>以上就是 <code>SDWebImage</code> 设置图片的整个流程，但只是过了一遍代码而已，内部的实现并没有深入，例如：<code>SDWebImage</code> 的下载、缓存机制。这些都没有深入去了解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SDWebImage整体的框架：&lt;/p&gt;
&lt;figure class=&quot;highlight gherkin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;lin
      
    
    </summary>
    
      <category term="读SDWebImage手札" scheme="http://guohuaden.com/categories/%E8%AF%BBSDWebImage%E6%89%8B%E6%9C%AD/"/>
    
    
      <category term="SDWebImage" scheme="http://guohuaden.com/tags/SDWebImage/"/>
    
  </entry>
  
  <entry>
    <title>copy 和 mutableCopy</title>
    <link href="http://guohuaden.com/2018/06/30/copyAndMutableCopy/"/>
    <id>http://guohuaden.com/2018/06/30/copyAndMutableCopy/</id>
    <published>2018-06-30T06:16:37.000Z</published>
    <updated>2018-10-24T11:01:54.936Z</updated>
    
    <content type="html"><![CDATA[<p>今天来谈下深浅拷贝【copy 和 mutableCopy】</p><p>想写这篇文章，是因为看到了一个有意思的文章，对于其中的一些观点不太认同，所以想简单分析一下深浅拷贝</p><p>先看一段代码，稍后会对代码进行分析</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)testOne</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *test = @[@<span class="number">1</span>,@<span class="number">2</span>,@<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"test-&gt;%p\n"</span>,test);</span><br><span class="line">    <span class="built_in">NSArray</span> *testCopy = [test <span class="keyword">copy</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"testCopy-&gt;%p\n"</span>,testCopy);</span><br><span class="line">    <span class="built_in">NSArray</span> *testMutableCopy = [test mutableCopy];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"testMutableCopy-&gt;%p\n"</span>,testMutableCopy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>很简单的创建一个数组，对其进行copy和mutableCopy操作，打印其内存地址。结果看图会知道：<br>test和testCopy 内存地址是一样的，而testMutableCopy的内存地址是和test不同的。</p><p><strong>小总结：</strong></p><ol><li><code>copy</code> 只是拷贝指向对象的指针，并没有出现新的内存地址，我们称之为<strong>浅拷贝</strong>：</li><li><code>mutableCopy</code> 拷贝整个对象内存到另一块内存中，是产生了新的内存地址。</li></ol><p><img src="http://obzx0h1re.bkt.clouddn.com/copyAndMutableCopy_one.png" alt="copy和mutableCopy操作1"></p><hr><p>再看下面的一段代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)testTwo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"\n"</span>);</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *test2 = [<span class="built_in">NSMutableArray</span> arrayWithObjects:<span class="string">@"1"</span>,<span class="string">@"2"</span>,<span class="string">@"3"</span>, <span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"test2-&gt;%p\n"</span>,test2);</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *testCopy2 = [test2 <span class="keyword">copy</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"testCopy2-&gt;%p\n"</span>,testCopy2);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableArray</span> *testMutableCopy2 = [test2 mutableCopy];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"testMutableCopy2-&gt;%p\n"</span>,testMutableCopy2);</span><br><span class="line">    </span><br><span class="line">    [test2 addObject:<span class="string">@"A"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里不能对数组做操作， 可变数组的copy属于深拷贝，和mutableCopy一样都是将数组拷贝一份存入新的内存中，但通过mutableCopy得到的可变数组可以再操作，而copy出来的是不可变数组。</span></span><br><span class="line"><span class="comment">//    [testCopy2 removeObject:@"1"];</span></span><br><span class="line"><span class="comment">//    [testCopy2 addObject:@"B"]; </span></span><br><span class="line">    </span><br><span class="line">    [testMutableCopy2 addObject:<span class="string">@"C"</span>];</span><br><span class="line">    [testMutableCopy2 removeObject:<span class="string">@"3"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"test2 = %@, testCopy2 =%@,testMutableCopy2 = %@"</span>,test2,testCopy2,testMutableCopy2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//打印结果： test2 = @[1,2,3,A]   testCopy2 = @[1,2,3]   testMutableCopy2 = @[1,2,3,C]</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析：</strong><br>上面这段代码会和之前的不一样，我们这里创建的是一个可变数组，然后对可变数组进行<code>copy</code>和<code>mutableCopy</code>操作。发现打印其内存地址都不一样，<br>这说明对可变数组进行<code>copy</code>和<code>mutableCopy</code>都是深拷贝。<br>但你会发现<code>copy</code>得到的数组不能添加删除操作，这是因为<code>copy</code>得到的是不可变数组。</p><p><strong>小总结：</strong></p><p>可变数组的<code>copy</code>和<code>mutableCopy</code>都是深拷贝</p><p><img src="http://obzx0h1re.bkt.clouddn.com/copyAndMutableCopy_two.png" alt="copy和mutableCopy操作2"></p><p>最后一段代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-(void)testThree</span><br><span class="line">&#123;</span><br><span class="line">    NSMutableArray *test4 = [NSMutableArray arrayWithObjects:<span class="type"></span>@<span class="string">"1"</span>,@<span class="string">"2"</span>,@<span class="string">"3"</span>, nil];</span><br><span class="line">    NSMutableArray *<span class="keyword">new</span><span class="type">Test</span> = [NSMutableArray arrayWithObject:<span class="type">test4</span>];</span><br><span class="line">    NSMutableArray *testMutableCopy4 = [<span class="keyword">new</span><span class="type">Test</span> mutableCopy];<span class="comment">//拷贝出来的是NSMutableArray类型数组</span></span><br><span class="line">    NSLog(@<span class="string">"newTest-&gt;%p,testMutableCopy4-&gt;%p\n"</span>,<span class="keyword">new</span><span class="type">Test</span>,testMutableCopy4);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//copy的先不说， 我们看下mutableCopy得到的数组，你会发现通过mutableCopy得到的数组中的元素地址是不变的</span></span><br><span class="line">    NSLog(@<span class="string">"newTest.first-&gt;%p,testMutableCopy4first-&gt;%p\n"</span>,<span class="keyword">new</span><span class="type">Test</span>.firstObject,testMutableCopy4.firstObject);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//test</span></span><br><span class="line">    [testMutableCopy4.firstObject addObject:<span class="type"></span>@<span class="number">6</span>];</span><br><span class="line">    [<span class="keyword">new</span><span class="type">Test</span>.firstObject addObject:<span class="type"></span>@<span class="string">"12"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//打印出来这里两个数组，会发现结果是一样的，原因就是mutableCopy的深拷贝是容器和其中的元素，但元素的地址并没有改变，修改其中的元素中的内容，结果必然都改变</span></span><br><span class="line">    </span><br><span class="line">    NSLog(@<span class="string">"newTest = %@,testMutableCopy2 = %@"</span>,<span class="keyword">new</span><span class="type">Test</span>,testMutableCopy4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>通过<code>mutableCopy</code>得到的数组，你会发现通过<code>mutableCopy</code>得到的数组中的元素地址是不变的。如果你往数组的元素中添加或删除元素，会发现newTest和testMutableCopy4中的元素都发生了改变。</p><p><strong>小总结：</strong></p><p>集合对象的内容复制（mutableCopy）仅限于对象本身，对象中的元素仍然是指针复制。</p><p><img src="http://obzx0h1re.bkt.clouddn.com/copyAndMutableCopy_four.png" alt="copy和mutableCopy操作4"></p><p>关于这点其实苹果官网文档中<code>CopyFunctions</code>给了解释，看下以下介绍：</p><p><strong>关于复制的介绍：</strong></p><blockquote><p>Copy Functions<br>In general, a standard copy operation, which might also be called simple assignment, occurs when you use the = operator to assign the value of one variable to another. The expression myInt2 = myInt1, for example, causes the integer contents of myInt1 to be copied from the memory used by myInt1 into the memory used by myInt2. Following the copy operation, two separate areas of memory contain the same value. However, if you attempt to copy a Core Foundation object in this way, be aware that you will not duplicate the object itself, only the reference to the object.</p></blockquote><blockquote><p>For example, someone new to Core Foundation might think that to make a copy of a CFString object she would use the expression myCFString2 = myCFString1. Again, this expression does not actually copy the string data. Because both myCFString1 and myCFString2 must have the CFStringRef type, this expression only copies the reference to the object. Following the copy operation, you have two copies of the reference to the CFString. This type of copy is very fast because only the reference is duplicated, but it is important to remember that copying a mutable object in this way is dangerous. As with programs that use global variables, if one part of your application changes an object using a copy of the reference, there is no way for other parts of the program which have copies of that reference to know that the data has changed.</p></blockquote><blockquote><p>If you want to duplicate an object, you must use one of the functions provided by Core Foundation specifically for this purpose. Continuing with the CFString example, you would use CFStringCreateCopy to create an entirely new CFString object containing the same data as the original. Core Foundation types which have “CreateCopy” functions also provide the variant “CreateMutableCopy” which returns a copy of an object that can be modified.</p></blockquote><p><strong>浅拷贝：</strong></p><blockquote><p>Shallow Copy<br>Copying compound objects, objects such as collection objects that can contain other objects, must also be done with care. As you would expect, using the = operator to perform a copy on these objects results in a duplication of the object reference. In contrast to simple objects like CFString and CFData, the “CreateCopy” functions provided for compound objects such as CFArray and CFSet actually perform a shallow copy. In the case of these objects, a shallow copy means that a new collection object is created, but the contents of the original collection are not duplicated—only the object references are copied to the new container. This type of copy is useful if, for example, you have an array that’s immutable and you want to reorder it. In this case, you don’t want to duplicate all of the contained objects because there’s no need to change them—and why use up that extra memory? You just want the set of included objects to be changed. The same risks apply here as with copying object references with simple types.</p></blockquote><p><strong>深拷贝：</strong></p><blockquote><p>Deep Copy<br>When you want to create an entirely new compound object, you must perform a deep copy. A deep copy duplicates the compound object as well as the contents of all of its contained objects. The current release of Core Foundation includes a function that performs deep copying of a property list (see CFPropertyListCreateDeepCopy). If you want to create deep copies of other structures, you could perform the deep copy yourself by recursively descending into the compound object and copying all of its contents one by one. Take care in implementing this functionality as compound objects can be recursive—they may directly or indirectly contain a reference to themselves—which can cause a recursive loop.</p></blockquote><p>引用自：<a href="https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/CopyFunctions.html#//apple_ref/doc/uid/20001149-CJBEJBHH" target="_blank" rel="noopener">苹果官网文档-CopyFunctions</a></p><p><strong>小总结：</strong></p><p>我们通过对集合类对象进行mutableCopy得到的新对象，从某种意义上来说，并不是真正的深层次的复制，严格意义上说：它只是一个单层次的深复制。原因上面已说明：集合对象的内容复制（mutableCopy）仅限于对象本身，对象中的元素仍然是指针复制。</p><p>那如果需要深层次的复制，就需要以递归的形式找到集合中的元素对象，再对元素对象进行mutableCopy，以此来实现深层次的复制。但Apple并不提倡这种方式，因为这可能会导致递归循环。</p><p>最后总结：</p><ol><li>不管是集合类对象还是非集合类对象，copy和mutableCopy时，都遵循以下准则：<ol><li>copy得到的都是不可变对象（imutable），所以对其copy返回的对象做可变对象的操作，都会崩溃。</li><li>mutableCopy返回的是可变对象（mutable）</li></ol></li><li>在非集合类对象中：<ol><li>对不可变对象进行copy操作，是指针复制，其内存地址不变。</li><li>对不可变对象进行mutableCopy操作，是内容复制，其内存地址改变。</li><li>对可变对象进行copy和mutableCopy操作，都是内容复制，其内存地址改变。</li></ol></li><li>在集合类对象中：<ol><li>对不可变对象进行copy操作，是指针复制，其内存地址不变。</li><li>对不可变对象进行mutableCopy操作，是内容复制，其内存地址改变。</li><li>对可变对象进行copy和mutableCopy操作，都是内容复制，其内存地址改变。但集合对象的内容复制仅限于对象本身，对象中的元素仍然是指针复制。</li></ol></li></ol><p>最后可以看下这个Apple的官方文档《<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Collections/Articles/Copying.html#//apple_ref/doc/uid/TP40010162-SW1" target="_blank" rel="noopener">苹果官网文档-Copying</a>》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天来谈下深浅拷贝【copy 和 mutableCopy】&lt;/p&gt;
&lt;p&gt;想写这篇文章，是因为看到了一个有意思的文章，对于其中的一些观点不太认同，所以想简单分析一下深浅拷贝&lt;/p&gt;
&lt;p&gt;先看一段代码，稍后会对代码进行分析&lt;/p&gt;
&lt;figure class=&quot;highli
      
    
    </summary>
    
      <category term="iOS" scheme="http://guohuaden.com/categories/iOS/"/>
    
    
      <category term="copy, mutableCopy" scheme="http://guohuaden.com/tags/copy-mutableCopy/"/>
    
  </entry>
  
  <entry>
    <title>项目总结四</title>
    <link href="http://guohuaden.com/2018/06/03/Project-summary-Four/"/>
    <id>http://guohuaden.com/2018/06/03/Project-summary-Four/</id>
    <published>2018-06-03T04:01:57.000Z</published>
    <updated>2018-10-24T11:03:47.552Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>最近都一直在忙新项目的事，真是倍感身心疲别啊。目前项目终于成型，也算时间宽松渐缓吧，就把项目中遇到的一些问题做个总结。</p><h4 id="1、textField限制输入的位数以及小数点的位数"><a href="#1、textField限制输入的位数以及小数点的位数" class="headerlink" title="1、textField限制输入的位数以及小数点的位数"></a>1、textField限制输入的位数以及小数点的位数</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)textField:(<span class="built_in">UITextField</span> *)textField shouldChangeCharactersInRange:(<span class="built_in">NSRange</span>)range replacementString:(<span class="built_in">NSString</span> *)string;</span><br><span class="line">&#123; </span><br><span class="line"> <span class="comment">//string就是此时输入的那个字符textField就是此时正在输入的那个输入框返回YES就是可以改变输入框的值NO相反</span></span><br><span class="line">    <span class="built_in">NSString</span> * toBeString = [textField.text     stringByReplacingCharactersInRange:range withString:string]; </span><br><span class="line">    <span class="comment">// 判断是否输入内容，或者用户点击的是键盘的删除按钮</span></span><br><span class="line">    <span class="keyword">if</span> (![string isEqualToString:<span class="string">@""</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([textField isEqual:<span class="keyword">self</span>.textField]) &#123;</span><br><span class="line">            <span class="comment">// 小数点在字符串中的位置 第一个数字从0位置开始</span></span><br><span class="line">            <span class="built_in">NSInteger</span> dotLocation = [textField.text rangeOfString:<span class="string">@"."</span>].location;</span><br><span class="line">            <span class="keyword">if</span> (dotLocation == <span class="built_in">NSNotFound</span> &amp;&amp; range.location != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//没有小数点,最大数值</span></span><br><span class="line">                <span class="keyword">if</span> (range.location &gt;= <span class="number">9</span>)&#123;</span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@"单笔金额不能超过亿位"</span>);</span><br><span class="line">                    <span class="keyword">if</span> ([string isEqualToString:<span class="string">@"."</span>] &amp;&amp; range.location == <span class="number">9</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断输入多个小数点,禁止输入多个小数点</span></span><br><span class="line">            <span class="keyword">if</span> (dotLocation != <span class="built_in">NSNotFound</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> ([string isEqualToString:<span class="string">@"."</span>])<span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断小数点后最多两位</span></span><br><span class="line">            <span class="keyword">if</span> (dotLocation != <span class="built_in">NSNotFound</span> &amp;&amp; range.location &gt; dotLocation + <span class="number">2</span>) &#123; <span class="keyword">return</span> <span class="literal">NO</span>; &#125;</span><br><span class="line">            <span class="comment">//判断总长度</span></span><br><span class="line">            <span class="keyword">if</span> (textField.text.length &gt; <span class="number">11</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、禁用第三方键盘"><a href="#2、禁用第三方键盘" class="headerlink" title="2、禁用第三方键盘"></a>2、禁用第三方键盘</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application shouldAllowExtensionPointIdentifier:(<span class="built_in">NSString</span> *)extensionPointIdentifier</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、延迟执行"><a href="#3、延迟执行" class="headerlink" title="3、延迟执行"></a>3、延迟执行</h4><p>取消延迟执行函<code>cancelPreviousPerformRequestsWithTarget</code></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">延迟执行函数</span><br><span class="line">[self <span class="string">performSelector:</span><span class="meta">@selector</span>(scrollDone) <span class="string">withObject:</span>nil <span class="string">afterDelay:</span><span class="number">0.5</span>];</span><br><span class="line"></span><br><span class="line">在<span class="number">0.5</span>秒内取消执行函数，带的参数必须一样，才能取消成功</span><br><span class="line">[NSObject <span class="string">cancelPreviousPerformRequestsWithTarget:</span>self <span class="string">selector:</span><span class="meta">@selector</span>(scrollDone) <span class="string">object:</span>nil];</span><br></pre></td></tr></table></figure><h4 id="4、关于浮点数精度问题"><a href="#4、关于浮点数精度问题" class="headerlink" title="4、关于浮点数精度问题"></a>4、关于浮点数精度问题</h4><p>大部分开发是不需要关心浮点数精度问题，但在股票等软件开发中，浮点数精度问题会显得很重要，这时就需要用到十进制数字类<code>NSDecimalNumber</code>，这个类继承自NSNumber，苹果针对浮点类型计算精度问题提供出来的计算类，基于十进制的科学计数法来计算，同时可以指定舍入模式，一般用于货币计算。</p><h4 id="5、判断是否为单页-是就执行js"><a href="#5、判断是否为单页-是就执行js" class="headerlink" title="5、判断是否为单页,是就执行js"></a>5、判断是否为单页,是就执行js</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *jsStr=<span class="string">@"if(window.historyBack)historyBack();else window.inject.finish();"</span>;</span><br><span class="line">[_webView evaluateJavaScript:jsStr completionHandler:^(<span class="keyword">id</span> _Nullable response, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"No error"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        [<span class="keyword">super</span> leftAction];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><hr><p><strong>注</strong>：先写到这里，其他以后补充。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h3&gt;&lt;p&gt;最近都一直在忙新项目的事，真是倍感身心疲别啊。目前项目终于成型，也算时间宽松渐缓吧，就把项目中遇到的一些问题做个总结。&lt;/p&gt;
&lt;h
      
    
    </summary>
    
      <category term="项目总结" scheme="http://guohuaden.com/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="iOS" scheme="http://guohuaden.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS之项目总结三：项目开发中遇到的一些问题及解决方案</title>
    <link href="http://guohuaden.com/2017/10/05/project-summary-Three/"/>
    <id>http://guohuaden.com/2017/10/05/project-summary-Three/</id>
    <published>2017-10-05T03:19:10.000Z</published>
    <updated>2018-10-24T11:04:06.739Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>两年多以来，基本上都是独立开发或者维护项目，不得不自嘲的说挺锻炼人的。最近的一家公司是涉足金融行列的，算是第一次踏足金融吧，过程怎样不说，确实学到了不少东西。</p><p><strong><em>下面就开发第一款金融类项目遇到的问题做一下总结：</em></strong></p><h4 id="1、中文显示标题之类"><a href="#1、中文显示标题之类" class="headerlink" title="1、中文显示标题之类"></a>1、中文显示标题之类</h4><p>我们在项目中调用相册、相机等往往默认的是显示英文，但有时候开发的项目是针对国内的，所以需要中文配合显示，这就需要我们做一下配置。<br>其实很简单：就是在<code>info.plist</code>中允许应用程序获取框架内语言即可。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Localizedresources can be mixed  YES</span><br><span class="line">Localization <span class="keyword">native</span> development region  China <span class="comment">//en</span></span><br></pre></td></tr></table></figure><p>图片显示：</p><p><img src="http://obzx0h1re.bkt.clouddn.com/project_summary_lauguageSet.png" alt="允许应用程序获取框架内语言图片"></p><h4 id="2、运行报错问题"><a href="#2、运行报错问题" class="headerlink" title="2、运行报错问题"></a>2、运行报错问题</h4><p>报错信息：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld: <span class="number">4</span> duplicate symbols <span class="keyword">for</span> architecture arm64 clang: error: linker command failed with <span class="keyword">exit</span></span><br></pre></td></tr></table></figure><p>这个是粗心大意而差生的报错，最可能的情况是：引入【.h】文件重复。<br>我们知道iOS不允许在A类中重复引入相同的B类的，使用<code>improt</code>关键字引入头文件时，它会判断是否已经引入，如果引入了一次就不在引入。但并不能直接提示报错，所以在运行时会提示上面的报错信息。所以首先要做的是排查是否重复引入【.h】文件。</p><h4 id="3、在使用jsonModel做项目的数据解析时，出现一个属性名字不确定是否存在的情况"><a href="#3、在使用jsonModel做项目的数据解析时，出现一个属性名字不确定是否存在的情况" class="headerlink" title="3、在使用jsonModel做项目的数据解析时，出现一个属性名字不确定是否存在的情况"></a>3、在使用jsonModel做项目的数据解析时，出现一个属性名字不确定是否存在的情况</h4><p>这个问题是没有技术含量的，遇到了解决就行，方法如下：<br>在【.m】文件中添加下面的方法即可</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+(<span class="built_in">BOOL</span>)propertyIsOptional:(<span class="built_in">NSString</span>*)propertyName</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、AES加密遇到的和android统一加密模式问题"><a href="#4、AES加密遇到的和android统一加密模式问题" class="headerlink" title="4、AES加密遇到的和android统一加密模式问题"></a>4、AES加密遇到的和<em>android</em>统一加密模式问题</h4><p>这种情况我以前在《<a href="http://guohuaden.com/2016/10/06/DES-encryption/">Base64加密和DES加密、以及JAVA和iOS中DES加密统一性问题</a>》这篇文章中有提到多，主要是iOS这边SDK中只提供了两种模式：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@constant   kCCOptionPKCS7Padding   Perform PKCS7 padding.</span><br><span class="line">@constant   kCCOptionECBMode        Electronic Code Book Mode.</span><br><span class="line">                                    Default is CBC.</span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    / options <span class="keyword">for</span> block ciphers /</span><br><span class="line">    kCCOptionPKCS7Padding   = <span class="number">0x0001</span>,</span><br><span class="line">    kCCOptionECBMode        = <span class="number">0x0002</span></span><br><span class="line">    / stream ciphers currently have no options /</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但安卓的不一样，有十几种左右，所以在开发中一定要和安卓、服务器端做好统一。</p><ol><li>如果使用CBC模式，那直接用：<code>kCCOptionPKCS7Padding</code>即可。</li><li>但如果是ECB模式，就需要做下转变 <code>kCCOptionECBMode | kCCOptionPKCS7Padding</code></li></ol><h4 id="5、服务器端小数显示问题（如：1e-05）"><a href="#5、服务器端小数显示问题（如：1e-05）" class="headerlink" title="5、服务器端小数显示问题（如：1e-05）"></a>5、服务器端小数显示问题（如：1e-05）</h4><p>这个做下处理即可：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDecimalNumber</span> *decNumber = [<span class="built_in">NSDecimalNumber</span> decimalNumberWithString:leastWaveStr];</span><br><span class="line"><span class="built_in">NSString</span> *numberStr = [decNumber stringValue];</span><br></pre></td></tr></table></figure><p>金融类项目中常用到这个<code>NSDecimalNumber</code> ,用于货币处理 。<br>通过<code>NSDecimalNumber</code>提供的计算方式，可以很好的计算出准确的精度的数据，同时不需要使用格式化输出等。</p><h4 id="6、自定义导航栏按钮不靠左／右问题"><a href="#6、自定义导航栏按钮不靠左／右问题" class="headerlink" title="6、自定义导航栏按钮不靠左／右问题"></a>6、自定义导航栏按钮不靠左／右问题</h4><p>很简单，解决方法，添加一个空的按钮进去</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIButton</span> *leftButton = [[<span class="built_in">UIButton</span> alloc]init];</span><br><span class="line">leftButton.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line">[leftButton setBackgroundImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"back.png"</span>] forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">[leftButton addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(popToLastVC:) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line"><span class="built_in">UIBarButtonItem</span> *leftBarButtonItems = [[<span class="built_in">UIBarButtonItem</span> alloc]initWithCustomView:leftButton];</span><br><span class="line"><span class="comment">//解决按钮不靠左 靠右的问题.</span></span><br><span class="line"><span class="built_in">UIBarButtonItem</span> *nagetiveSpacer = [[<span class="built_in">UIBarButtonItemalloc</span>]initWithBarButtonSystemItem:<span class="built_in">UIBarButtonSystemItemFixedSpace</span></span><br><span class="line">target:<span class="literal">nil</span> action:<span class="literal">nil</span>];</span><br><span class="line">nagetiveSpacer.width = <span class="number">-15</span>;<span class="comment">//这个值可以根据自己需要自己调整</span></span><br><span class="line"><span class="keyword">self</span>.navigationItem.leftBarButtonItems = @[nagetiveSpacer, leftBarButtonItems];</span><br></pre></td></tr></table></figure><h4 id="7、不同屏幕尺寸字体显示字体大小问题"><a href="#7、不同屏幕尺寸字体显示字体大小问题" class="headerlink" title="7、不同屏幕尺寸字体显示字体大小问题"></a>7、不同屏幕尺寸字体显示字体大小问题</h4><p>我们应该清楚，UI设计图大多数是以iPhone6 为模版设计的，但开发中腰考虑不同的屏幕尺寸显示字体大小不同的情况。<br>网上给出的大多数是针对<code>Xib</code>和<code>storyboard</code>做的处理，下面我说一下针对纯代码开发的处理方法。<br>其实很简单，在pch文件中设置宏定义，针对不同的机型做一下简单判断，在开发中使用宏定义字体大小就可以了。<br>例如：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">kDevice_Is_iPhone4</span> ([UIScreen <span class="attribute">instancesRespondToSelector</span>:<span class="variable">@selector</span>(currentMode)] ? CGSizeEqualToSize(CGSizeMake(<span class="number">640</span>, <span class="number">960</span>), [[UIScreen mainScreen] currentMode].size) : NO)</span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">kDevice_Is_iPhone5</span> ([UIScreen <span class="attribute">instancesRespondToSelector</span>:<span class="variable">@selector</span>(currentMode)] ? CGSizeEqualToSize(CGSizeMake(<span class="number">640</span>, <span class="number">1136</span>), [[UIScreen mainScreen] currentMode].size) : NO)</span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">kDevice_Is_iPhone6</span> ([UIScreen <span class="attribute">instancesRespondToSelector</span>:<span class="variable">@selector</span>(currentMode)] ? CGSizeEqualToSize(CGSizeMake(<span class="number">750</span>, <span class="number">1334</span>), [[UIScreen mainScreen] currentMode].size) : NO)</span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">kDevice_Is_iPhone6Plus</span> ([UIScreen <span class="attribute">instancesRespondToSelector</span>:<span class="variable">@selector</span>(currentMode)] ? CGSizeEqualToSize(CGSizeMake(<span class="number">1242</span>, <span class="number">2208</span>), [[UIScreen mainScreen] currentMode].size) : NO)</span><br><span class="line"><span class="comment">//字体大小（以6s为基准,以6p为判断）</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">kFontSize10</span>  <span class="selector-tag">kDevice_Is_iPhone6Plus</span> ? <span class="selector-tag">12</span><span class="selector-pseudo">:10</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">kFontSize11</span>  <span class="selector-tag">kDevice_Is_iPhone6Plus</span> ? <span class="selector-tag">13</span><span class="selector-pseudo">:11</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">kFontSize12</span>  <span class="selector-tag">kDevice_Is_iPhone6Plus</span> ? <span class="selector-tag">14</span><span class="selector-pseudo">:12</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">kFontSize13</span>  <span class="selector-tag">kDevice_Is_iPhone6Plus</span> ? <span class="selector-tag">15</span><span class="selector-pseudo">:13</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">kFontSize14</span>  <span class="selector-tag">kDevice_Is_iPhone6Plus</span> ? <span class="selector-tag">16</span><span class="selector-pseudo">:14</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">kFontSize15</span>  <span class="selector-tag">kDevice_Is_iPhone6Plus</span> ? <span class="selector-tag">17</span><span class="selector-pseudo">:15</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">kFontSize16</span>  <span class="selector-tag">kDevice_Is_iPhone6Plus</span> ? <span class="selector-tag">18</span><span class="selector-pseudo">:16</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">kFontSize17</span>  <span class="selector-tag">kDevice_Is_iPhone6Plus</span> ? <span class="selector-tag">19</span><span class="selector-pseudo">:17</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">kFontSize18</span>  <span class="selector-tag">kDevice_Is_iPhone6Plus</span> ? <span class="selector-tag">20</span><span class="selector-pseudo">:18</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">kFontSize19</span>  <span class="selector-tag">kDevice_Is_iPhone6Plus</span> ? <span class="selector-tag">21</span><span class="selector-pseudo">:19</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">kFontSize20</span>  <span class="selector-tag">kDevice_Is_iPhone6Plus</span> ? <span class="selector-tag">22</span><span class="selector-pseudo">:20</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">kFontSize21</span>  <span class="selector-tag">kDevice_Is_iPhone6Plus</span> ? <span class="selector-tag">23</span><span class="selector-pseudo">:21</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">kFontSize22</span>  <span class="selector-tag">kDevice_Is_iPhone6Plus</span> ? <span class="selector-tag">24</span><span class="selector-pseudo">:22</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">kFontSize23</span>  <span class="selector-tag">kDevice_Is_iPhone6Plus</span> ? <span class="selector-tag">25</span><span class="selector-pseudo">:23</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">kFontSize24</span>  <span class="selector-tag">kDevice_Is_iPhone6Plus</span> ? <span class="selector-tag">26</span><span class="selector-pseudo">:24</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">kFontSize25</span>  <span class="selector-tag">kDevice_Is_iPhone6Plus</span> ? <span class="selector-tag">27</span><span class="selector-pseudo">:25</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">kFontSize34</span>  <span class="selector-tag">kDevice_Is_iPhone6Plus</span> ? <span class="selector-tag">35</span><span class="selector-pseudo">:34</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">kFontSize36</span>  <span class="selector-tag">kDevice_Is_iPhone6Plus</span> ? <span class="selector-tag">38</span><span class="selector-pseudo">:36</span></span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UILabel *<span class="keyword">label</span><span class="bash"> = [UILabel new];</span></span><br><span class="line"><span class="bash">label.text = @<span class="string">""</span>;</span></span><br><span class="line"><span class="bash">label.textColor = [UIColor darkGrayColor];</span></span><br><span class="line"><span class="bash">label.textAlignment = NSTextAlignmentCenter;</span></span><br><span class="line"><span class="bash">label.font = [UIFont systemFontOfSize:kFontSize16];</span></span><br><span class="line"><span class="bash">[self addSubview:label];</span></span><br></pre></td></tr></table></figure><p>这样就不需要每次使用字体都判断不同屏幕尺寸了。</p><h4 id="8、view上有tableView，view添加手势后与tableView手势冲突问题"><a href="#8、view上有tableView，view添加手势后与tableView手势冲突问题" class="headerlink" title="8、view上有tableView，view添加手势后与tableView手势冲突问题"></a>8、view上有tableView，view添加手势后与tableView手势冲突问题</h4><p> 解决这个问题，我们需要利用系统的方法做个判断：如果点击了tableView，就不接收Touch点击事件。</p> <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="built_in">BOOL</span>)gestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer shouldReceiveTouch:(<span class="built_in">UITouch</span> *)touch &#123;</span><br><span class="line">    <span class="comment">// 点击的view的类名</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromClass</span>([touch.view <span class="keyword">class</span>]));</span><br><span class="line">    <span class="comment">// 点击了tableViewCell，view的类名为UITableViewCellContentView，则不接收Touch点击事件</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">NSStringFromClass</span>([touch.view <span class="keyword">class</span>]) isEqualToString:<span class="string">@"UITableViewCellContentView"</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法用来执行点击View的操作：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark - UIGestureRecognizerDelegate methods</span></span><br><span class="line">-(<span class="keyword">void</span>)viewtapClicked:(<span class="built_in">UITapGestureRecognizer</span> *)tap</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGPoint</span> point = [tap locationInView:<span class="keyword">self</span>];</span><br><span class="line">    <span class="built_in">BOOL</span> isTouch = <span class="built_in">CGRectContainsPoint</span>(<span class="keyword">self</span>.baseView.frame, point);</span><br><span class="line">    <span class="keyword">if</span> (isTouch) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"点击tableView"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        [<span class="built_in">UIView</span> animateWithDuration:<span class="number">1.0</span> animations:^&#123;</span><br><span class="line">            [<span class="keyword">self</span> removeFromSuperview];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9、断网重连后更新界面"><a href="#9、断网重连后更新界面" class="headerlink" title="9、断网重连后更新界面"></a>9、断网重连后更新界面</h4><p>我们在开发项目中，网络状态的监听基本设置在<code>appDelegate</code>中。所以需要在这里针对网络状态做一个广播通知，在需要网络重连后更新界面的地方注册该广播进行界面的刷新</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册网络监控通知</span></span><br><span class="line"><span class="selector-attr">[[NSNotificationCenter defaultCenter]</span> <span class="selector-tag">addObserver</span><span class="selector-pseudo">:self</span> <span class="selector-tag">selector</span>:@<span class="selector-tag">selector</span>(<span class="attribute">notificationHandler</span>:) <span class="selector-tag">name</span><span class="selector-pseudo">:kIsNetWork</span> <span class="selector-tag">object</span><span class="selector-pseudo">:nil</span>];</span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">notificationHandler</span><span class="selector-pseudo">:(NSNotification</span> *) <span class="selector-tag">notification</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="selector-tag">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="selector-attr">[self requestHomeInfoData]</span>;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h3&gt;&lt;p&gt;两年多以来，基本上都是独立开发或者维护项目，不得不自嘲的说挺锻炼人的。最近的一家公司是涉足金融行列的，算是第一次踏足金融吧，过程怎样
      
    
    </summary>
    
      <category term="项目总结" scheme="http://guohuaden.com/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="iOS" scheme="http://guohuaden.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>WKWebView使用遇到的问题</title>
    <link href="http://guohuaden.com/2017/10/03/WKWebView-issue/"/>
    <id>http://guohuaden.com/2017/10/03/WKWebView-issue/</id>
    <published>2017-10-03T02:30:40.000Z</published>
    <updated>2018-10-24T11:06:00.688Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p><code>WKWebView</code>在iOS8之后正式替代<code>UIWebView</code>，速度方面确实提升了不少。关于<code>WKWebView</code>的简单使用，在《<a href="http://guohuaden.com/2017/02/11/WKWebView/">聊一聊WKWebView</a>》中我已经介绍过了，这里就不再絮叨，本篇主要记录s三个开发中遇到的问题。</p><h4 id="1、去缓存问题"><a href="#1、去缓存问题" class="headerlink" title="1、去缓存问题"></a>1、去缓存问题</h4><p>我们在第一次打开webView后，移动端为了使用的便捷，会在本地做一个缓存，服务器端也有类似的缓存。但有时服务器端更改信息或者web端更改界面信息。我们往往打开移动端的webView界面，仍然是原来的界面状态，这就是缓存机制造成的现象。<br>解决方法：如果不考虑流量，则需要在请求时忽略本地和远程的缓存即可,使用<code>NSURLRequestReloadIgnoringLocalAndRemoteCacheData</code></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSURLRequest *request = [[NSURLRequest alloc]<span class="string">initWithURL:</span>[NSURL <span class="string">URLWithString:</span>url] <span class="string">cachePolicy:</span>NSURLRequestReloadIgnoringLocalAndRemoteCacheData <span class="string">timeoutInterval:</span><span class="number">20</span>];</span><br><span class="line">[self.webView <span class="string">loadRequest:</span>request];</span><br></pre></td></tr></table></figure><p>这里附上iOS提供的请求缓存类型:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, <span class="built_in">NSURLRequestCachePolicy</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSURLRequestUseProtocolCachePolicy</span> = <span class="number">0</span>,</span><br><span class="line">    <span class="built_in">NSURLRequestReloadIgnoringLocalCacheData</span> = <span class="number">1</span>,</span><br><span class="line">    <span class="built_in">NSURLRequestReloadIgnoringLocalAndRemoteCacheData</span> = <span class="number">4</span>, <span class="comment">// Unimplemented</span></span><br><span class="line">    <span class="built_in">NSURLRequestReloadIgnoringCacheData</span> = <span class="built_in">NSURLRequestReloadIgnoringLocalCacheData</span>,</span><br><span class="line">    <span class="built_in">NSURLRequestReturnCacheDataElseLoad</span> = <span class="number">2</span>,</span><br><span class="line">    <span class="built_in">NSURLRequestReturnCacheDataDontLoad</span> = <span class="number">3</span>,</span><br><span class="line">    <span class="built_in">NSURLRequestReloadRevalidatingCacheData</span> = <span class="number">5</span>, <span class="comment">// Unimplemented</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也可以看看这篇文章：《<a href="http://www.cnblogs.com/lolDragon/p/6774509.html" target="_blank" rel="noopener">iOS webview加载时序和缓存问题总结</a>》</p><h4 id="2、拦截WKWebView中界面的URL，自己进行处理跳转（例如跳转到appstore、支付宝等）"><a href="#2、拦截WKWebView中界面的URL，自己进行处理跳转（例如跳转到appstore、支付宝等）" class="headerlink" title="2、拦截WKWebView中界面的URL，自己进行处理跳转（例如跳转到appstore、支付宝等）"></a>2、拦截WKWebView中界面的URL，自己进行处理跳转（例如跳转到appstore、支付宝等）</h4><p>如果在<code>webView</code>界面中有跳转<code>appstore</code>、支付宝等调手机中app的点击按钮时，如果iOS端不做处理的话，是调不起来手机中的app的。<br>我们需要做的就是在代理方法中截取<code>webView</code>的<code>url</code>，再使用iOS的代码进行跳转。<br>例如打开<code>appstore</code></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView decidePolicyForNavigationAction:(<span class="built_in">WKNavigationAction</span> *)navigationAction decisionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">WKNavigationActionPolicy</span>))decisionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *url = navigationAction.request.URL;</span><br><span class="line">    <span class="built_in">UIApplication</span> *app = [<span class="built_in">UIApplication</span> sharedApplication];</span><br><span class="line">    <span class="comment">// 打开appstore</span></span><br><span class="line">    <span class="keyword">if</span> ([url.absoluteString containsString:<span class="string">@"https://itunes.apple.com/"</span>])&#123;</span><br><span class="line">        <span class="keyword">if</span> ([app canOpenURL:url])&#123;</span><br><span class="line">            [[<span class="built_in">UIApplication</span> sharedApplication] openURL:url];</span><br><span class="line">            decisionHandler(<span class="built_in">WKNavigationActionPolicyCancel</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    decisionHandler(<span class="built_in">WKNavigationActionPolicyAllow</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、在WKWebView中点击事件需要上传cookie中的数据，但cookie数据有问题"><a href="#4、在WKWebView中点击事件需要上传cookie中的数据，但cookie数据有问题" class="headerlink" title="4、在WKWebView中点击事件需要上传cookie中的数据，但cookie数据有问题"></a>4、在WKWebView中点击事件需要上传cookie中的数据，但cookie数据有问题</h4><p>开发中发现，在WKWebView中点击获取验证码等失败（抓包工具查看，发现需要和请求一块上传cookie中的数据，实际并没有上传或者数据丢失一部分）</p><p>在WKWebView中，cookie的是需要我们自己去设置的，这一点和UIWebView不同。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)setUIWebviewcookie&#123;</span><br><span class="line">    <span class="built_in">NSHTTPCookieStorage</span> *cs = [<span class="built_in">NSHTTPCookieStorage</span> sharedHTTPCookieStorage];</span><br><span class="line">    [cs setCookieAcceptPolicy:<span class="built_in">NSHTTPCookieAcceptPolicyAlways</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在webView响应请求的代理方法中，查看cookie</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView decidePolicyForNavigationResponse:(<span class="built_in">WKNavigationResponse</span> *)navigationResponse decisionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">WKNavigationResponsePolicy</span>))decisionHandler&#123;</span><br><span class="line">    <span class="built_in">NSHTTPURLResponse</span> *response = (<span class="built_in">NSHTTPURLResponse</span> *)navigationResponse.response;</span><br><span class="line">    <span class="built_in">NSArray</span> *cookies =[<span class="built_in">NSHTTPCookie</span> cookiesWithResponseHeaderFields:[response allHeaderFields] forURL:response.URL];</span><br><span class="line">    <span class="comment">//读取wkwebview中的cookie 方法1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSHTTPCookie</span> *cookie <span class="keyword">in</span> cookies) &#123;</span><br><span class="line">        <span class="comment">//[[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookie:cookie];</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"wkwebview中的cookie:%@"</span>, cookie);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读取wkwebview中的cookie 方法2 读取Set-Cookie字段</span></span><br><span class="line">    <span class="built_in">NSString</span> *cookieString = [[response allHeaderFields] valueForKey:<span class="string">@"Set-Cookie"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"wkwebview中的cookie:%@"</span>, cookieString);</span><br><span class="line">    <span class="comment">//看看存入到了NSHTTPCookieStorage了没有</span></span><br><span class="line">    <span class="built_in">NSHTTPCookieStorage</span> *cookieJar2 = [<span class="built_in">NSHTTPCookieStorage</span> sharedHTTPCookieStorage];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSHTTPCookie</span> *cookie <span class="keyword">in</span> cookieJar2.cookies) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"NSHTTPCookieStorage中的cookie%@"</span>, cookie);</span><br><span class="line">    &#125;</span><br><span class="line">    decisionHandler(<span class="built_in">WKNavigationResponsePolicyAllow</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h3&gt;&lt;p&gt;&lt;code&gt;WKWebView&lt;/code&gt;在iOS8之后正式替代&lt;code&gt;UIWebView&lt;/code&gt;，速度方面确实提升了不
      
    
    </summary>
    
      <category term="iOS" scheme="http://guohuaden.com/categories/iOS/"/>
    
    
      <category term="WKWebView" scheme="http://guohuaden.com/tags/WKWebView/"/>
    
  </entry>
  
  <entry>
    <title>一个自定义的搜索框：GH_SearchView</title>
    <link href="http://guohuaden.com/2017/05/20/GH-SearchView/"/>
    <id>http://guohuaden.com/2017/05/20/GH-SearchView/</id>
    <published>2017-05-20T05:46:13.000Z</published>
    <updated>2018-10-24T11:02:49.318Z</updated>
    
    <content type="html"><![CDATA[<p>对于iOS自带的搜索框，其实我用着也挺好的，但低版本的使用：  高版本的使用:UISearchController，两个难有个统一。很多项目中都是将着两套代码都写入项目中去，这样做难免显得代码冗余。所以就简单的自定义个搜索框。</p><p><a href="https://github.com/Wheat-Qin/GH_SearchView" target="_blank" rel="noopener">下载地址：https://github.com/Wheat-Qin/GH_SearchView  【支持pods】</a></p><p>怎样使用<code>&#39;GH_SearchView&#39;:</code></p><p>安装CocoaPods：<code>pod &#39;GH_SearchView&#39;</code></p><p>手动倒入：<br>拖动<code>GH_SearchView</code>文件夹中的所有文件到工程项目中</p><p>引入主要文件：<code>#import &quot;GH_SearchView.h&quot;</code></p><p>使用时实现起来也很简单，一句代码创建：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GH_SearchView *searchView_1 = [[GH_SearchView alloc]<span class="string">initWithFrame:</span>CGRectMake(<span class="number">10</span>, <span class="number">80</span>, IPHONE_WIDTH<span class="number">-20</span>, <span class="number">44.</span>f) <span class="string">withTarget:</span>self <span class="string">backgroundColor:</span>[UIColor redColor] <span class="string">placeholderContent:</span>@<span class="string">"请输入搜索内容"</span> <span class="string">searchImage:</span>@<span class="string">"GH_search"</span> <span class="string">withTableView:</span>nil];</span><br><span class="line"> </span><br><span class="line"><span class="comment">//自定制取消按钮字体颜色</span></span><br><span class="line">[searchView_1  <span class="string">setCancelButtonTitleColor:</span>[UIColor blueColor]];</span><br><span class="line"><span class="comment">//设置背景色透明度</span></span><br><span class="line">[searchView_1 <span class="string">setBackgroundColorWithAlphaComponent:</span><span class="number">0.5</span>];</span><br><span class="line"><span class="comment">//设置激活状态</span></span><br><span class="line">[searchView_1 <span class="string">setSearchActiveState:</span>YES];</span><br><span class="line">    </span><br><span class="line">[self.view <span class="string">addSubview:</span>searchView_1];</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="comment">//self.tableView.tableHeaderView = self.searchView;</span></span><br></pre></td></tr></table></figure><p>使用时需遵守<code>GH_searchDelegate</code>协议。<br>其中必需实现的协议方法有一种:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 搜索按钮</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> content 搜索的内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">-(<span class="keyword">void</span>)<span class="string">searchClickedWithContent:</span>(NSString *)content;</span><br></pre></td></tr></table></figure><p>可选的协议方法有三种:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 实时搜索协议方法</span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> content 搜索的内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">-(<span class="keyword">void</span>)<span class="string">searchBoxContentDidChange:</span>(NSString *)content;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 搜索框开始输入</span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> content 搜索的内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">-(<span class="keyword">void</span>)<span class="string">searchDidBeginEditing:</span>(NSString *)content;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 搜索框输入结束</span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> content 搜索的内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">-(<span class="keyword">void</span>)<span class="string">searchDidEndEditing:</span>(NSString *)content;</span><br></pre></td></tr></table></figure><p>效果图如下：<br>无tableView情况下：<br><img src="http://obzx0h1re.bkt.clouddn.com/GH_searchView_1.png" alt="GH_searchView_1"></p><p>有tableView情况下：<br><img src="http://obzx0h1re.bkt.clouddn.com/GH_searchView_2.png" alt="GH_searchView_2"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于iOS自带的搜索框，其实我用着也挺好的，但低版本的使用：  高版本的使用:UISearchController，两个难有个统一。很多项目中都是将着两套代码都写入项目中去，这样做难免显得代码冗余。所以就简单的自定义个搜索框。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https:/
      
    
    </summary>
    
      <category term="iOS" scheme="http://guohuaden.com/categories/iOS/"/>
    
    
      <category term="自定义的搜索框" scheme="http://guohuaden.com/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E6%90%9C%E7%B4%A2%E6%A1%86/"/>
    
  </entry>
  
  <entry>
    <title>利用通知(`NSNotificationCenter`)获取键盘的高度,以及显示和隐藏键盘时修改界面的注意事项</title>
    <link href="http://guohuaden.com/2017/04/30/get-keyboard-height/"/>
    <id>http://guohuaden.com/2017/04/30/get-keyboard-height/</id>
    <published>2017-04-30T02:42:19.000Z</published>
    <updated>2018-10-24T06:08:38.320Z</updated>
    
    <content type="html"><![CDATA[<p>我们在开发中会遇到这样的情况：调用键盘时需要界面有一个调整，避免键盘遮掩输入框。</p><p>但实现时你会发现，在不同的手机上键盘的高度是不同的。这里列举一下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取键盘的高度</span></span><br><span class="line"> <span class="selector-tag">iphone</span> <span class="selector-tag">6</span>:</span><br><span class="line"> 中文</span><br><span class="line"> <span class="selector-tag">2014-12-31</span> <span class="selector-tag">11</span><span class="selector-pseudo">:16</span><span class="selector-pseudo">:23.643</span> <span class="selector-tag">Demo</span><span class="selector-attr">[686:41289]</span> 键盘高度是  <span class="selector-tag">258</span></span><br><span class="line"> <span class="selector-tag">2014-12-31</span> <span class="selector-tag">11</span><span class="selector-pseudo">:16</span><span class="selector-pseudo">:23.644</span> <span class="selector-tag">Demo</span><span class="selector-attr">[686:41289]</span> 键盘宽度是  <span class="selector-tag">375</span></span><br><span class="line"> 英文</span><br><span class="line"> <span class="selector-tag">2014-12-31</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:21.417</span> <span class="selector-tag">Demo</span><span class="selector-attr">[1102:58972]</span> 键盘高度是  <span class="selector-tag">216</span></span><br><span class="line"> <span class="selector-tag">2014-12-31</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:21.417</span> <span class="selector-tag">Demo</span><span class="selector-attr">[1102:58972]</span> 键盘宽度是  <span class="selector-tag">375</span></span><br><span class="line"> </span><br><span class="line"> <span class="selector-tag">iphone</span>  <span class="selector-tag">6</span> <span class="selector-tag">plus</span>：</span><br><span class="line"> 英文：</span><br><span class="line"> <span class="selector-tag">2014-12-31</span> <span class="selector-tag">11</span><span class="selector-pseudo">:31</span><span class="selector-pseudo">:14.669</span> <span class="selector-tag">Demo</span><span class="selector-attr">[928:50593]</span> 键盘高度是  <span class="selector-tag">226</span></span><br><span class="line"> <span class="selector-tag">2014-12-31</span> <span class="selector-tag">11</span><span class="selector-pseudo">:31</span><span class="selector-pseudo">:14.669</span> <span class="selector-tag">Demo</span><span class="selector-attr">[928:50593]</span> 键盘宽度是  <span class="selector-tag">414</span></span><br><span class="line"> 中文：</span><br><span class="line"> <span class="selector-tag">2015-01-07</span> <span class="selector-tag">09</span><span class="selector-pseudo">:22</span><span class="selector-pseudo">:49.438</span> <span class="selector-tag">Demo</span><span class="selector-attr">[622:14908]</span> 键盘高度是  <span class="selector-tag">271</span></span><br><span class="line"> <span class="selector-tag">2015-01-07</span> <span class="selector-tag">09</span><span class="selector-pseudo">:22</span><span class="selector-pseudo">:49.439</span> <span class="selector-tag">Demo</span><span class="selector-attr">[622:14908]</span> 键盘宽度是  <span class="selector-tag">414</span></span><br><span class="line"> </span><br><span class="line"> <span class="selector-tag">iPhone</span> <span class="selector-tag">7</span></span><br><span class="line"> <span class="selector-tag">2016-11-13</span> <span class="selector-tag">17</span><span class="selector-pseudo">:44</span><span class="selector-pseudo">:48.315</span> <span class="selector-tag">LoginDemo</span><span class="selector-attr">[2431:120937]</span> 键盘高度是  <span class="selector-tag">258</span></span><br><span class="line"> <span class="selector-tag">2016-11-13</span> <span class="selector-tag">17</span><span class="selector-pseudo">:44</span><span class="selector-pseudo">:48.316</span> <span class="selector-tag">LoginDemo</span><span class="selector-attr">[2431:120937]</span> 键盘宽度是  <span class="selector-tag">375</span></span><br><span class="line"> </span><br><span class="line"> <span class="selector-tag">iPhone</span> <span class="selector-tag">7</span> <span class="selector-tag">Plus</span></span><br><span class="line"> <span class="selector-tag">2016-11-13</span> <span class="selector-tag">17</span><span class="selector-pseudo">:43</span><span class="selector-pseudo">:20.683</span> <span class="selector-tag">LoginDemo</span><span class="selector-attr">[2322:119257]</span> 键盘高度是  <span class="selector-tag">271</span></span><br><span class="line"> <span class="selector-tag">2016-11-13</span> <span class="selector-tag">17</span><span class="selector-pseudo">:43</span><span class="selector-pseudo">:20.683</span> <span class="selector-tag">LoginDemo</span><span class="selector-attr">[2322:119257]</span> 键盘宽度是  <span class="selector-tag">414</span></span><br><span class="line"> </span><br><span class="line"> <span class="selector-tag">iphone</span> <span class="selector-tag">5</span> :</span><br><span class="line"> <span class="selector-tag">2014-12-31</span> <span class="selector-tag">11</span><span class="selector-pseudo">:19</span><span class="selector-pseudo">:36.452</span> <span class="selector-tag">Demo</span><span class="selector-attr">[755:43233]</span> 键盘高度是  <span class="selector-tag">216</span></span><br><span class="line"> <span class="selector-tag">2014-12-31</span> <span class="selector-tag">11</span><span class="selector-pseudo">:19</span><span class="selector-pseudo">:36.452</span> <span class="selector-tag">Demo</span><span class="selector-attr">[755:43233]</span> 键盘宽度是  <span class="selector-tag">320</span></span><br><span class="line"> </span><br><span class="line"> <span class="selector-tag">ipad</span> <span class="selector-tag">Air</span>：</span><br><span class="line"> <span class="selector-tag">2014-12-31</span> <span class="selector-tag">11</span><span class="selector-pseudo">:28</span><span class="selector-pseudo">:32.178</span> <span class="selector-tag">Demo</span><span class="selector-attr">[851:48085]</span> 键盘高度是  <span class="selector-tag">264</span></span><br><span class="line"> <span class="selector-tag">2014-12-31</span> <span class="selector-tag">11</span><span class="selector-pseudo">:28</span><span class="selector-pseudo">:32.178</span> <span class="selector-tag">Demo</span><span class="selector-attr">[851:48085]</span> 键盘宽度是  <span class="selector-tag">768</span></span><br><span class="line"> </span><br><span class="line"> <span class="selector-tag">ipad2</span> ：</span><br><span class="line"> <span class="selector-tag">2014-12-31</span> <span class="selector-tag">11</span><span class="selector-pseudo">:33</span><span class="selector-pseudo">:57.258</span> <span class="selector-tag">Demo</span><span class="selector-attr">[1014:53043]</span> 键盘高度是  <span class="selector-tag">264</span></span><br><span class="line"> <span class="selector-tag">2014-12-31</span> <span class="selector-tag">11</span><span class="selector-pseudo">:33</span><span class="selector-pseudo">:57.258</span> <span class="selector-tag">Demo</span><span class="selector-attr">[1014:53043]</span> 键盘宽度是  <span class="selector-tag">768</span></span><br></pre></td></tr></table></figure><p> 我们看出不同的手机设备键盘的高度是不同的，而且英文和中文键盘的高度也是不一样的。</p><p> 下面我们说一下利用通知来获取键盘的高度：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增加监听，当键盘出现或改变时收出消息</span></span><br><span class="line"><span class="selector-attr">[[NSNotificationCenter defaultCenter]</span> <span class="selector-tag">addObserver</span><span class="selector-pseudo">:self</span></span><br><span class="line">                                      <span class="selector-tag">selector</span>:@<span class="selector-tag">selector</span>(<span class="attribute">keyboardWillShow</span>:)</span><br><span class="line">                                      <span class="selector-tag">name</span><span class="selector-pseudo">:UIKeyboardWillShowNotification</span></span><br><span class="line">                                      <span class="selector-tag">object</span><span class="selector-pseudo">:nil</span>];</span><br><span class="line"> </span><br><span class="line"><span class="comment">//增加监听，当键退出时收出消息</span></span><br><span class="line"><span class="selector-attr">[[NSNotificationCenter defaultCenter]</span> <span class="selector-tag">addObserver</span><span class="selector-pseudo">:self</span></span><br><span class="line">                                      <span class="selector-tag">selector</span>:@<span class="selector-tag">selector</span>(<span class="attribute">keyboardWillHide</span>:)</span><br><span class="line">                                      <span class="selector-tag">name</span><span class="selector-pseudo">:UIKeyboardWillHideNotification</span></span><br><span class="line">                                      <span class="selector-tag">object</span><span class="selector-pseudo">:nil</span>];</span><br></pre></td></tr></table></figure><p>显示键盘的代码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)keyboardWillShow:(NSNotification *)aNotification</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取键盘的高度</span></span><br><span class="line">    NSDictionary *userInfo = [aNotification userInfo];</span><br><span class="line">    NSValue *aValue = [userInfo objectForKey:UIKeyboardFrameEndUserInfoKey];</span><br><span class="line">    CGRect keyboardRect = [aValue CGRectValue];</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span> = keyboardRect.<span class="built_in">size</span>.<span class="built_in">height</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">width</span> = keyboardRect.<span class="built_in">size</span>.<span class="built_in">width</span>;</span><br><span class="line">    NSLog(@<span class="string">"键盘高度是  %d"</span>,<span class="built_in">height</span>);</span><br><span class="line">    NSLog(@<span class="string">"键盘宽度是  %d"</span>,<span class="built_in">width</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>隐藏键盘的高度：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当键盘隐藏的时候</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">keyboardWillBeHidden:</span>(NSNotification*)aNotification</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 当然在注册通知(<code>NSNotificationCenter</code>)后，记得最后的注销通知：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-</span>(void)<span class="selector-tag">viewWillDisappear</span><span class="selector-pseudo">:(BOOL)animated</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="selector-attr">[[NSNotificationCenter defaultCenter]</span> <span class="selector-tag">removeObserver</span><span class="selector-pseudo">:self</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⚠️：切换键盘时也会产生 <code>UIKeyboardWillShowNotification</code> ，所以很可能方法被调用多次。最好在 <code>keyboardWillShow</code> 中不要写与调用次数有关的代码。在键盘第一次产生时，如果不是默认的英文键盘也会调用多次方法。</p><p> 比如：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark -  ******************打开键盘********</span></span><br><span class="line">- (<span class="keyword">void</span>) keyboardWillShowOfFeedBackVC:(<span class="built_in">NSNotification</span> *)notify &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这样写是不正确的：因为切换中英文键盘时都会调用该方法。</span></span><br><span class="line"><span class="comment">//    CGRect frame = self.view.frame;</span></span><br><span class="line"><span class="comment">//    frame.origin.y = self.view.frame.origin.y - 64;</span></span><br><span class="line"><span class="comment">//    self.view.frame = frame;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.view.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">-40</span>, IPHONE_WIDTH, IPHONE_HEIGHT);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们在开发中会遇到这样的情况：调用键盘时需要界面有一个调整，避免键盘遮掩输入框。&lt;/p&gt;
&lt;p&gt;但实现时你会发现，在不同的手机上键盘的高度是不同的。这里列举一下：&lt;/p&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class
      
    
    </summary>
    
      <category term="iOS" scheme="http://guohuaden.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://guohuaden.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>统计项目代码量</title>
    <link href="http://guohuaden.com/2017/04/29/Project-code-number/"/>
    <id>http://guohuaden.com/2017/04/29/Project-code-number/</id>
    <published>2017-04-29T01:48:46.000Z</published>
    <updated>2018-10-24T10:59:46.059Z</updated>
    
    <content type="html"><![CDATA[<p>有遇到过这样的情况，项目经理在写文档时会要求开发人员提供项目的代码量。下面就说一下代码量的统计问题。</p><h4 id="1、统计总的代码量（代码的行数）"><a href="#1、统计总的代码量（代码的行数）" class="headerlink" title="1、统计总的代码量（代码的行数）"></a>1、统计总的代码量（代码的行数）</h4><p>在终端中，cd 到项目文件夹；输入下面的指令。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span> . -<span class="built_in">name</span> <span class="string">"*.m"</span> -<span class="built_in">or</span> -<span class="built_in">name</span> <span class="string">"*.h"</span> -<span class="built_in">or</span> -<span class="built_in">name</span> <span class="string">"*.xib"</span> -<span class="built_in">or</span> -<span class="built_in">name</span> <span class="string">"*.c"</span> |xargs grep -v <span class="string">"^$"</span>|wc -l</span><br></pre></td></tr></table></figure><p>该指令是统计总共的代码量，并不统计具体的文件代码<br>其中<code>grep -v “^$”</code>：去除空行</p><p>注释是包含在代码量中的，这一点要注意。</p><p>统计效果图：<br><img src="http://obzx0h1re.bkt.clouddn.com/ProjectCodeTotal.png" alt="统计总的代码量"></p><h4 id="2、统计每个文件的代码量（代码的行数）"><a href="#2、统计每个文件的代码量（代码的行数）" class="headerlink" title="2、统计每个文件的代码量（代码的行数）"></a>2、统计每个文件的代码量（代码的行数）</h4><p>在终端中，cd 到项目文件夹；输入下面的指令。<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span> . -<span class="built_in">name</span> <span class="string">"*.m"</span> -<span class="built_in">or</span> -<span class="built_in">name</span> <span class="string">"*.h"</span> -<span class="built_in">or</span> -<span class="built_in">name</span> <span class="string">"*.xib"</span> -<span class="built_in">or</span> -<span class="built_in">name</span> <span class="string">"*.c"</span> |xargs wc -l</span><br></pre></td></tr></table></figure></p><p>该指令会统计具体的文件代码行数。</p><p>统计效果图：<br><img src="http://obzx0h1re.bkt.clouddn.com/ProjectCodeNumber1.png" alt="统计每个文件的代码量1"></p><p><img src="http://obzx0h1re.bkt.clouddn.com/ProjectCodeNumber2.png" alt="统计每个文件的代码量2"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有遇到过这样的情况，项目经理在写文档时会要求开发人员提供项目的代码量。下面就说一下代码量的统计问题。&lt;/p&gt;
&lt;h4 id=&quot;1、统计总的代码量（代码的行数）&quot;&gt;&lt;a href=&quot;#1、统计总的代码量（代码的行数）&quot; class=&quot;headerlink&quot; title=&quot;1、
      
    
    </summary>
    
      <category term="iOS" scheme="http://guohuaden.com/categories/iOS/"/>
    
    
      <category term="统计代码量" scheme="http://guohuaden.com/tags/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>iOS中关于图片、PDF等文件加密</title>
    <link href="http://guohuaden.com/2017/04/27/fileEncryptionAndDecryption/"/>
    <id>http://guohuaden.com/2017/04/27/fileEncryptionAndDecryption/</id>
    <published>2017-04-27T03:20:25.000Z</published>
    <updated>2018-10-24T11:02:22.304Z</updated>
    
    <content type="html"><![CDATA[<p>这里加密使用的是三方库：<code>RNCryptor</code>,它是一个跨语言AES加密/解密库。</p><p>主要目标是<code>Swift</code>和<code>Objective-C</code>，但<code>C</code>,<code>C ++</code>,<code>C＃</code>,<code>Erlang</code>,<code>Go</code>,<code>Haskell</code>,<code>Java</code>,<code>PHP</code>,<code>Python</code>,<code>Javascript</code>和<code>Ruby</code>中都有实现。</p><p>RNCryptor地址：</p><p><a href="https://github.com/RNCryptor/RNCryptor" target="_blank" rel="noopener">RNCryptor ：https://github.com/RNCryptor/RNCryptor</a></p><p>以及OC专用的地址:</p><p><a href="https://github.com/RNCryptor/RNCryptor-objc" target="_blank" rel="noopener">RNCryptor-objc ：https://github.com/RNCryptor/RNCryptor-objc</a></p><p>下面就用到的图片和PDF文件加密做一下简单的介绍。</p><h4 id="1、图片加解密"><a href="#1、图片加解密" class="headerlink" title="1、图片加解密"></a>1、图片加解密</h4><p>这个没有什么思想可言，直接看下代码</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma  mark --Image加解密</span></span><br><span class="line">-(<span class="keyword">void</span>)imageEncryptionAndDecryption</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfFile:[[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"default.jpg"</span> ofType:<span class="literal">nil</span>]];</span><br><span class="line">    <span class="built_in">NSError</span> *error;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//加密</span></span><br><span class="line">    <span class="built_in">NSData</span> *encryptedData = [RNEncryptor encryptData:data withSettings:kRNCryptorAES256Settings password:aPassword error:&amp;error ];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"^_^ 加密成功 ……——(^_^)\n"</span>);</span><br><span class="line"><span class="comment">//        NSLog(@"encryptedData==%@",encryptedData);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//解密</span></span><br><span class="line">    <span class="built_in">NSData</span> *decryptedData = [RNDecryptor decryptData:encryptedData withPassword:aPassword error:&amp;error];</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"^_^ 解密成功 ……——(^_^)\n"</span>);</span><br><span class="line"><span class="comment">//        NSLog(@"decryptedData==%@",decryptedData);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.imageView.image = [<span class="built_in">UIImage</span> imageWithData:decryptedData];</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、PDF加解密"><a href="#2、PDF加解密" class="headerlink" title="2、PDF加解密"></a>2、PDF加解密</h4><p>考虑到PDF文件可能较大的原因，这里在加解密时使用了子线程，以避免加解密过程耗时。</p><p>另：PDF查看需要提供路径，而这也是关键。</p><p>思路：</p><ol><li>将网络请求下来的数据流（NSData）直接进行加密，加密成功后存入沙盒目录中。</li><li>在查看PDF时,先对加密的PDF进行解密，再将解密的PDF存入沙盒目录中（区分加解密PDF文件）。</li><li>获取解密的PDF文件路径，查看PDF文件。</li><li>退出查看当前的PDF文件时，删除解密后的PDF文件缓存，保留加密的PDF缓存。</li></ol><p>查看代码：</p><p><strong>加密</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark --PDF加密</span></span><br><span class="line">-(<span class="keyword">void</span>)PDFEncryption</span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="built_in">NSData</span> *encryptedData;</span><br><span class="line">    __block <span class="built_in">NSError</span> *error;</span><br><span class="line">    <span class="built_in">NSString</span> *filePath = [[<span class="built_in">NSBundle</span> mainBundle]pathForResource:<span class="string">@"11.pdf"</span> ofType:<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *fileEncryPath = [<span class="built_in">NSHomeDirectory</span>()stringByAppendingPathComponent:<span class="string">@"/Documents/TKAMC.qgh"</span>];</span><br><span class="line">    <span class="built_in">NSFileManager</span> *fileManager = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">    <span class="comment">//判断是否已存在加密文件，若存在直接执行解密过程。</span></span><br><span class="line">    <span class="keyword">if</span> ([fileManager fileExistsAtPath:fileEncryPath]) &#123;</span><br><span class="line">        </span><br><span class="line">        [<span class="keyword">self</span> PDFDecryptedData:[<span class="built_in">NSData</span> dataWithContentsOfFile:fileEncryPath]];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//异步去加密，防止占用太多内存</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfFile:filePath];</span><br><span class="line">        <span class="comment">//加密</span></span><br><span class="line">        encryptedData = [RNEncryptor encryptData:data withSettings:kRNCryptorAES256Settings password:aPassword error:&amp;error ];</span><br><span class="line">        <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"^_^ PDF加密成功 ……——(^_^)\n"</span>);</span><br><span class="line"><span class="comment">//            NSLog(@"encryptedData==%@",encryptedData);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在主线程上写入文件</span></span><br><span class="line">        <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="built_in">BOOL</span> yes = [encryptedData writeToFile:fileEncryPath atomically:<span class="literal">NO</span>];</span><br><span class="line">            <span class="keyword">if</span> (yes) &#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"加密文件写入成功"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"加密文件写入失败"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"写入PDF路径：%@"</span>,fileEncryPath);</span><br><span class="line">            [<span class="keyword">self</span> PDFDecryptedData:encryptedData];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解密</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark ---PDF解密</span></span><br><span class="line">-(<span class="keyword">void</span>)PDFDecryptedData:(<span class="built_in">NSData</span> *)encryptedData&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSString</span> *fileDecryPath = [<span class="built_in">NSHomeDirectory</span>()stringByAppendingPathComponent:<span class="string">@"/Documents/TKAMC"</span>];</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="comment">//    解密</span></span><br><span class="line">        <span class="built_in">NSError</span> *error;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (encryptedData != <span class="literal">nil</span> || aPassword != <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="built_in">NSData</span> *decryptedData = [RNDecryptor decryptData:encryptedData</span><br><span class="line">                                                withPassword:aPassword</span><br><span class="line">                                                       error:&amp;error];</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                 <span class="built_in">BOOL</span> yes = [decryptedData writeToFile:fileDecryPath atomically:<span class="literal">NO</span>];</span><br><span class="line">                <span class="keyword">if</span> (yes) &#123;</span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@"解密文件写入成功"</span>);</span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@"写入解密PDF路径：%@"</span>,fileDecryPath);</span><br><span class="line">                    <span class="keyword">self</span>.filepath = fileDecryPath;</span><br><span class="line">                    [<span class="keyword">self</span> pushVC];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@"解密文件写入失败"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"加密数据为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="#FF6347"><strong>注：</strong></font>这里加解密时并没有具体实现网络请求模块，只是简单的对本地文件进行了实践，但大体实现过程已经实现。</p><p><strong>退出PDF时，删除解密的PDF文件</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark - ReaderViewControllerDelegate methods</span></span><br><span class="line">- (<span class="keyword">void</span>)dismissReaderViewController:(ReaderViewController *)viewController</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//MARK:退出查看PDF时删除解密存储文件。</span></span><br><span class="line">    <span class="built_in">NSFileManager</span> *fileManager = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">    </span><br><span class="line">    [fileManager removeItemAtPath:<span class="keyword">self</span>.filepath error:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>这里提供一个个人测试使用的一个Demo，仅供参考</p><p><a href="https://github.com/Wheat-Qin/FileEncryption_Demo" target="_blank" rel="noopener">FileEncryption_Demo ：https://github.com/Wheat-Qin/FileEncryption_Demo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里加密使用的是三方库：&lt;code&gt;RNCryptor&lt;/code&gt;,它是一个跨语言AES加密/解密库。&lt;/p&gt;
&lt;p&gt;主要目标是&lt;code&gt;Swift&lt;/code&gt;和&lt;code&gt;Objective-C&lt;/code&gt;，但&lt;code&gt;C&lt;/code&gt;,&lt;code&gt;C ++&lt;/
      
    
    </summary>
    
      <category term="iOS" scheme="http://guohuaden.com/categories/iOS/"/>
    
    
      <category term="文件加密" scheme="http://guohuaden.com/tags/%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
</feed>
