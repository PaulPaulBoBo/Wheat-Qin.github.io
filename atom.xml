<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>青卷三部</title>
  <subtitle>金戈铁马，写意风流</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http:guohuaden.com/"/>
  <updated>2017-01-14T02:11:44.000Z</updated>
  <id>http:guohuaden.com/</id>
  
  <author>
    <name>青卷三部</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS之项目总结二：关于项目中一些功能的改进建议（从一个维护者的角度）</title>
    <link href="http:guohuaden.com/2017/01/11/project-summary-two/"/>
    <id>http:guohuaden.com/2017/01/11/project-summary-two/</id>
    <published>2017-01-11T15:38:00.000Z</published>
    <updated>2017-01-14T02:11:44.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>最近一直在维护老的项目，遇到的问题也千奇百怪，需要修补的，需要优化的，需要特殊处理的，感觉总是那么的无语。也许这时候也应该感叹一句：路漫漫其修远兮，吾将上下而求索吧。<br>这篇文章就只是讲讲老项目中遇到的种种不敢苟同的代码写法，以及遇到一些问题时的处理方法。</p>
<h3 id="1、关于按钮事件的重复点击问题"><a href="#1、关于按钮事件的重复点击问题" class="headerlink" title="1、关于按钮事件的重复点击问题"></a>1、关于按钮事件的重复点击问题</h3><p>我们开发中大概都经历过这样的事情，我的一个<code>button</code>被重复的快速点击，（我们开发者应该更清楚的知道这意味着什么）。那我们再深入的想一下（给这样的事件安排一个特定的环境）：例如当网络较差的情况下，再例如当<code>button</code>的执行事件较为耗时时。这时就会出现很多的问题：有时是界面出现问题（当<code>button</code>执行事件中出现调节界面<code>frame</code>的时候）；有时则会出现卡顿，更甚至会出现崩溃现象。对于这种问题，我们要提前考虑到，做好防范处理：即点击按钮事件时,添加防止重复点击功能。</p>
<p><strong>思路是</strong>：防止按钮重复点击<br>比较推荐的解决方法代码：</p>
<pre> - (void)btnClicked:(id)sender {
    //在这里做按钮的想做的事情。
}
- (void)buttonClicked:(id)sender {
   //先将未到时间执行前的任务取消。
    [[self class] cancelPreviousPerformRequestsWithTarget:self selector:@selector(btnClicked:)object:sender];
    [self performSelector:@selector(btnClicked:)withObject:sender afterDelay:0.2f];
}</pre>

<p><strong>原理是</strong> ：我们每次点击按钮时，先执行取消之前的按钮点击执行事件，然后再去执行一个延迟执行方法（方法中执行的是按钮执行的事件）。</p>
<p>还有一种方法也是可以实现的：具体的看《<a href="http://www.cnblogs.com/LQCQ-Silent/p/6082086.html" target="_blank" rel="external">iOS之防止用户重复点击Button（按钮）问题</a> 》</p>
<h3 id="2、很多界面共用一个界面时：使用枚举做类型判断"><a href="#2、很多界面共用一个界面时：使用枚举做类型判断" class="headerlink" title="2、很多界面共用一个界面时：使用枚举做类型判断"></a>2、很多界面共用一个界面时：使用枚举做类型判断</h3><p>老的项目中会出现很多这样的现象：很多界面重复使用一个界面，这样就自然而然的需要在不同的界面跳转到复用的界面时去做判断。而奇怪的地方在于：判断的依据是<code>self.title</code>。那么就会出现这样一种现象：在跳转界面后会有一大段<code>if</code>去判断字符串是否等于<code>self.title</code> 。</p>
<p><strong>如果我们做一些改变：使用枚举来做界面类型的判断，使用<code>switch case</code>语句做判断执行代码。这样会不会更优美，简洁一些。</strong></p>
<h3 id="3、关于老项目中iOS10以上的情况下，导航栏中按钮不显示问题"><a href="#3、关于老项目中iOS10以上的情况下，导航栏中按钮不显示问题" class="headerlink" title="3、关于老项目中iOS10以上的情况下，导航栏中按钮不显示问题"></a>3、关于老项目中iOS10以上的情况下，导航栏中按钮不显示问题</h3><p>如果你的<code>viewController</code>都继承于基类，那么在基类中添加这样一段代码（这也是目前我发现的最省事的方法）：</p>
<pre>- (void)viewWillAppear:(BOOL)animated { 
    [super viewWillAppear:animated];
    [self.navigationController setNavigationBarHidden:YES animated:NO];
    [self.navigationController setNavigationBarHidden:NO animated:NO];
}
- (void)viewWillDisappear:(BOOL)animated {
    [super viewWillDisappear:animated];
    [self.navigationController setNavigationBarHidden:YES animated:NO];
    [self.navigationController setNavigationBarHidden:NO animated:NO];
}</pre>



<h3 id="4、事件方法要每个界面区分开"><a href="#4、事件方法要每个界面区分开" class="headerlink" title="4、事件方法要每个界面区分开"></a>4、事件方法要每个界面区分开</h3><p>老项目中会有这种情况：在本界面 command点击一个<code>button</code>执行事件方法或者手势事件方法时，会莫名其妙的跳转到另外一个界面。<br>我们在开发时最好给不同界面<code>button</code>的<code>clicked</code>事件命名是区分开来，例如：界面名 + <code>ButtonClicked</code></p>
<h3 id="5、对象为空现象"><a href="#5、对象为空现象" class="headerlink" title="5、对象为空现象"></a>5、对象为空现象</h3><p>在开发中如果存在<code>image</code>为空，或者必须显示的<code>String</code>为空现象，<br>记得在代码中作判断，图片可以直接设置默认图片，字符串也可以设置默认字符串<br>这一点可以学一下SDWebImage库中对于网络请求图片不存在的处理方法：</p>
<p><pre>//给一张默认图片，先使用默认图片，当图片加载完成后再替换<br>[self.image1 sd_setImageWithURL:imagePath1 placeholderImage:[UIImage imageNamed:@”default”]];</pre>例如：</p>
<p><pre><br>UIImage *image = [UIImage imageNamed:@”image”];</pre></p>
<p>UIImage *defaultImage = [UIImage imageNamed:@”defaultImage”];</p>
<p>UIImageView *imageView = [[UIImageView alloc]initWithImage:image==nil ?  image:defaultImage];<br>字符串当然也是类似，其实看似有些费事甚至有的显得多余的写法，会使以后的维护变得更加的如意。</p>
<h3 id="6、一个界面多网络请求问题，而且需要多个请求都完成后，对界面有一些操作。"><a href="#6、一个界面多网络请求问题，而且需要多个请求都完成后，对界面有一些操作。" class="headerlink" title="6、一个界面多网络请求问题，而且需要多个请求都完成后，对界面有一些操作。"></a>6、一个界面多网络请求问题，而且需要多个请求都完成后，对界面有一些操作。</h3><p>这是一个老的话题了，我之所以重新提及这个话题，原因是我从一些文章中发现了一个从来没使用过的方法，这个下面会提到，现在就让我们列举出来比较常用的方法。就以一个界面两个网络请求为例 A和B.</p>
<p><strong>（1）两个请求互套)(也是最笨的方法)</strong><br>     具体是这样的，我在A请求成功后，再请求B。当然如果请求多的话，这个肯定是作废的。</p>
<p><strong>（2）使用GCD中的通知</strong></p>
<p><pre>dispatch_group_t serviceGroup = dispatch_group_create();<br>// 开始第一个网络请求<br>servicedispatch_group_enter(serviceGroup);<br>[self.configService startWithCompletion:^(ConfigResponse <em>results, NSError </em>error) {<br> //请求成功后的操作<br>    configError = error;<br>    dispatch_group_leave(serviceGroup);//完成后离开分组<br>}];<br>// 开始第二个请求<br>dispatch_group_enter(serviceGroup);<br>[self.preferenceService startWithCompletion:^(PreferenceResponse <em>results, NSError </em>error) {<br> //请求成功后的操作<br>    preferenceError = error;<br>    dispatch_group_leave(serviceGroup);//完成后离开分组<br>}];<br>dispatch_group_notify(serviceGroup,dispatch_get_main_queue(),^{<br> // Assess any errors<br>     NSError *overallError = nil;<br>    if (configError || preferenceError)  {<br> // 判断时候请求有失败<br>        overallError = configError ?: preferenceError;<br>     }<br>// 最后完成后执行的block<br>    completion(overallError);<br>});<br></pre></p>
<p><strong>（3）利用GCD中的信号量</strong></p>
<p>在GCD中有三个函数是<code>semaphore</code>的操作，分别是：　　<br><code>dispatch_semaphore_create</code> 创建一个semaphore　　<br><code>dispatch_semaphore_signal</code> 发送一个信号　<br><code>dispatch_semaphore_wait</code> 等待信号　　<br>简单的介绍一下这三个函数，第一个函数有一个整形的参数，我们可以理解为信号的总量，<code>dispatch_semaphore_signal</code>是发送一个信号，自然会让信号总量加1，<code>dispatch_semaphore_wait</code>等待信号，当信号总量少于0的时候就会一直等待，否则就可以正常的执行，并让信号总量-1，根据这样的原理，我们便可以快速的创建一个并发控制来同步任务和有限资源访问控制。</p>
<p>利用这样的机制，当信号量达到我们网络请求的数量时，请求结束。</p>
<p><strong>（4）这个也是我上面说的无意中看到的一个方法，仅拿出来作为参考</strong></p>
<p><pre>dispatch_async(concurrent_queue, ^{<br>     NSLog(@”—并发任务1—“);<br>});<br>dispatch_async(concurrent_queue, ^{<br>     NSLog(@”—并发任务2—“);<br>});<br>dispatch_barrier_async(concurrent_queue, ^{<br>    dispatch_async(dispatch_get_main_queue(), ^{<br>        NSLog(@”—所有并发任务结束后回到主线程刷新—“);<br>    });<br>}); </pre></p>
<p>以上就是关于一界面多请求的不同解决方案。</p>
<h3 id="7、代码规范问题"><a href="#7、代码规范问题" class="headerlink" title="7、代码规范问题"></a>7、代码规范问题</h3><ul>
<li>为什么这个普通的话题放到最后呢，大概是因为我觉得这个很重要的问题吧，毕竟技术水平不高，还是可以提升的。但代码不规范的话，养成习惯后很难改的，我见过太多项目中使用【拼音命名、不注意驼峰命名法、define预处理指令满天飞等等的代码】这些出现在项目中就像时时刻刻在提醒你，看这样的项目是一种煎熬。</li>
<li>其实代码规范不仅仅是公司对开发者的要求,也是开发者对自己的一个要求。因为如果统一每个人的写作规范，是一件耗时，耗材的事情。小一些的公司是做不来，中型的公司大多是不想做。而大型的公司总是花费近几个月的时间去培养员工的代码规范，这就是财大气粗吧。而且开发者本身对于技术的提升、追求等，都无形中要求自己注意代码规范问题。</li>
<li>对于这部分，建议看看《Effective Objective-C 2.0》这本书，其中起到的。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h3&gt;&lt;p&gt;最近一直在维护老的项目，遇到的问题也千奇百怪，需要修补的，需要优化的，需要特殊处理的，感觉总是那么的无语。也许这时候也应该感叹一句：
    
    </summary>
    
    
      <category term="iOS" scheme="http:guohuaden.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS之项目总结－：项目中遇到的各种的问题和解决方法</title>
    <link href="http:guohuaden.com/2016/08/16/project-summary-one/"/>
    <id>http:guohuaden.com/2016/08/16/project-summary-one/</id>
    <published>2016-08-16T10:28:00.000Z</published>
    <updated>2017-01-14T03:56:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p> 一到公司报道那时，便着手独立的去完成了一个项目，其中的辛酸泪也是不足为外人道也。这次算是一个新型的app，仍然是独立开发，但心境和想法却是完全的不同。下面说一次以前做开发时常常忽略的知识，也算是一种复习了吧。下面言归正传：</p>
<h3 id="1、自带键盘的next用法"><a href="#1、自带键盘的next用法" class="headerlink" title="1、自带键盘的next用法"></a>1、自带键盘的next用法</h3><p>这算是比较常用的了吧，只要我们想到登录和注册界面，就应该自然而然的想到 - 键盘的next用法（当然不排除相当多的软件并没有实现这个功能）。</p>
<p>想法也就是：用户在输入用户名后，点击next跳转到下一个输入框。其实也不用想的如此复杂，在登录界面，我们完全可以用一个 if 语句做判断，去实现键盘的响应和注销响应。</p>
<p>代码如下： <pre>- (BOOL)textFieldShouldReturn:(UITextField <em> )textField {<br>  UITextField </em> passTextFiled = (UITextField *)[self.view viewWithTag:201];<br>  if (textField.tag == 200) {<br>          [passTextFiled becomeFirstResponder];<br>   }else{<br>           [passTextFiled resignFirstResponder];<br>    }<br>   return YES;<br>}</pre><br>这样就简单的在变成响应和注销响应之间实现了输入框的切换。</p>
<p>但还是存在一个问题，如果我实现注册界面的跳转输入框，并且在输入框很多的情况下，显然如果我仍是这样判断，会显得啰嗦和冗余。</p>
<p>我曾想过使用计数的方式，记录每一次的点击next后的tag，但实践中失败了，因为当我不通过next而是直接用手去触摸选择输入框时，则无法计数。</p>
<p> 这里先留个空白，等把手里的项目完成时再研究这个问题</p>
<h3 id="2、UITextField的纠错和首字母大小写问题"><a href="#2、UITextField的纠错和首字母大小写问题" class="headerlink" title="2、UITextField的纠错和首字母大小写问题"></a>2、UITextField的纠错和首字母大小写问题</h3><p>这个问题只是简单的属性问题，在开发时如果忘记，建议多点进去看看，（如：command + UITextField）   </p>
<pre>
 //输入框中是否有个叉号，在什么时候显示，用于一次性删除输入框中的内容    
self.clearButtonMode = UITextFieldViewModeWhileEditing;    
//是否纠错,本人感觉纠错是一个很反感的东西，但UITextField默认是 YES,这里我改成了NO      
self.autocorrectionType = UITextAutocorrectionTypeNo;       
 //再次编辑就清空      
self.clearsOnBeginEditing = YES;       
//设置自动缩小显示的最小字体大小      
self.minimumFontSize = 15;        
//设置键盘的样式，本人感觉这个设置对用户体验有影响。比如说我想打电话，Type为UIKeyboardTypeNumberPad,而不是其他     
self.keyboardType = UIKeyboardTypeNamePhonePad;</pre>

<h3 id="3、iOS中图片的几种拉伸方法的使用"><a href="#3、iOS中图片的几种拉伸方法的使用" class="headerlink" title="3、iOS中图片的几种拉伸方法的使用"></a>3、iOS中图片的几种拉伸方法的使用</h3><p>以下是Apple SDK给出的3种方法:</p>
<pre>UIImage *image = [UIImage imageNamed:@"picture"];        
//iOS5之前     
// 左端盖宽度        
NSInteger leftCapWidth = image.size.width * 0.5f;       
NSInteger topCapHeight = image.size.height * 0.8f;        

image = [image stretchableImageWithLeftCapWidth:leftCapWidth topCapHeight:topCapHeight];        

//iOS5之后       
UIEdgeInsets insets = UIEdgeInsetsMake(image.size.height * 0.8f,image.size.width * 0.5f, 40, 40);       

image = [image resizableImageWithCapInsets:insets];      
//iOS6之后        
UIEdgeInsets insets = UIEdgeInsetsMake(image.size.height * 0.8f,image.size.width * 0.5f, 40, 40);       
image = [image resizableImageWithCapInsets:insets resizingMode:UIImageResizingModeStretch]; </pre>  
下面是使用的解释：

![pictureStretch](http://obzx0h1re.bkt.clouddn.com/pictureStretch.png)

<pre>
/**   
 *  - (UIImage *)stretchableImageWithLeftCapWidth:(NSInteger)leftCapWidth topCapHeight:(NSInteger)topCapHeight;    
 *  
 *  leftCapWidth代表左端盖宽度，topCapHeight代表顶端盖高度。系统会自动计算出右端盖宽度(rightCapWidth)和底端盖高度(bottomCapHeight)    

 * 算法如下：    
 * width为图片宽度  rightCapWidth = width - leftCapWidth - 1;       
 * height为图片高度 bottomCapHeight = height - topCapHeight - 1    
 *    
 *经过计算，你会发现中间的可拉伸区域只有1x1    
 *   

* stretchWidth为中间可拉伸区域的宽度        stretchWidth = width - leftCapWidth - rightCapWidth = 1;       
* stretchHeight为中间可拉伸区域的高度        stretchHeight = height - topCapHeight - bottomCapHeight = 1;    
*    
* 因此，使用这个方法只会拉伸图片中间1x1的区域，并不会影响到边缘和角落。    
*/

/**   
 * - (UIImage * )resizableImageWithCapInsets:(UIEdgeInsets)capInsets    
 *  这个方法只接收一个UIEdgeInsets类型的参数，可以通过设置UIEdgeInsets的left、right、top、bottom来分别指定左端盖宽度、右端盖宽度、顶端盖高度、底端盖高度    
 * */       

/**    
 *- (UIImage * )resizableImageWithCapInsets:(UIEdgeInsets)capInsets resizingMode:(UIImageResizingMode)resizingMode  

对比iOS5.0中的方法，只多了一个<code>UIImageResizingMode</code>参数，用来指定拉伸的模式：
    UIImageResizingModeStretch：拉伸模式，通过拉伸
    UIEdgeInsets:指定的矩形区域来填充图片    
    UIImageResizingModeTile：平铺模式，通过重复显示
    UIEdgeInsets指定的矩形区域来填充图片   
**/</pre>

<p>图片拉伸的以上内容参考文章 《<a href="http://blog.csdn.net/q199109106q/article/details/8615661" target="_blank" rel="external">iOS图片拉伸技巧</a>》讲的很好，建议大家多看看。</p>
<h3 id="4、iOS中唤起自带浏览器（safari）的方法"><a href="#4、iOS中唤起自带浏览器（safari）的方法" class="headerlink" title="4、iOS中唤起自带浏览器（safari）的方法"></a>4、iOS中唤起自带浏览器（safari）的方法</h3><p>也是一个简单的一句代码 ，这种也就是知道了就知道了，不知道就是抓耳挠腮吧 </p>
<pre>NSURL *url = [NSURL URLWithString:urlStr]; 

[[UIApplication sharedApplication] openURL:url]; </pre>

<h3 id="5、iOS中唤起电话界面"><a href="#5、iOS中唤起电话界面" class="headerlink" title="5、iOS中唤起电话界面"></a>5、iOS中唤起电话界面</h3><p>app内部唤起电话界面的实现，是找了很多资料才有的一个结论（安全，并且拨打完之后可以返回app）</p>
<p>实现的方法是使用UIWebView 加载电话，目前这种方法是合法的，App Store也允许通过的。  </p>
<pre>NSURL *phoneURL = [NSURL URLWithString:[NSString stringWithFormat:@"tel:%@",newPhoneString]];    
 if (_phoneCallWebView) { 
   [_phoneCallWebView loadRequest:[NSURLRequest requestWithURL:phoneURL]];  

 }</pre>
但如果使用下面的这种方法，则可能不允许通过审核  
<pre>[[UIApplication sharedApplication] openURL:phoneURL];</pre>

<h3 id="6、iOS-调用地图的方法"><a href="#6、iOS-调用地图的方法" class="headerlink" title="6、iOS 调用地图的方法"></a>6、iOS 调用地图的方法</h3><p>app内部调用第三方app，这里有一个详细的文章《<a href="http://blog.csdn.net/a416863220/article/details/51220739" target="_blank" rel="external">IOS实现应用内打开第三方地图app进行导航</a>》</p>
<ul>
<li>app内部调用地图，需要先检测用户手机上是否已经安装地图app。</li>
</ul>
<p>我们常用的地图app有：高德、百度；国外有：谷歌（Google Map ）。当然还有苹果自带的地图，随着iOS10的发布，苹果地图这块也有很大的完善和进步。</p>
<p>我使用Xcode模拟器实现时，会提示:</p>
<pre>1、canOpenURL: failed for URL: "iosamap://" error: "(null)" 。</pre> 

<p><strong>原因是：模拟器上没有高德地图。</strong></p>
<pre>2、canOpenURL: failed for URL:"comgooglemaps://" 
error: "This app is not allowed to query for scheme comgooglemaps"。</pre> 
**原因是：LSApplicationQueriesSchemes 我自己马虎设成了字典类型。**

首先说好的是iOS9以后，我们在app内部要跳转到其他软件时，需要在 <code>Info.plist</code> 中添加白名单。

方法为：在<code>Info.plist</code>中添加 <code>key : LSApplicationQueriesSchemes </code> 类型为：<code>Array</code>。

将高德、百度、谷歌的值填进去分别是：**iosamap**｜**baidumap** | **comgooglemaps**

图片：
![LSApplicationQueriesSchemes](http://obzx0h1re.bkt.clouddn.com/LSApplicationQueriesSchemes.png)

 至于下面代码中的<code>URLScheme</code> 和<code>appName </code> 是在<code>Info.plist</code> 的<code>URL types</code>中添加  <code>URL Scheme</code>(URL Schemes是一个数组，允许应用定义多个URL schemes)和<code>URL identifier</code>（建议采用反转域名的方法保证该名字的唯一性，比如 <code>com.yourApp.www</code>）

图片如下：

![URLTypes](http://obzx0h1re.bkt.clouddn.com/URLTypes.png)

下面是具体的代码：

 <pre>__block NSString *urlScheme = urlScheme;   

 __block NSString *appName = appName;    

__block CLLocationCoordinate2D coordinate = self.coordinate;        

UIAlertController *alert = [UIAlertController alertControllerWithTitle:@"选择地图" message:nil preferredStyle:UIAlertControllerStyleActionSheet];          

//apple自带的地图不需要判断        

UIAlertAction * action = [UIAlertAction actionWithTitle:@"苹果地图" style:UIAlertActionStyleDefault handler:^(UIAlertAction *action) {      

       MKMapItem *currentLocation = [MKMapItem mapItemForCurrentLocation]; 

     MKMapItem *toLocation = [[MKMapItem alloc] initWithPlacemark:[[MKPlacemark alloc] initWithCoordinate:coordinate addressDictionary:nil]];                      

     [MKMapItem openMapsWithItems:@[currentLocation, toLocation]                           launchOptions:@{

MKLaunchOptionsDirectionsModeKey:     MKLaunchOptionsDirectionsModeDriving,MKLaunchOptionsShowsTrafficKey: [NSNumber numberWithBool:YES]}];        

}];        

 [alert addAction:action];        

 //判断百度地图   

 if ( [[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@"baidumap://"]])      

{        UIAlertAction * action = [UIAlertAction actionWithTitle:@"百度地图" style:UIAlertActionStyleDefault handler:^(UIAlertAction *action) {                       

 NSString *urlString = [[NSString stringWithFormat:@"baidumap://map/direction?origin=&destination=latlng:%f,%f|name=目的地&mode=driving&coord_type=gcj02",coordinate.latitude, coordinate.longitude] stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];

  [[UIApplication sharedApplication] openURL:[NSURL URLWithString:urlString]];         

 }];        

[alert addAction:action];      

}     

 //判断高德地图     

 if ( [[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@"iosamap://"]])      

 {        

UIAlertAction * action = [UIAlertAction actionWithTitle:@"高德地图" style:UIAlertActionStyleDefault handler:^(UIAlertAction *action) {                        

NSString *urlString = [[NSString stringWithFormat:@"iosamap://navi?sourceApplication=%@&backScheme=%@&lat=%f&lon=%f&dev=0&style=2",appName,urlScheme,coordinate.latitude, coordinate.longitude] stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];  

        [[UIApplication sharedApplication] openURL:[NSURL URLWithString:urlString]];                    }];       

 [alert addAction:action];    

}        

 //判断谷歌地图   

 if ( [[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@"comgooglemaps://"]])    {       

 UIAlertAction * action = [UIAlertAction actionWithTitle:@"谷歌地图" style:UIAlertActionStyleDefault handler:^(UIAlertAction *action) {                       

 NSString *urlString = [[NSString stringWithFormat:@"comgooglemaps://?x-source=%@&x-success=%@&saddr=&daddr=%f,%f&directionsmode=driving",appName,urlScheme,coordinate.latitude, coordinate.longitude] stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];                       [[UIApplication sharedApplication] openURL:[NSURL URLWithString:urlString]];          

}];                

[alert addAction:action];    

}        

UIAlertAction *action = [UIAlertAction actionWithTitle:@"取消" style:UIAlertActionStyleCancel handler:nil];    [alert addAction:action];        

[self presentViewController:alert animated:YES completion:^{          

}];    

}</pre>

]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h3&gt;&lt;p&gt; 一到公司报道那时，便着手独立的去完成了一个项目，其中的辛酸泪也是不足为外人道也。这次算是一个新型的app，仍然是独立开发，但心境和
    
    </summary>
    
    
      <category term="iOS" scheme="http:guohuaden.com/tags/iOS/"/>
    
  </entry>
  
</feed>
