<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wheat</title>
  
  <subtitle>以梦为马，不负韶华</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://guohuaden.com/"/>
  <updated>2018-09-29T06:48:59.093Z</updated>
  <id>http://guohuaden.com/</id>
  
  <author>
    <name>Wheat</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>读 SDWebImage (一)</title>
    <link href="http://guohuaden.com/2018/09/29/Read-SDWebImage-note1/"/>
    <id>http://guohuaden.com/2018/09/29/Read-SDWebImage-note1/</id>
    <published>2018-09-29T06:32:04.000Z</published>
    <updated>2018-09-29T06:48:59.093Z</updated>
    
    <content type="html"><![CDATA[<p>SDWebImage整体的框架：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">SDWebImage</span><br><span class="line">    -</span><br><span class="line">    |--SDWebImageCompat :一些兼容性相关的宏定义 </span><br><span class="line">    |--SDWebImageOperation :只有一个 cancel 方法的 protocal</span><br><span class="line">    |</span><br><span class="line">    |--Downloader :下载模块</span><br><span class="line">    |   |-- SDWebImageDownloader</span><br><span class="line">    |   |-- SDWebImageDownloaderOperation</span><br><span class="line">    |   </span><br><span class="line">    |--Cache :内存和硬盘缓存模块</span><br><span class="line">    |   |-- SDImageCache</span><br><span class="line">    |</span><br><span class="line">    |--Utils :</span><br><span class="line">    |   |-- SDWebImageManager 将缓存和下载模块结合起来使用</span><br><span class="line">    |   |-- SDWebImagePrefetcher 预下载图片</span><br><span class="line">    |   |-- SDWebImageDecoder</span><br><span class="line">    |</span><br><span class="line">    |--Categories : UIKit 相关的Category,方便使用,还支持 MKAnnotationView</span><br><span class="line">        |-- MKAnnotationView+WebCache</span><br><span class="line">        |-- UIButton+WebCache</span><br><span class="line">        |-- UIImageView+WebCache</span><br><span class="line">    -</span><br><span class="line">    ... ...</span><br></pre></td></tr></table></figure><h2 id="1、使用配置"><a href="#1、使用配置" class="headerlink" title="1、使用配置"></a>1、使用配置</h2><p>为项目添加一个通用的只读缓存的存储路径:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSString *bundlePath = [[NSBundle mainBundle].resourcePath stringByAppendingPathComponent:@&quot;CustomPathImages&quot;];</span><br><span class="line"> </span><br><span class="line">[[SDImageCache sharedImageCache] addReadOnlyCachePath:bundlePath];</span><br></pre></td></tr></table></figure><h2 id="2、-身份鉴定"><a href="#2、-身份鉴定" class="headerlink" title="2、 身份鉴定"></a>2、 身份鉴定</h2><p>如果请求的图片需要身份鉴定才可以获取，SDWebImage提供了两种方法：</p><p>一种是直接设置用户名和密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[SDWebImageManager sharedManager].imageDownloader.username = @&quot;httpwatch&quot;;</span><br><span class="line">[SDWebImageManager sharedManager].imageDownloader.password = @&quot;httpwatch01&quot;;</span><br></pre></td></tr></table></figure><p>另一种是通过 <code>NSURLCredential</code> 属性去配置用户名和密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSURLCredential *newCredential = [NSURLCredential credentialWithUser:@&quot;httpwatch&quot; password:@&quot;httpwatch01&quot; persistence:NSURLCredentialPersistenceNone];</span><br><span class="line">[SDWebImageManager sharedManager].imageDownloader.urlCredential = newCredential;</span><br></pre></td></tr></table></figure><p>这里做下测试：<br>图片地址（需要身份验证才可以查看）：<a href="http://www.httpwatch.com/httpgallery/authentication/authenticatedimage/default.aspx?0.35786508303135633" target="_blank" rel="noopener">http://www.httpwatch.com/httpgallery/authentication/authenticatedimage/default.aspx?0.35786508303135633</a></p><p>浏览器去打开会弹出提示框让输入验证信息，如下：<br><img src="http://obzx0h1re.bkt.clouddn.com/Authentication_Image_SDWebImage.jpg" alt="Authentication_Image_SDWebImage"></p><p>这种情况下，在项目中就需要配置身份验证信息，否则图片无法显示。</p><h2 id="3、设置要附加到每个下载HTTP请求的HTTP标头的值"><a href="#3、设置要附加到每个下载HTTP请求的HTTP标头的值" class="headerlink" title="3、设置要附加到每个下载HTTP请求的HTTP标头的值"></a>3、设置要附加到每个下载HTTP请求的HTTP标头的值</h2><p>如果想要自定义图片请求的Request Header时，可以使用以下方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//设置要附加到每个下载HTTP请求的HTTP标头的值。</span><br><span class="line">  [SDWebImageManager.sharedManager.imageDownloader setValue:@&quot;&amp;&amp;Jason&amp;&amp;&quot; forHTTPHeaderField:@&quot;****SDWebImageM****&quot;];</span><br></pre></td></tr></table></figure><p>通过charles抓包可以看到设置的Request Header：</p><p><img src="http://obzx0h1re.bkt.clouddn.com/setValue_1_SDWebImageManager.jpg" alt="setValue_1_SDWebImageManager"></p><p><img src="http://obzx0h1re.bkt.clouddn.com/setValue_2_SDWebImageManager.jpg" alt="setValue_2_SDWebImageManager"></p><h2 id="4、图片下载执行顺序"><a href="#4、图片下载执行顺序" class="headerlink" title="4、图片下载执行顺序"></a>4、图片下载执行顺序</h2><p>执行顺序分：LIFO（先入后出） 和 FIFO（先进先出）两种<br>默认值为 <code>FIFO</code> 。</p><p><code>SDWebImageDownloaderExecutionOrder</code> ：枚举类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SDWebImageManager.sharedManager.imageDownloader.executionOrder = SDWebImageDownloaderLIFOExecutionOrder;</span><br></pre></td></tr></table></figure><h2 id="5、手动清理缓存"><a href="#5、手动清理缓存" class="headerlink" title="5、手动清理缓存"></a>5、手动清理缓存</h2><p>SDWebImage提供了手动清理缓存操作，从SDWebImage的工作原理可以想到清理缓存需清理两处：内存和磁盘。</p><p>注：这里清理的仅仅是SDWebImage的缓存，并没有清理整个app的缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[SDWebImageManager.sharedManager.imageCache clearMemory];</span><br><span class="line">[SDWebImageManager.sharedManager.imageCache clearDiskOnCompletion:nil];</span><br></pre></td></tr></table></figure><hr><h2 id="6、将图片显示到ImgaeView上（Button图片或者背景图的显示和ImageView同理，只是多了几个额外的参数）"><a href="#6、将图片显示到ImgaeView上（Button图片或者背景图的显示和ImageView同理，只是多了几个额外的参数）" class="headerlink" title="6、将图片显示到ImgaeView上（Button图片或者背景图的显示和ImageView同理，只是多了几个额外的参数）"></a>6、将图片显示到ImgaeView上（Button图片或者背景图的显示和ImageView同理，只是多了几个额外的参数）</h2><h3 id="6-1、图片显示动画"><a href="#6-1、图片显示动画" class="headerlink" title="6.1、图片显示动画"></a>6.1、图片显示动画</h3><p>图片显示过渡类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.customImageView.sd_imageTransition = SDWebImageTransition.curlUpTransition;</span><br></pre></td></tr></table></figure></p><p>SDWebImage提供了七种动画过渡类型，分别是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/// Fade transition. 淡出过渡</span><br><span class="line">@property (nonatomic, class, nonnull, readonly) SDWebImageTransition *fadeTransition;</span><br><span class="line">/// Flip from left transition. 从左过渡翻转。</span><br><span class="line">@property (nonatomic, class, nonnull, readonly) SDWebImageTransition *flipFromLeftTransition;</span><br><span class="line">/// Flip from right transition. 从右过渡翻转。</span><br><span class="line">@property (nonatomic, class, nonnull, readonly) SDWebImageTransition *flipFromRightTransition;</span><br><span class="line">/// Flip from top transition. 从顶部过渡翻转。</span><br><span class="line">@property (nonatomic, class, nonnull, readonly) SDWebImageTransition *flipFromTopTransition;</span><br><span class="line">/// Flip from bottom transition. 从底部过渡翻转。</span><br><span class="line">@property (nonatomic, class, nonnull, readonly) SDWebImageTransition *flipFromBottomTransition;</span><br><span class="line">/// Curl up transition. 向上卷起过渡。</span><br><span class="line">@property (nonatomic, class, nonnull, readonly) SDWebImageTransition *curlUpTransition;</span><br><span class="line">/// Curl down transition. 向下卷起过渡。</span><br><span class="line">@property (nonatomic, class, nonnull, readonly) SDWebImageTransition *curlDownTransition;</span><br></pre></td></tr></table></figure><h3 id="6-2、图片加载原理"><a href="#6-2、图片加载原理" class="headerlink" title="6.2、图片加载原理"></a>6.2、图片加载原理</h3><p>SDWebImage加载图片的原理是：</p><h3 id="6-3、图片显示方法"><a href="#6-3、图片显示方法" class="headerlink" title="6.3、图片显示方法"></a>6.3、图片显示方法</h3><p>SDWebImage提供7种方法去显示图片，我们只看第7个，因为其他6种方法最后都是通过该方法图显示图片的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)sd_setImageWithURL:(nullable NSURL *)url</span><br><span class="line">          placeholderImage:(nullable UIImage *)placeholder</span><br><span class="line">                   options:(SDWebImageOptions)options</span><br><span class="line">                  progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                 completed:(nullable SDExternalCompletionBlock)completedBlock;</span><br></pre></td></tr></table></figure><p><strong>通过给定的URL加载图片并将其加载到此imageView中。它适用于静态和动态图像。<br>先从缓存和磁盘中寻找该图片，有则直接显示，无就下载显示并缓存。<br>下载是异步和缓存的，SDWebImage会先显示传入的占位符，直到请求完成</strong></p><h4 id="6-3-1分析参数"><a href="#6-3-1分析参数" class="headerlink" title="6.3.1分析参数"></a>6.3.1分析参数</h4><ol><li>@param url  ：图片URL</li><li>@param placeholder ：占位符（最初要设置的图像，直到图像请求完成。）</li><li>@param options ：下载图像时使用的选项。</li><li>@param progressBlock ：下载图像时调用的block代码块（稍后分析）</li><li>@param completedBlock ： 操作完成时调用的代码块。 该代码块没有返回值（稍后分析）</li></ol><p><strong>解析 options 选项（枚举类型）</strong></p><blockquote><p><code>SDWebImageRetryFailed = 1 &lt;&lt; 0,</code><br>  默认情况下当通过URL下载图片失败后，该URL就被加入黑名单，之后SDWebImage不会再去尝试下载。此标志作用就是禁用该黑名单，也就是说使用SDWebImageRetryFailed后，图片下载失败仍会尝试下载</p><p> <code>SDWebImageLowPriority = 1 &lt;&lt; 1,</code><br>  默认情况下图片在UI交互期间下载，此标志的作用就是禁用该功能。例如：在UIScrollView减速时导致延迟下载。</p><p><code>SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2,</code><br>  此标志作用是：图片下载完成后仅缓存到内存，不缓存在磁盘上</p><p><code>SDWebImageProgressiveDownload = 1 &lt;&lt; 3,</code><br>  此标志启用渐进式下载，图像在下载过程中逐步显示，就像浏览器一样。<br>  默认情况下，图像仅在完全下载后显示。</p><p><code>SDWebImageRefreshCached = 1 &lt;&lt; 4,</code><br>  即使缓存中存在该图片，也尊重HTTP响应缓存控制，在需要时从远程刷新图片。<br>  磁盘缓存将由 <code>NSURLCache</code> 替代 <code>SDWebImage</code> 去处理，这样也将导致性能略有下降。<br>  该选项有助于处理同一个URL请求但更换图片的情况，例如Facebook图形api配置文件的图片。<br>  如果刷新了缓存图片，则使用缓存图片调用一次完成block代码块，再使用最终的图片调用完成block代码块。<br>  仅当你无法使用嵌入式缓存清除参数使URL保持静态时，才使用该标志。</p><p><code>SDWebImageContinueInBackground = 1 &lt;&lt; 5,</code><br>  在<code>iOS 4+</code>中，如果app进入后台也继续下载图片，这是通过询问系统实现的。<br>  在后台有额外的时间让请求完成，如果后台任务到期，则操作被取消。</p><p><code>SDWebImageHandleCookies = 1 &lt;&lt; 6,</code><br>  通过<code>NSMutableURLRequest.HTTPShouldHandleCookies = YES</code>设置处理在 <code>NSHTTPCookieStore</code>中的cookies。</p><p>  <code>SDWebImageAllowInvalidSSLCertificates = 1 &lt;&lt; 7,</code><br>  启用允许不受信任的SSL证书（用于测试目的，在生产中谨慎使用）</p><p><code>SDWebImageHighPriority = 1 &lt;&lt; 8,</code><br>  默认情况下，图像按其排队顺序加载，此标志将它们移动到队列的前面</p><p><code>SDWebImageDelayPlaceholder = 1 &lt;&lt; 9,</code><br>  默认情况下，加载图像时会加载占位符。 此标志将延迟加载占位符图像，直到图像加载完毕。</p><p><code>SDWebImageTransformAnimatedImage = 1 &lt;&lt; 10,</code><br>  我们通常不会在动画图像上调用transformDownloadedImage委托方法，因为大多数转换代码会破坏它。如果使用必须使用此标志来转换它们。  </p><p><code>SDWebImageAvoidAutoSetImage = 1 &lt;&lt; 11,</code><br>  默认情况下，下载后会将图像添加到imageView。 但在某些情况下，我们想要<br>  在设置图像之前手动处理一些东西（例如应用滤镜或添加交叉渐变动画）请使用此标志</p><p><code>SDWebImageScaleDownLargeImages = 1 &lt;&lt; 12,</code><br>  默认情况下，图像会根据其原始大小进行解码。 在iOS上，此标志将缩小<br>  图像尺寸与设备的受限内存兼容。（如果设置了“SDWebImageProgressiveDownload”标志，则停用缩小比例。）</p><p><code>SDWebImageQueryDataWhenInMemory = 1 &lt;&lt; 13,</code><br>  默认情况下，当图像缓存在内存中时，我们不查询磁盘数据。 此掩码可以强制同时查询磁盘数据。<br>  建议将此标志与<code>SDWebImageQueryDiskSync</code>一起使用，以确保图像在同一个runloop中加载。 </p><p><code>SDWebImageQueryDiskSync = 1 &lt;&lt; 14,</code><br>  默认情况下，我们同步查询内存缓存，异步查询磁盘缓存。 此掩码可以强制同步查询磁盘缓存，以确保在同一个runloop中加载映像。<br>  如果禁用内存缓存或在某些其他情况下，此标志可以避免在单元重用期间闪烁。</p><p><code>SDWebImageFromCacheOnly = 1 &lt;&lt; 15,</code><br>  默认情况下，当缓存丢失时，将从网络下载映像。此标志可以阻止网络仅从缓存加载。</p><p><code>SDWebImageForceTransition = 1 &lt;&lt; 16</code><br>  默认情况下，当您使用 <code>SDWebImageTransition</code> 在图像加载完成后进行某些视图转换时，此转换仅适用于从网络下载图像。 此掩码也可以强制为内存和磁盘缓存应用视图转换。</p></blockquote><p><strong>解析progressBlock代码块</strong><br>下载图像时重复调用的代码块,在后台队列上执行,包含三个参数，分别是：<br>NSInteger receivedSize：接收到的图片大小<br>NSInteger expectedSize：预期的图片大小<br>NSURL * _Nullable targetURL：目标图片的URL</p><p><strong>completedBlock代码块</strong><br>包含四个参数：<br>(UIImage <em> _Nullable image, NSError </em> _Nullable error, SDImageCacheType cacheType, NSURL * _Nullable imageURL)</p><ol><li>第一个参数是：请求得到的UIImage，如果请求失败，该图像参数是为nil</li><li>第二个参数： 请求结果中可能包含的NSError</li><li>第三个参数： 是枚举，缓存类型，通过类型判断图片从哪里获取。分三种： SDImageCacheTypeNone 、SDImageCacheTypeDisk、SDImageCacheTypeMemory 。</li><li>第四个参数：图片的URL。</li></ol><p>以下是其他6种显示图片的方法，只做简单的分析：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *通过给定的URL加载图片并将其加载到此imageView中。它适用于静态和动态图像</span><br><span class="line"> * 先从缓存和磁盘中寻找，有则显示，无就下载显示并缓存</span><br><span class="line"> */</span><br><span class="line">- (void)sd_setImageWithURL:(nullable NSURL *)url;</span><br><span class="line"></span><br><span class="line">- (void)sd_setImageWithURL:(nullable NSURL *)url</span><br><span class="line">          placeholderImage:(nullable UIImage *)placeholder ;</span><br><span class="line"></span><br><span class="line">- (void)sd_setImageWithURL:(nullable NSURL *)url</span><br><span class="line">          placeholderImage:(nullable UIImage *)placeholder</span><br><span class="line">                   options:(SDWebImageOptions)options ;</span><br><span class="line"></span><br><span class="line">- (void)sd_setImageWithURL:(nullable NSURL *)url</span><br><span class="line">                 completed:(nullable SDExternalCompletionBlock)completedBlock;</span><br><span class="line"></span><br><span class="line">- (void)sd_setImageWithURL:(nullable NSURL *)url</span><br><span class="line">          placeholderImage:(nullable UIImage *)placeholder</span><br><span class="line">                 completed:(nullable SDExternalCompletionBlock)completedBlock ;</span><br><span class="line"></span><br><span class="line">- (void)sd_setImageWithURL:(nullable NSURL *)url</span><br><span class="line">          placeholderImage:(nullable UIImage *)placeholder</span><br><span class="line">                   options:(SDWebImageOptions)options</span><br><span class="line">                 completed:(nullable SDExternalCompletionBlock)completedBlock;</span><br><span class="line"></span><br><span class="line">- (void)sd_setImageWithURL:(nullable NSURL *)url</span><br><span class="line">          placeholderImage:(nullable UIImage *)placeholder</span><br><span class="line">                   options:(SDWebImageOptions)options</span><br><span class="line">                  progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                 completed:(nullable SDExternalCompletionBlock)completedBlock;</span><br></pre></td></tr></table></figure></p><hr><h2 id="7、图像显示的最终调用方法解析"><a href="#7、图像显示的最终调用方法解析" class="headerlink" title="7、图像显示的最终调用方法解析"></a>7、图像显示的最终调用方法解析</h2><p>通过上面的七种方法来加载图像，其实前6种都是调用第7种完善的方法。而这7种方法都是调用的另一种方法。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)sd_internalSetImageWithURL:(nullable NSURL *)url</span><br><span class="line">                  placeholderImage:(nullable UIImage *)placeholder</span><br><span class="line">                           options:(SDWebImageOptions)options</span><br><span class="line">                      operationKey:(nullable NSString *)operationKey</span><br><span class="line">                     setImageBlock:(nullable SDSetImageBlock)setImageBlock</span><br><span class="line">                          progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                         completed:(nullable SDExternalCompletionBlock)completedBlock</span><br><span class="line">                           context:(nullable NSDictionary&lt;NSString *, id&gt; *)context;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ol><li>@param url  ：图像URL</li><li>@param placeholder ：初始化image，知道图像请求完成</li><li>@param options ：图像下载时的选项</li><li>@param operationKey ：用作操作key的字符串。 如果为nil，将使用类名（ImageView加载图像时直接传的nil，Button加载图像时传【字符串和UIControlState状态的拼接】）</li><li>@param setImageBlock ： 用于自定义设置图像的代码块</li><li>@param progressBlock ： 下载图像时调用的代码块</li><li>@param completedBlock ： 操作完成时调用的代码块。 该块没有返回值</li><li>@param context ： 具有执行特定更改或过程的额外信息的上下文。</li></ol><p>其实可以看出：除了参数4、5、8之外，剩下的都是和ImageView加载图像时参数一样，因为这本就是ImageView加载图像最终调用的方法。而参数4、5、8则是Button加载图像传入的参数，这也证明了代码的高内聚力。</p><p><strong>SDSetImageBlock：</strong><br>包含两个参数：<br>(UIImage <em>image, NSData </em>imageData)<br>我们通常在该回调中自定义图像（比如说压缩、剪切、加滤镜、加蒙层等）<br>或者直接简单的显示图像：<code>[weakSelf setImage:image forState:state];</code></p><p>看下整体的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[self sd_internalSetImageWithURL:url</span><br><span class="line">                    placeholderImage:placeholder</span><br><span class="line">                             options:options</span><br><span class="line">                        operationKey:imageOperationKeyForState(state)</span><br><span class="line">                       setImageBlock:^(UIImage *image, NSData *imageData) &#123;</span><br><span class="line">                           [weakSelf setImage:image forState:state]; //自定义图像</span><br><span class="line">                       &#125;</span><br><span class="line">                            progress:nil</span><br><span class="line">                           completed:completedBlock];</span><br></pre></td></tr></table></figure></p><p> <strong>context ： 上下文信息</strong></p><p>这个是最后才加上的，为的是获取额外的信息（加载的过程信息、更改信息等）</p><h3 id="7-1、分析最终的加载图像的方法"><a href="#7-1、分析最终的加载图像的方法" class="headerlink" title="7.1、分析最终的加载图像的方法"></a>7.1、分析最终的加载图像的方法</h3><p>该方法是针对UIView的子类进行图像加载的（例如：UIImageView、UIButton）<br>下面会拆成代码片段一步一步看</p><h4 id="7-1-1、第一步"><a href="#7-1-1、第一步" class="headerlink" title="7.1.1、第一步"></a>7.1.1、第一步</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static char imageURLKey;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">NSString *validOperationKey = operationKey ?: NSStringFromClass([self class]);</span><br><span class="line">[self sd_cancelImageLoadOperationWithKey:validOperationKey];</span><br><span class="line">objc_setAssociatedObject(self, &amp;imageURLKey, url, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br></pre></td></tr></table></figure><ol><li>初始化一个有效的操作key，如果传入的 <code>operationKey</code> 为nil，则赋值为类名 <code>NSStringFromClass([self class])</code> </li><li>通过 <code>operationKey</code> 从队列中取消正在进行的下载操作。</li><li>最后将该类与图像的URL关联起来，关联类型是 ：<code>OBJC_ASSOCIATION_RETAIN_NONATOMIC</code> (指定对关联对象的强引用。)</li></ol><p>以下列出所有的关联类型</p><table><thead><tr><th style="text-align:left">关联策略</th><th style="text-align:left">等价属性</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">OBJC_ASSOCIATION_ASSIGN</td><td style="text-align:left">@property (assign) or @property (unsafe_unretained)</td><td style="text-align:left">弱引用关联对象</td></tr><tr><td style="text-align:left">OBJC_ASSOCIATION_RETAIN_NONATOMIC</td><td style="text-align:left">@property (strong, nonatomic)</td><td style="text-align:left">强引用关联对象，且为非原子操作</td></tr><tr><td style="text-align:left">OBJC_ASSOCIATION_COPY_NONATOMIC</td><td style="text-align:left">@property (copy, nonatomic)</td><td style="text-align:left">复制关联对象，且为非原子操作</td></tr><tr><td style="text-align:left">OBJC_ASSOCIATION_RETAIN</td><td style="text-align:left">@property (strong, atomic)</td><td style="text-align:left">强引用关联对象，且为原子操作</td></tr><tr><td style="text-align:left">OBJC_ASSOCIATION_COPY</td><td style="text-align:left">@property (copy, atomic)</td><td style="text-align:left">复制关联对象，且为原子操作</td></tr></tbody></table><p>再回到第2条看下怎么通过 <code>operationKey</code> 取消对应正在进行下载的操作（顺便附上加载图像的操作，因为两者正好始和末）：<br>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//设置加载图像的操作</span><br><span class="line">- (void)sd_setImageLoadOperation:(nullable id&lt;SDWebImageOperation&gt;)operation forKey:(nullable NSString *)key &#123;</span><br><span class="line">    if (key) &#123;</span><br><span class="line">        [self sd_cancelImageLoadOperationWithKey:key];</span><br><span class="line">        if (operation) &#123;</span><br><span class="line">            SDOperationsDictionary *operationDictionary = [self sd_operationDictionary];</span><br><span class="line">            @synchronized (self) &#123;</span><br><span class="line">                [operationDictionary setObject:operation forKey:key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//设置取消加载图像的操作</span><br><span class="line">- (void)sd_cancelImageLoadOperationWithKey:(nullable NSString *)key &#123;</span><br><span class="line">    if (key) &#123;</span><br><span class="line">        // Cancel in progress downloader from queue</span><br><span class="line">        SDOperationsDictionary *operationDictionary = [self sd_operationDictionary];</span><br><span class="line">        id&lt;SDWebImageOperation&gt; operation;</span><br><span class="line">        </span><br><span class="line">        @synchronized (self) &#123;</span><br><span class="line">            operation = [operationDictionary objectForKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">        if (operation) &#123;</span><br><span class="line">            if ([operation conformsToProtocol:@protocol(SDWebImageOperation)]) &#123;</span><br><span class="line">                [operation cancel];</span><br><span class="line">            &#125;</span><br><span class="line">            @synchronized (self) &#123;</span><br><span class="line">                [operationDictionary removeObjectForKey:key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>分析：<br><strong>首先</strong>，获取当前的一个 <code>NSMapTable</code> ，可以说是一个广义的字典，官方文档是这样解释 <code>NSMapTable</code> 的：</p><blockquote><p>An NSMapTable is modeled after a dictionary, although, because of its options, is not a dictionary because it will behave differently.  The major option is to have keys and/or values held “weakly” in a manner that entries will be removed at some indefinite point after one of the objects is reclaimed.  In addition to being held weakly, keys or values may be copied on input or may use pointer identity for equality and hashing.<br> An NSMapTable can also be configured to operate on arbitrary pointers and not just objects.We recommend the C function API for “void *” access</p></blockquote><p>大体可以理解为：<br> <code>NSMapTable</code> 是在字典之后的一个可变集合模型化的类，但由于它的选项是使 <code>key</code> 和/或 <code>valus</code> 保持“弱有化”，以便在回收其中一个对象之后在某个不确定点删除条目，所以它不是字典，因为它的行为会有所不同。 除了被弱化之外，可以在输入上复制 <code>key</code> 或 <code>valus</code>，或者可以使用指针标识来进行相等和 <code>hash</code>（散列or哈希）操作。<br> <code>NSMapTable</code> 也可以配置为对任意指针进行操作，而不仅仅是对象。 Apple建议使用C函数API进行 <code>void *</code> 访问。</p><p> SDWebImage是这样定义 <code>NSMapTable</code> 的：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// key is copy, value is weak because operation instance is retained by SDWebImageManager&apos;s runningOperations property</span><br><span class="line">typedef NSMapTable&lt;NSString *, id&lt;SDWebImageOperation&gt;&gt; SDOperationsDictionary;</span><br></pre></td></tr></table></figure></p><p> key使用的是copy，value则使用的是weak，并给出了解释：操作实例由SDWebImageManager的runningOperations属性保留</p><p><strong>注：</strong>获取当前的 <code>NSMapTable</code> ，以下用 <code>operationDictionary</code> 叙述。</p><p> <strong>其次</strong>，将该图像的加载操作存放入 <code>operationDictionary</code> 中，而key正是我们上面分析的 <code>operationKey</code> 。这里为了防止在操作是被篡改，使用 <code>@synchronized</code> 做了互斥锁处理。</p><p> <strong>最后</strong>，现在再看取消加载图像的操作流程就显得清晰了，大体如下：</p><ol><li>获取当前的一个 <code>operationDictionary</code> 通过key取得操作。</li><li>如果该操作存在，就通过 <code>conformsToProtocol:@protocol()</code> 检查对象是否实现了指定协议类的方法。</li><li>如果存在就直接取消，最后从移除 <code>operationDictionary</code> 该操作</li></ol><p><strong>扩展：<code>objc_setAssociatedObject</code></strong></p><ul><li>在 Objective-C 中可以通过 Category 给一个现有的类添加属性，却不能添加实例变量，这成了 Objective-C 的一个明显短板。但可以通过 Associated Objects 来弥补这一不足。</li><li>相关函数：<br>与 Associated Objects 相关的函数主要有三个:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy);</span><br><span class="line">id objc_getAssociatedObject(id object, const void *key);</span><br><span class="line">void objc_removeAssociatedObjects(id object);</span><br></pre></td></tr></table></figure></li></ul><p>在使用是需要引入 <code>objc/runtime.h</code> 头文件</p><ul><li>函数的作用：<br>objc_setAssociatedObject 用于给对象添加关联对象，传入 nil 则可以移除已有的关联对象；<br>objc_getAssociatedObject 用于获取关联对象；<br>objc_removeAssociatedObjects 用于移除一个对象的所有关联对象。</li><li>key值使用：<br>推荐的方法大体有三种：<br>（1）声明 static char kAssociatedObjectKey; 使用 &amp;kAssociatedObjectKey 作为 key 值;<br>（2）声明 static void *kAssociatedObjectKey = &kAssociatedObjectKey; 使用 kAssociatedObjectKey 作为 key 值；<br>（3）用 selector ，使用 getter 方法的名称作为 key 值。</li></ul><p>我们看到的SDWebInage是使用的 <code>static char kAssociatedObjectKey</code> 这种方法。而 <code>static char</code> 这种声明是C语言的写法，意思是：声明一个局部静态变量。</p><p>附上一个讲的很不错的文章：<a href="http://blog.leichunfeng.com/blog/2015/06/26/objective-c-associated-objects-implementation-principle/" target="_blank" rel="noopener">Objective-C Associated Objects 的实现原理</a></p><h4 id="7-1-2、第二步"><a href="#7-1-2、第二步" class="headerlink" title="7.1.2、第二步"></a>7.1.2、第二步</h4><p>代码片段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (!(options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">        dispatch_main_async_safe(^&#123;</span><br><span class="line">            [self sd_setImage:placeholder imageData:nil basedOnClassOrViaCustomSetImageBlock:setImageBlock];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>解析：<br>条件语句判断options选项是否为 <code>SDWebImageDelayPlaceholder</code> 若不是则执行条件语句里的内容。（条件语句中执行的是设置占位符图像，但该选项是延迟占位符加载，所以需要加以判断。）</p><p><code>dispatch_main_async_safe(^{})</code> 宏定义主线程异步安全加载，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#ifndef dispatch_main_async_safe</span><br><span class="line">#define dispatch_main_async_safe(block) dispatch_queue_async_safe(dispatch_get_main_queue(), block)</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifndef dispatch_queue_async_safe</span><br><span class="line">#define dispatch_queue_async_safe(queue, block)\</span><br><span class="line">    if (dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL) == dispatch_queue_get_label(queue)) &#123;\</span><br><span class="line">        block();\</span><br><span class="line">    &#125; else &#123;\</span><br><span class="line">        dispatch_async(queue, block);\</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p><code>dispatch_main_async_safe</code> 安全的分发任务到主线程里面运行<br><code>dispatch_queue_get_label</code> 用来取队列的名字，进而判断如果当前已经是主队列，那么直接执行，否则回调到主队列之后再执行。</p><p>原因是：如果当前队列已经是主队列，那么再调用 <code>dispatch_async(dispatch_get_main_queue(), block)</code>有可能会出现<code>crash</code>。而该方法则很好的做了预防工作。</p><p>下面看条件语句中的执行方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)sd_setImage:(UIImage *)image imageData:(NSData *)imageData basedOnClassOrViaCustomSetImageBlock:(SDSetImageBlock)setImageBlock &#123;</span><br><span class="line">#if SD_UIKIT || SD_MAC</span><br><span class="line">    [self sd_setImage:image imageData:imageData basedOnClassOrViaCustomSetImageBlock:setImageBlock transition:nil cacheType:0 imageURL:nil];</span><br><span class="line">#else</span><br><span class="line">    // watchOS does not support view transition. Simplify the logic</span><br><span class="line">    if (setImageBlock) &#123;</span><br><span class="line">        setImageBlock(image, imageData);</span><br><span class="line">    &#125; else if ([self isKindOfClass:[UIImageView class]]) &#123;</span><br><span class="line">        UIImageView *imageView = (UIImageView *)self;</span><br><span class="line">        [imageView setImage:image];</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该方法目的为了执行加载占位符图像。分了两种情况 <code>iOS和VTOS 、masOS系统</code> 和 其他。分类型的原因 <code>SDWebImage</code> 给了简单说明： <code>watchOS</code> 不支持 <code>view</code> 的翻转动画，所以 <code>SDWebImage</code> 做了一个简单的加载显示处理。而其他类型则和图像URL的加载显示共用了一套方法（具体实现在加载URL图像时细看）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)sd_setImage:(UIImage *)image imageData:(NSData *)imageData basedOnClassOrViaCustomSetImageBlock:(SDSetImageBlock)setImageBlock transition:(SDWebImageTransition *)transition cacheType:(SDImageCacheType)cacheType imageURL:(NSURL *)imageURL</span><br></pre></td></tr></table></figure></p><h4 id="7-1-3、第三步-正式准备加载URL图像"><a href="#7-1-3、第三步-正式准备加载URL图像" class="headerlink" title="7.1.3、第三步 正式准备加载URL图像"></a>7.1.3、第三步 正式准备加载URL图像</h4><p>同样分两种情况，根据所传的 <code>url</code> 是否存在做区分</p><ol><li><strong><code>url</code> 不存在情况</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        dispatch_main_async_safe(^&#123;</span><br><span class="line">#if SD_UIKIT</span><br><span class="line">            [self sd_removeActivityIndicator];</span><br><span class="line">#endif</span><br><span class="line">            if (completedBlock) &#123;</span><br><span class="line">                NSError *error = [NSError errorWithDomain:SDWebImageErrorDomain code:-1 userInfo:@&#123;NSLocalizedDescriptionKey : @&quot;Trying to load a nil url&quot;&#125;];</span><br><span class="line">                completedBlock(nil, error, SDImageCacheTypeNone, url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></li></ol><p>分析：<br>首先确保在线程安全的情况下，如果<code>iOS和VTOS系统</code>就做下移除<strong>加载指示器</strong>操作。<br>如果<code>completedBlock</code>代码块存在，就获取错误信息，执行回调内的操作。<br><code>SDExternalCompletionBlock</code> 的声明:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^SDExternalCompletionBlock)(UIImage * _Nullable image, NSError * _Nullable error, SDImageCacheType cacheType, NSURL * _Nullable imageURL);</span><br></pre></td></tr></table></figure></p><p>下面是url传nil时的情况：<br><img src="http://obzx0h1re.bkt.clouddn.com/SDWebImage_Error.jpg" alt="SDWebImage_Error"></p><ol start="2"><li><strong><code>url</code> 存在情况</strong></li></ol><ul><li>1、如果是<code>iOS和VTOS</code>的系统，则判断使用显示加载指示器，如果显示则创建并添加到View上。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#if SD_UIKIT</span><br><span class="line">        // check if activityView is enabled or not</span><br><span class="line">        if ([self sd_showActivityIndicatorView]) &#123;</span><br><span class="line">            [self sd_addActivityIndicator];</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></li></ul><p>配置加载指示器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[self.customImageView sd_setShowActivityIndicatorView:YES];</span><br><span class="line">[self.customImageView sd_setIndicatorStyle:UIActivityIndicatorViewStyleGray];</span><br></pre></td></tr></table></figure></p><ul><li>2、根据上下文获取 <code>SDWebImageManager</code></li></ul><p>根据上下文（<code>context</code>）获取 <code>SDWebImageManager</code>，没有则创建。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SDWebImageManager *manager;</span><br><span class="line">if ([context valueForKey:SDWebImageExternalCustomManagerKey]) &#123;</span><br><span class="line">    manager = (SDWebImageManager *)[context valueForKey:SDWebImageExternalCustomManagerKey];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    manager = [SDWebImageManager sharedManager];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>SDWebImageManager</code>是 <code>SDWebImage</code> 管理以及操作的类。该类是<code>SDWebImage</code>的核心类，拥有一个SDWebImageCache 和 SDWebImageDownloader 属性，分别用于图片缓存和下载处理。</p><p>关于 <code>SDWebImageManager</code> 这里不细说，分出去单独研究。</p><ul><li>3 加载进度回调（或者说加载进度回调中…）</li></ul><p>下载图像时重复调用该代码块，在后台队列上执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// reset the progress</span><br><span class="line">self.sd_imageProgress.totalUnitCount = 0;</span><br><span class="line">self.sd_imageProgress.completedUnitCount = 0;</span><br><span class="line"></span><br><span class="line">__weak __typeof(self)wself = self;</span><br><span class="line">SDWebImageDownloaderProgressBlock combinedProgressBlock = ^(NSInteger receivedSize, NSInteger expectedSize, NSURL * _Nullable targetURL) &#123;</span><br><span class="line">    wself.sd_imageProgress.totalUnitCount = expectedSize;</span><br><span class="line">    wself.sd_imageProgress.completedUnitCount = receivedSize;</span><br><span class="line">    if (progressBlock) &#123;</span><br><span class="line">        progressBlock(receivedSize, expectedSize, targetURL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>代码块中会判断传入的 <code>progressBlock</code> 是否为空，不为空的话执行回调操作，回调方法中开发者可以处理一些其他操作。看下图：</p><p><img src="http://obzx0h1re.bkt.clouddn.com/SDWebImage_progressBlock.jpg" alt="SDWebImage_progressBlock"></p><h4 id="7-1-4、第四步-加载URL图像"><a href="#7-1-4、第四步-加载URL图像" class="headerlink" title="7.1.4、第四步 加载URL图像"></a>7.1.4、第四步 加载URL图像</h4><p>加载图像的代码比较多，接下来就在代码中加注释分析。<br>加载图像的方法是在 <code>SDWebImageManager</code>类中完成的，这里只是执行加载完成后的代码块中的内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (id &lt;SDWebImageOperation&gt;)loadImageWithURL:(nullable NSURL *)url</span><br><span class="line">                                     options:(SDWebImageOptions)options</span><br><span class="line">                                    progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                   completed:(nullable SDInternalCompletionBlock)completedBlock</span><br></pre></td></tr></table></figure></p><p>加载图像的过程先不去考虑，先看加载完成后的代码块中执行的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">id &lt;SDWebImageOperation&gt; operation = [manager loadImageWithURL:url options:options progress:combinedProgressBlock completed:^(UIImage *image, NSData *data, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123;</span><br><span class="line">        </span><br><span class="line">    __strong __typeof (wself) sself = wself; //代码块中创建强引用</span><br><span class="line">    if (!sself) &#123; return; &#125; //如果强引用的self不存在，退出block</span><br><span class="line">#if SD_UIKIT</span><br><span class="line">    [sself sd_removeActivityIndicator]; //不是iOS and tvOS系统的话，移除加载指示器</span><br><span class="line">#endif</span><br><span class="line">    // if the progress not been updated, mark it to complete state （如果进度未更新，请将其标记为完成状态）</span><br><span class="line">    if (finished &amp;&amp; !error &amp;&amp; sself.sd_imageProgress.totalUnitCount == 0 &amp;&amp; sself.sd_imageProgress.completedUnitCount == 0) &#123;</span><br><span class="line">    //如果加载结束、没错误、sd_imageProgress.totalUnitCount 和 sd_imageProgress.completedUnitCount 都为0，则设置两者的值为未知值</span><br><span class="line">        sself.sd_imageProgress.totalUnitCount = SDWebImageProgressUnitCountUnknown;</span><br><span class="line">        sself.sd_imageProgress.completedUnitCount = SDWebImageProgressUnitCountUnknown;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   是否应该回调CompletedBlock （ 加载完成 或者 传入的 options 选项 为 SDWebImageAvoidAutoSetImage）</span><br><span class="line">    BOOL shouldCallCompletedBlock = finished || (options &amp; SDWebImageAvoidAutoSetImage);</span><br><span class="line">    </span><br><span class="line">    //判断是否应该不设置Image （如果有图片但设置了SDWebImageAvoidAutoSetImage 或者没有图片并且没有设置SDWebImageDelayPlaceholder）</span><br><span class="line">    BOOL shouldNotSetImage = ((image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage)) ||</span><br><span class="line">                              (!image &amp;&amp; !(options &amp; SDWebImageDelayPlaceholder)));</span><br><span class="line">                              </span><br><span class="line">    SDWebImageNoParamsBlock callCompletedBlockClojure = ^&#123;</span><br><span class="line">        //如果view不存在，终止执行</span><br><span class="line">        if (!sself) &#123; return; &#125;</span><br><span class="line">        </span><br><span class="line">        需要设置Image，就刷新视图</span><br><span class="line">        if (!shouldNotSetImage) &#123;</span><br><span class="line">            [sself sd_setNeedsLayout];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //如果传入了completedBlock并且应该回调，则执行回调</span><br><span class="line">        if (completedBlock &amp;&amp; shouldCallCompletedBlock) &#123;</span><br><span class="line">        //回调</span><br><span class="line">            completedBlock(image, error, cacheType, url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    // case 1a: we got an image, but the SDWebImageAvoidAutoSetImage flag is set （我们得到了一个图像，但设置了SDWebImageAvoidAutoSetImage标志）</span><br><span class="line">    // OR</span><br><span class="line">    // case 1b: we got no image and the SDWebImageDelayPlaceholder is not set（我们没有图像，并且没有设置SDWebImageDelayPlaceholder标志）</span><br><span class="line">   </span><br><span class="line">   //如果不需要设置图片就在主线程队列种调用上面生成的完成回调代码块，然后停止执行</span><br><span class="line">    if (shouldNotSetImage) &#123;</span><br><span class="line">        dispatch_main_async_safe(callCompletedBlockClojure);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //初始化变量</span><br><span class="line">    UIImage *targetImage = nil;</span><br><span class="line">    NSData *targetData = nil;</span><br><span class="line">    </span><br><span class="line">    if (image) &#123;</span><br><span class="line">        // case 2a: we got an image and the SDWebImageAvoidAutoSetImage is not set （我们得到了一个图像，并且没有设置SDWebImageAvoidAutoSetImage）</span><br><span class="line">        //如果图片下载成功就将其保存到变量中</span><br><span class="line">        targetImage = image;</span><br><span class="line">        targetData = data;</span><br><span class="line">    &#125; else if (options &amp; SDWebImageDelayPlaceholder) &#123;</span><br><span class="line">        // case 2b: we got no image and the SDWebImageDelayPlaceholder flag is set（我们没有图像，并且设置了SDWebImage Delay Placeholder标志）</span><br><span class="line">        如果图片下载失败并且设置了延迟加载占位符图像，就保存占位符图像</span><br><span class="line">        targetImage = placeholder;</span><br><span class="line">        targetData = nil;</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">#if SD_UIKIT || SD_MAC （iOS and tvOS macOS）</span><br><span class="line">    // check whether we should use the image transition（检查我们是否应该使用图像过渡转换）</span><br><span class="line">    SDWebImageTransition *transition = nil;</span><br><span class="line">    //如果加载结束并且options选项为：SDWebImageForceTransition 或者 缓存类型为：SDImageCacheTypeNone</span><br><span class="line">    if (finished &amp;&amp; (options &amp; SDWebImageForceTransition || cacheType == SDImageCacheTypeNone)) &#123;</span><br><span class="line">    //保存图像过渡转换</span><br><span class="line">        transition = sself.sd_imageTransition;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    dispatch_main_async_safe(^&#123;</span><br><span class="line">    //主线程队列种设置图像</span><br><span class="line">#if SD_UIKIT || SD_MAC （iOS and tvOS macOS）</span><br><span class="line">            设置图像</span><br><span class="line">            [sself sd_setImage:targetImage imageData:targetData basedOnClassOrViaCustomSetImageBlock:setImageBlock transition:transition cacheType:cacheType imageURL:imageURL];</span><br><span class="line">#else</span><br><span class="line">            //iWatchOS系统设置图像</span><br><span class="line">            [sself sd_setImage:targetImage imageData:targetData basedOnClassOrViaCustomSetImageBlock:setImageBlock];</span><br><span class="line">#endif</span><br><span class="line">            //设置完成后调用完成回调代码块</span><br><span class="line">            callCompletedBlockClojure();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;];</span><br><span class="line">    //SDOperationsDictionary存储当前的操作。</span><br><span class="line">    [self sd_setImageLoadOperation:operation forKey:validOperationKey];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面再使用纯描述的方式，过一遍流程：（为了简便，以下：<code>SD_UIKIT || SD_MAC</code> 简称：<code>iOS_tvOS_MAC</code>; <code>SD_MAC</code>简称：<code>MAC</code>  <code>SD_UIKIT</code> 简称 ：<code>iOS_tvOS</code>）</p><p><code>__strong</code>在<code>Block</code>内部修饰的对象,会保证,在使用这个对象在block内,这个对象都不会被释放。</p><p>之前分析过，加载指示器只能在<code>iOS_tvOS</code>的情况下添加，所以加载完成后需要移除。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#if SD_UIKIT</span><br><span class="line">            [sself sd_removeActivityIndicator];</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p><p>如果加载已经完成并且没有错误；iamge进度的总单元和完成单元都是0，就设置<code>imageProgress</code> 的总单元和完成单元值为未知。</p><p>创建 “应该执行完成加载的回调” 和 “不应该设置Image” 两个布尔值。<br><code>SDWebImageAvoidAutoSetImage</code>: 在设置图像之前手动处理一些东西（例如应用滤镜或添加交叉渐变动画）请使用此标志<br><code>SDWebImageDelayPlaceholder</code> : 延迟显示占位符图像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//加载完成 或者 传入的 options 选项为 SDWebImageAvoidAutoSetImage</span><br><span class="line">BOOL shouldCallCompletedBlock = finished || (options &amp; SDWebImageAvoidAutoSetImage);</span><br><span class="line">//图片存在并且选项为 SDWebImageAvoidAutoSetImage 或者 图片不存在并且选项不为SDWebImageDelayPlaceholder</span><br><span class="line">BOOL shouldNotSetImage = ((image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage)) ||</span><br><span class="line">                                    (!image &amp;&amp; !(options &amp; SDWebImageDelayPlaceholder)));</span><br></pre></td></tr></table></figure><p><code>SDWebImageNoParamsBlock</code> 回调<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SDWebImageNoParamsBlock callCompletedBlockClojure = ^&#123;</span><br><span class="line">                if (!sself) &#123; return; &#125;</span><br><span class="line">                if (!shouldNotSetImage) &#123;</span><br><span class="line">                    //需要设置Image</span><br><span class="line">                    [sself sd_setNeedsLayout];</span><br><span class="line">                &#125;</span><br><span class="line">                //completedBlock存在并且需要回调</span><br><span class="line">                if (completedBlock &amp;&amp; shouldCallCompletedBlock) &#123;</span><br><span class="line">                    completedBlock(image, error, cacheType, url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure></p><p>不需要设置Image，执行callCompletedBlockClojure回调代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (shouldNotSetImage) &#123;</span><br><span class="line">     dispatch_main_async_safe(callCompletedBlockClojure);</span><br><span class="line">     return;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>图像和图像Data赋值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">UIImage *targetImage = nil;</span><br><span class="line">NSData *targetData = nil;</span><br><span class="line">if (image) &#123;</span><br><span class="line">    // case 2a: we got an image and the SDWebImageAvoidAutoSetImage is not set</span><br><span class="line">    targetImage = image;</span><br><span class="line">    targetData = data;</span><br><span class="line">&#125; else if (options &amp; SDWebImageDelayPlaceholder) &#123;</span><br><span class="line">    // case 2b: we got no image and the SDWebImageDelayPlaceholder flag is set</span><br><span class="line">    targetImage = placeholder;</span><br><span class="line">    targetData = nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果系统类型为：<code>iOS_tvOS_MAC</code>，图像过渡动画赋值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#if SD_UIKIT || SD_MAC</span><br><span class="line">    // check whether we should use the image transition</span><br><span class="line">    SDWebImageTransition *transition = nil;</span><br><span class="line">    if (finished &amp;&amp; (options &amp; SDWebImageForceTransition || cacheType == SDImageCacheTypeNone)) &#123;</span><br><span class="line">        transition = sself.sd_imageTransition;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p><p>执行异步安全加载，根据不同的系统执行不同的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dispatch_main_async_safe(^&#123;</span><br><span class="line">#if SD_UIKIT || SD_MAC</span><br><span class="line">                [sself sd_setImage:targetImage imageData:targetData basedOnClassOrViaCustomSetImageBlock:setImageBlock transition:transition cacheType:cacheType imageURL:imageURL];</span><br><span class="line">#else</span><br><span class="line">                [sself sd_setImage:targetImage imageData:targetData basedOnClassOrViaCustomSetImageBlock:setImageBlock];</span><br><span class="line">#endif</span><br><span class="line">                callCompletedBlockClojure();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;];</span><br></pre></td></tr></table></figure></p><p>以上就是大体加载图像所展示的流程</p><p>接下来看一下需要动画翻转过渡的代码（可以使用动画过渡的是<code>iOS_tvOS_MAC</code>）<br>其实就是多加了一个转换动画的执行代码。其他的就是UIImageView和UIButton 的图像设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#if SD_UIKIT || SD_MAC</span><br><span class="line">- (void)sd_setImage:(UIImage *)image imageData:(NSData *)imageData basedOnClassOrViaCustomSetImageBlock:(SDSetImageBlock)setImageBlock transition:(SDWebImageTransition *)transition cacheType:(SDImageCacheType)cacheType imageURL:(NSURL *)imageURL &#123;</span><br><span class="line">    UIView *view = self;</span><br><span class="line">    //最终的图像设置block</span><br><span class="line">    SDSetImageBlock finalSetImageBlock;</span><br><span class="line">    //若setImageBlock，说明是Button需要自定义图像。</span><br><span class="line">    if (setImageBlock) &#123;</span><br><span class="line">        finalSetImageBlock = setImageBlock;</span><br><span class="line">    &#125; else if ([view isKindOfClass:[UIImageView class]]) &#123;</span><br><span class="line">    //若View为ImageView，执行block回调，为imageView赋值</span><br><span class="line">        UIImageView *imageView = (UIImageView *)view;</span><br><span class="line">        finalSetImageBlock = ^(UIImage *setImage, NSData *setImageData) &#123;</span><br><span class="line">            imageView.image = setImage;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">#if SD_UIKIT</span><br><span class="line">    else if ([view isKindOfClass:[UIButton class]]) &#123;</span><br><span class="line">     //若View为button，执行block回调，为button赋值</span><br><span class="line">        UIButton *button = (UIButton *)view;</span><br><span class="line">        finalSetImageBlock = ^(UIImage *setImage, NSData *setImageData)&#123;</span><br><span class="line">            [button setImage:setImage forState:UIControlStateNormal];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    </span><br><span class="line">    //动画过渡执行代码</span><br><span class="line">    if (transition) &#123;</span><br><span class="line">#if SD_UIKIT</span><br><span class="line">        [UIView transitionWithView:view duration:0 options:0 animations:^&#123;</span><br><span class="line">            // 0 duration to let UIKit render placeholder and prepares block</span><br><span class="line">            if (transition.prepares) &#123;</span><br><span class="line">                transition.prepares(view, image, imageData, cacheType, imageURL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; completion:^(BOOL finished) &#123;</span><br><span class="line">            [UIView transitionWithView:view duration:transition.duration options:transition.animationOptions animations:^&#123;</span><br><span class="line">                if (finalSetImageBlock &amp;&amp; !transition.avoidAutoSetImage) &#123;</span><br><span class="line">                    finalSetImageBlock(image, imageData);</span><br><span class="line">                &#125;</span><br><span class="line">                if (transition.animations) &#123;</span><br><span class="line">                    transition.animations(view, image);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; completion:transition.completion];</span><br><span class="line">        &#125;];</span><br><span class="line">#elif SD_MAC</span><br><span class="line">        [NSAnimationContext runAnimationGroup:^(NSAnimationContext * _Nonnull prepareContext) &#123;</span><br><span class="line">            // 0 duration to let AppKit render placeholder and prepares block</span><br><span class="line">            prepareContext.duration = 0;</span><br><span class="line">            if (transition.prepares) &#123;</span><br><span class="line">                transition.prepares(view, image, imageData, cacheType, imageURL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; completionHandler:^&#123;</span><br><span class="line">            [NSAnimationContext runAnimationGroup:^(NSAnimationContext * _Nonnull context) &#123;</span><br><span class="line">                context.duration = transition.duration;</span><br><span class="line">                context.timingFunction = transition.timingFunction;</span><br><span class="line">                context.allowsImplicitAnimation = (transition.animationOptions &amp; SDWebImageAnimationOptionAllowsImplicitAnimation);</span><br><span class="line">                if (finalSetImageBlock &amp;&amp; !transition.avoidAutoSetImage) &#123;</span><br><span class="line">                    finalSetImageBlock(image, imageData);</span><br><span class="line">                &#125;</span><br><span class="line">                if (transition.animations) &#123;</span><br><span class="line">                    transition.animations(view, image);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; completionHandler:^&#123;</span><br><span class="line">                if (transition.completion) &#123;</span><br><span class="line">                    transition.completion(YES);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;];</span><br><span class="line">#endif</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (finalSetImageBlock) &#123;</span><br><span class="line">            finalSetImageBlock(image, imageData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>以上就是 <code>SDWebImage</code> 设置图片的整个流程，但只是过了一遍代码而已，内部的实现并没有深入，例如：<code>SDWebImage</code> 的下载、缓存机制。这些都没有深入去了解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SDWebImage整体的框架：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;
      
    
    </summary>
    
    
      <category term="iOS,Objective-C" scheme="http://guohuaden.com/tags/iOS-Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>copy 和 mutableCopy</title>
    <link href="http://guohuaden.com/2018/06/30/copyAndMutableCopy/"/>
    <id>http://guohuaden.com/2018/06/30/copyAndMutableCopy/</id>
    <published>2018-06-30T06:16:37.000Z</published>
    <updated>2018-09-18T03:58:17.166Z</updated>
    
    <content type="html"><![CDATA[<p>今天来谈下深浅拷贝【copy 和 mutableCopy】</p><p>想写这篇文章，是因为看到了一个有意思的文章，对于其中的一些观点不太认同，所以想简单分析一下深浅拷贝</p><p>先看一段代码，稍后会对代码进行分析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-(void)testOne</span><br><span class="line">&#123;</span><br><span class="line">    NSArray *test = @[@1,@2,@3];</span><br><span class="line">    NSLog(@&quot;test-&gt;%p\n&quot;,test);</span><br><span class="line">    NSArray *testCopy = [test copy];</span><br><span class="line">    NSLog(@&quot;testCopy-&gt;%p\n&quot;,testCopy);</span><br><span class="line">    NSArray *testMutableCopy = [test mutableCopy];</span><br><span class="line">    NSLog(@&quot;testMutableCopy-&gt;%p\n&quot;,testMutableCopy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>很简单的创建一个数组，对其进行copy和mutableCopy操作，打印其内存地址。结果看图会知道：<br>test和testCopy 内存地址是一样的，而testMutableCopy的内存地址是和test不同的。</p><p><strong>小总结：</strong></p><ol><li><code>copy</code> 只是拷贝指向对象的指针，并没有出现新的内存地址，我们称之为<strong>浅拷贝</strong>：</li><li><code>mutableCopy</code> 拷贝整个对象内存到另一块内存中，是产生了新的内存地址。</li></ol><p><img src="http://obzx0h1re.bkt.clouddn.com/copyAndMutableCopy_one.png" alt="copy和mutableCopy操作1"></p><hr><p>再看下面的一段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">-(void)testTwo</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;\n&quot;);</span><br><span class="line">    NSMutableArray *test2 = [NSMutableArray arrayWithObjects:@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;, nil];</span><br><span class="line">    NSLog(@&quot;test2-&gt;%p\n&quot;,test2);</span><br><span class="line">    NSMutableArray *testCopy2 = [test2 copy];</span><br><span class="line">    NSLog(@&quot;testCopy2-&gt;%p\n&quot;,testCopy2);</span><br><span class="line">    </span><br><span class="line">    NSMutableArray *testMutableCopy2 = [test2 mutableCopy];</span><br><span class="line">    NSLog(@&quot;testMutableCopy2-&gt;%p\n&quot;,testMutableCopy2);</span><br><span class="line">    </span><br><span class="line">    [test2 addObject:@&quot;A&quot;];</span><br><span class="line">    </span><br><span class="line">    //这里不能对数组做操作， 可变数组的copy属于深拷贝，和mutableCopy一样都是将数组拷贝一份存入新的内存中，但通过mutableCopy得到的可变数组可以再操作，而copy出来的是不可变数组。</span><br><span class="line">//    [testCopy2 removeObject:@&quot;1&quot;];</span><br><span class="line">//    [testCopy2 addObject:@&quot;B&quot;]; </span><br><span class="line">    </span><br><span class="line">    [testMutableCopy2 addObject:@&quot;C&quot;];</span><br><span class="line">    [testMutableCopy2 removeObject:@&quot;3&quot;];</span><br><span class="line">    NSLog(@&quot;test2 = %@, testCopy2 =%@,testMutableCopy2 = %@&quot;,test2,testCopy2,testMutableCopy2);</span><br><span class="line">    </span><br><span class="line">    //打印结果： test2 = @[1,2,3,A]   testCopy2 = @[1,2,3]   testMutableCopy2 = @[1,2,3,C]</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析：</strong><br>上面这段代码会和之前的不一样，我们这里创建的是一个可变数组，然后对可变数组进行<code>copy</code>和<code>mutableCopy</code>操作。发现打印其内存地址都不一样，<br>这说明对可变数组进行<code>copy</code>和<code>mutableCopy</code>都是深拷贝。<br>但你会发现<code>copy</code>得到的数组不能添加删除操作，这是因为<code>copy</code>得到的是不可变数组。</p><p><strong>小总结：</strong></p><p>可变数组的<code>copy</code>和<code>mutableCopy</code>都是深拷贝</p><p><img src="http://obzx0h1re.bkt.clouddn.com/copyAndMutableCopy_two.png" alt="copy和mutableCopy操作2"></p><p>最后一段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-(void)testThree</span><br><span class="line">&#123;</span><br><span class="line">    NSMutableArray *test4 = [NSMutableArray arrayWithObjects:@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;, nil];</span><br><span class="line">    NSMutableArray *newTest = [NSMutableArray arrayWithObject:test4];</span><br><span class="line">    NSMutableArray *testMutableCopy4 = [newTest mutableCopy];//拷贝出来的是NSMutableArray类型数组</span><br><span class="line">    NSLog(@&quot;newTest-&gt;%p,testMutableCopy4-&gt;%p\n&quot;,newTest,testMutableCopy4);</span><br><span class="line">    </span><br><span class="line">    //copy的先不说， 我们看下mutableCopy得到的数组，你会发现通过mutableCopy得到的数组中的元素地址是不变的</span><br><span class="line">    NSLog(@&quot;newTest.first-&gt;%p,testMutableCopy4first-&gt;%p\n&quot;,newTest.firstObject,testMutableCopy4.firstObject);</span><br><span class="line">    </span><br><span class="line">    //test</span><br><span class="line">    [testMutableCopy4.firstObject addObject:@6];</span><br><span class="line">    [newTest.firstObject addObject:@&quot;12&quot;];</span><br><span class="line">    </span><br><span class="line">    //打印出来这里两个数组，会发现结果是一样的，原因就是mutableCopy的深拷贝是容器和其中的元素，但元素的地址并没有改变，修改其中的元素中的内容，结果必然都改变</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;newTest = %@,testMutableCopy2 = %@&quot;,newTest,testMutableCopy4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>通过<code>mutableCopy</code>得到的数组，你会发现通过<code>mutableCopy</code>得到的数组中的元素地址是不变的。如果你往数组的元素中添加或删除元素，会发现newTest和testMutableCopy4中的元素都发生了改变。</p><p><strong>小总结：</strong></p><p>集合对象的内容复制（mutableCopy）仅限于对象本身，对象中的元素仍然是指针复制。</p><p><img src="http://obzx0h1re.bkt.clouddn.com/copyAndMutableCopy_four.png" alt="copy和mutableCopy操作4"></p><p>关于这点其实苹果官网文档中<code>CopyFunctions</code>给了解释，看下以下介绍：</p><p><strong>关于复制的介绍：</strong></p><blockquote><p>Copy Functions<br>In general, a standard copy operation, which might also be called simple assignment, occurs when you use the = operator to assign the value of one variable to another. The expression myInt2 = myInt1, for example, causes the integer contents of myInt1 to be copied from the memory used by myInt1 into the memory used by myInt2. Following the copy operation, two separate areas of memory contain the same value. However, if you attempt to copy a Core Foundation object in this way, be aware that you will not duplicate the object itself, only the reference to the object.</p></blockquote><blockquote><p>For example, someone new to Core Foundation might think that to make a copy of a CFString object she would use the expression myCFString2 = myCFString1. Again, this expression does not actually copy the string data. Because both myCFString1 and myCFString2 must have the CFStringRef type, this expression only copies the reference to the object. Following the copy operation, you have two copies of the reference to the CFString. This type of copy is very fast because only the reference is duplicated, but it is important to remember that copying a mutable object in this way is dangerous. As with programs that use global variables, if one part of your application changes an object using a copy of the reference, there is no way for other parts of the program which have copies of that reference to know that the data has changed.</p></blockquote><blockquote><p>If you want to duplicate an object, you must use one of the functions provided by Core Foundation specifically for this purpose. Continuing with the CFString example, you would use CFStringCreateCopy to create an entirely new CFString object containing the same data as the original. Core Foundation types which have “CreateCopy” functions also provide the variant “CreateMutableCopy” which returns a copy of an object that can be modified.</p></blockquote><p><strong>浅拷贝：</strong></p><blockquote><p>Shallow Copy<br>Copying compound objects, objects such as collection objects that can contain other objects, must also be done with care. As you would expect, using the = operator to perform a copy on these objects results in a duplication of the object reference. In contrast to simple objects like CFString and CFData, the “CreateCopy” functions provided for compound objects such as CFArray and CFSet actually perform a shallow copy. In the case of these objects, a shallow copy means that a new collection object is created, but the contents of the original collection are not duplicated—only the object references are copied to the new container. This type of copy is useful if, for example, you have an array that’s immutable and you want to reorder it. In this case, you don’t want to duplicate all of the contained objects because there’s no need to change them—and why use up that extra memory? You just want the set of included objects to be changed. The same risks apply here as with copying object references with simple types.</p></blockquote><p><strong>深拷贝：</strong></p><blockquote><p>Deep Copy<br>When you want to create an entirely new compound object, you must perform a deep copy. A deep copy duplicates the compound object as well as the contents of all of its contained objects. The current release of Core Foundation includes a function that performs deep copying of a property list (see CFPropertyListCreateDeepCopy). If you want to create deep copies of other structures, you could perform the deep copy yourself by recursively descending into the compound object and copying all of its contents one by one. Take care in implementing this functionality as compound objects can be recursive—they may directly or indirectly contain a reference to themselves—which can cause a recursive loop.</p></blockquote><p>引用自：<a href="https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/CopyFunctions.html#//apple_ref/doc/uid/20001149-CJBEJBHH" target="_blank" rel="noopener">苹果官网文档-CopyFunctions</a></p><p><strong>小总结：</strong></p><p>我们通过对集合类对象进行mutableCopy得到的新对象，从某种意义上来说，并不是真正的深层次的复制，严格意义上说：它只是一个单层次的深复制。原因上面已说明：集合对象的内容复制（mutableCopy）仅限于对象本身，对象中的元素仍然是指针复制。</p><p>那如果需要深层次的复制，就需要以递归的形式找到集合中的元素对象，再对元素对象进行mutableCopy，以此来实现深层次的复制。但Apple并不提倡这种方式，因为这可能会导致递归循环。</p><p>最后总结：</p><ol><li>不管是集合类对象还是非集合类对象，copy和mutableCopy时，都遵循以下准则：<ol><li>copy得到的都是不可变对象（imutable），所以对其copy返回的对象做可变对象的操作，都会崩溃。</li><li>mutableCopy返回的是可变对象（mutable）</li></ol></li><li>在非集合类对象中：<ol><li>对不可变对象进行copy操作，是指针复制，其内存地址不变。</li><li>对不可变对象进行mutableCopy操作，是内容复制，其内存地址改变。</li><li>对可变对象进行copy和mutableCopy操作，都是内容复制，其内存地址改变。</li></ol></li><li>在集合类对象中：<ol><li>对不可变对象进行copy操作，是指针复制，其内存地址不变。</li><li>对不可变对象进行mutableCopy操作，是内容复制，其内存地址改变。</li><li>对可变对象进行copy和mutableCopy操作，都是内容复制，其内存地址改变。但集合对象的内容复制仅限于对象本身，对象中的元素仍然是指针复制。</li></ol></li></ol><p>最后可以看下这个Apple的官方文档《<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Collections/Articles/Copying.html#//apple_ref/doc/uid/TP40010162-SW1" target="_blank" rel="noopener">苹果官网文档-Copying</a>》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天来谈下深浅拷贝【copy 和 mutableCopy】&lt;/p&gt;
&lt;p&gt;想写这篇文章，是因为看到了一个有意思的文章，对于其中的一些观点不太认同，所以想简单分析一下深浅拷贝&lt;/p&gt;
&lt;p&gt;先看一段代码，稍后会对代码进行分析&lt;/p&gt;
&lt;figure class=&quot;highli
      
    
    </summary>
    
      <category term="iOS" scheme="http://guohuaden.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://guohuaden.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>项目总结四</title>
    <link href="http://guohuaden.com/2018/06/03/Project-summary-Four/"/>
    <id>http://guohuaden.com/2018/06/03/Project-summary-Four/</id>
    <published>2018-06-03T04:01:57.000Z</published>
    <updated>2018-09-24T08:37:19.344Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>最近都一直在忙新项目的事，真是倍感身心疲别啊。目前项目终于成型，也算时间宽松渐缓吧，就把项目中遇到的一些问题做个总结。</p><h4 id="1、textField限制输入的位数以及小数点的位数"><a href="#1、textField限制输入的位数以及小数点的位数" class="headerlink" title="1、textField限制输入的位数以及小数点的位数"></a>1、textField限制输入的位数以及小数点的位数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string;</span><br><span class="line">&#123; </span><br><span class="line"> //string就是此时输入的那个字符textField就是此时正在输入的那个输入框返回YES就是可以改变输入框的值NO相反</span><br><span class="line">    NSString * toBeString = [textField.text     stringByReplacingCharactersInRange:range withString:string]; </span><br><span class="line">    // 判断是否输入内容，或者用户点击的是键盘的删除按钮</span><br><span class="line">    if (![string isEqualToString:@&quot;&quot;]) &#123;</span><br><span class="line">        if ([textField isEqual:self.textField]) &#123;</span><br><span class="line">            // 小数点在字符串中的位置 第一个数字从0位置开始</span><br><span class="line">            NSInteger dotLocation = [textField.text rangeOfString:@&quot;.&quot;].location;</span><br><span class="line">            if (dotLocation == NSNotFound &amp;&amp; range.location != 0) &#123;</span><br><span class="line">                //没有小数点,最大数值</span><br><span class="line">                if (range.location &gt;= 9)&#123;</span><br><span class="line">                    NSLog(@&quot;单笔金额不能超过亿位&quot;);</span><br><span class="line">                    if ([string isEqualToString:@&quot;.&quot;] &amp;&amp; range.location == 9) &#123;</span><br><span class="line">                        return YES;</span><br><span class="line">                    &#125;</span><br><span class="line">                    return NO;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //判断输入多个小数点,禁止输入多个小数点</span><br><span class="line">            if (dotLocation != NSNotFound)&#123;</span><br><span class="line">                if ([string isEqualToString:@&quot;.&quot;])return NO;</span><br><span class="line">            &#125;</span><br><span class="line">            //判断小数点后最多两位</span><br><span class="line">            if (dotLocation != NSNotFound &amp;&amp; range.location &gt; dotLocation + 2) &#123; return NO; &#125;</span><br><span class="line">            //判断总长度</span><br><span class="line">            if (textField.text.length &gt; 11) &#123;</span><br><span class="line">                return NO;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、禁用第三方键盘"><a href="#2、禁用第三方键盘" class="headerlink" title="2、禁用第三方键盘"></a>2、禁用第三方键盘</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application shouldAllowExtensionPointIdentifier:(NSString *)extensionPointIdentifier</span><br><span class="line">&#123;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、延迟执行"><a href="#3、延迟执行" class="headerlink" title="3、延迟执行"></a>3、延迟执行</h4><p>取消延迟执行函<code>cancelPreviousPerformRequestsWithTarget</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">延迟执行函数</span><br><span class="line">[self performSelector:@selector(scrollDone) withObject:nil afterDelay:0.5];</span><br><span class="line"></span><br><span class="line">在0.5秒内取消执行函数，带的参数必须一样，才能取消成功</span><br><span class="line">[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(scrollDone) object:nil];</span><br></pre></td></tr></table></figure><h4 id="4、关于浮点数精度问题"><a href="#4、关于浮点数精度问题" class="headerlink" title="4、关于浮点数精度问题"></a>4、关于浮点数精度问题</h4><p>大部分开发是不需要关心浮点数精度问题，但在股票等软件开发中，浮点数精度问题会显得很重要，这时就需要用到十进制数字类<code>NSDecimalNumber</code>，这个类继承自NSNumber，苹果针对浮点类型计算精度问题提供出来的计算类，基于十进制的科学计数法来计算，同时可以指定舍入模式，一般用于货币计算。</p><h4 id="5、判断是否为单页-是就执行js"><a href="#5、判断是否为单页-是就执行js" class="headerlink" title="5、判断是否为单页,是就执行js"></a>5、判断是否为单页,是就执行js</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSString *jsStr=@&quot;if(window.historyBack)historyBack();else window.inject.finish();&quot;;</span><br><span class="line">[_webView evaluateJavaScript:jsStr completionHandler:^(id _Nullable response, NSError * _Nullable error) &#123;</span><br><span class="line">    if (!error) &#123;</span><br><span class="line">        NSLog(@&quot;No error&quot;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        [super leftAction];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><hr><p><strong>注</strong>：先写到这里，其他以后补充。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h3&gt;&lt;p&gt;最近都一直在忙新项目的事，真是倍感身心疲别啊。目前项目终于成型，也算时间宽松渐缓吧，就把项目中遇到的一些问题做个总结。&lt;/p&gt;
&lt;h
      
    
    </summary>
    
      <category term="iOS" scheme="http://guohuaden.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://guohuaden.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS之项目总结三：项目开发中遇到的一些问题及解决方案</title>
    <link href="http://guohuaden.com/2017/10/05/project-summary-Three/"/>
    <id>http://guohuaden.com/2017/10/05/project-summary-Three/</id>
    <published>2017-10-05T03:19:10.000Z</published>
    <updated>2018-08-21T04:58:09.215Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>两年多以来，基本上都是独立开发或者维护项目，不得不自嘲的说挺锻炼人的。最近的一家公司是涉足金融行列的，算是第一次踏足金融吧，过程怎样不说，确实学到了不少东西。</p><p><strong><em>下面就开发第一款金融类项目遇到的问题做一下总结：</em></strong></p><h4 id="1、中文显示标题之类"><a href="#1、中文显示标题之类" class="headerlink" title="1、中文显示标题之类"></a>1、中文显示标题之类</h4><p>我们在项目中调用相册、相机等往往默认的是显示英文，但有时候开发的项目是针对国内的，所以需要中文配合显示，这就需要我们做一下配置。<br>其实很简单：就是在<code>info.plist</code>中允许应用程序获取框架内语言即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Localizedresources can be mixed  YES</span><br><span class="line">Localization native development region  China //en</span><br></pre></td></tr></table></figure><p>图片显示：</p><p><img src="http://obzx0h1re.bkt.clouddn.com/project_summary_lauguageSet.png" alt="允许应用程序获取框架内语言图片"></p><h4 id="2、运行报错问题"><a href="#2、运行报错问题" class="headerlink" title="2、运行报错问题"></a>2、运行报错问题</h4><p>报错信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld: 4 duplicate symbols for architecture arm64 clang: error: linker command failed with exit</span><br></pre></td></tr></table></figure><p>这个是粗心大意而差生的报错，最可能的情况是：引入【.h】文件重复。<br>我们知道iOS不允许在A类中重复引入相同的B类的，使用<code>improt</code>关键字引入头文件时，它会判断是否已经引入，如果引入了一次就不在引入。但并不能直接提示报错，所以在运行时会提示上面的报错信息。所以首先要做的是排查是否重复引入【.h】文件。</p><h4 id="3、在使用jsonModel做项目的数据解析时，出现一个属性名字不确定是否存在的情况"><a href="#3、在使用jsonModel做项目的数据解析时，出现一个属性名字不确定是否存在的情况" class="headerlink" title="3、在使用jsonModel做项目的数据解析时，出现一个属性名字不确定是否存在的情况"></a>3、在使用jsonModel做项目的数据解析时，出现一个属性名字不确定是否存在的情况</h4><p>这个问题是没有技术含量的，遇到了解决就行，方法如下：<br>在【.m】文件中添加下面的方法即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+(BOOL)propertyIsOptional:(NSString*)propertyName</span><br><span class="line">&#123;</span><br><span class="line">  return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、AES加密遇到的和android统一加密模式问题"><a href="#4、AES加密遇到的和android统一加密模式问题" class="headerlink" title="4、AES加密遇到的和android统一加密模式问题"></a>4、AES加密遇到的和<em>android</em>统一加密模式问题</h4><p>这种情况我以前在《<a href="http://guohuaden.com/2016/10/06/DES-encryption/">Base64加密和DES加密、以及JAVA和iOS中DES加密统一性问题</a>》这篇文章中有提到多，主要是iOS这边SDK中只提供了两种模式：</p><pre>@constant   kCCOptionPKCS7Padding   Perform PKCS7 padding.@constant   kCCOptionECBMode        Electronic Code Book Mode.                                    Default is CBC.enum {    / options for block ciphers /    kCCOptionPKCS7Padding   = 0x0001,    kCCOptionECBMode        = 0x0002    / stream ciphers currently have no options /};</pre><p>但安卓的不一样，有十几种左右，所以在开发中一定要和安卓、服务器端做好统一。</p><ol><li>如果使用CBC模式，那直接用：<code>kCCOptionPKCS7Padding</code>即可。</li><li>但如果是ECB模式，就需要做下转变 <code>kCCOptionECBMode | kCCOptionPKCS7Padding</code></li></ol><h4 id="5、服务器端小数显示问题（如：1e-05）"><a href="#5、服务器端小数显示问题（如：1e-05）" class="headerlink" title="5、服务器端小数显示问题（如：1e-05）"></a>5、服务器端小数显示问题（如：1e-05）</h4><p>这个做下处理即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSDecimalNumber *decNumber = [NSDecimalNumber decimalNumberWithString:leastWaveStr];</span><br><span class="line">NSString *numberStr = [decNumber stringValue];</span><br></pre></td></tr></table></figure><p>金融类项目中常用到这个<code>NSDecimalNumber</code> ,用于货币处理 。<br>通过<code>NSDecimalNumber</code>提供的计算方式，可以很好的计算出准确的精度的数据，同时不需要使用格式化输出等。</p><h4 id="6、自定义导航栏按钮不靠左／右问题"><a href="#6、自定义导航栏按钮不靠左／右问题" class="headerlink" title="6、自定义导航栏按钮不靠左／右问题"></a>6、自定义导航栏按钮不靠左／右问题</h4><p>很简单，解决方法，添加一个空的按钮进去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">UIButton *leftButton = [[UIButton alloc]init];</span><br><span class="line">leftButton.frame = CGRectMake(0, 0, 20, 20);</span><br><span class="line">[leftButton setBackgroundImage:[UIImage imageNamed:@&quot;back.png&quot;] forState:UIControlStateNormal];</span><br><span class="line">[leftButton addTarget:self action:@selector(popToLastVC:) forControlEvents:UIControlEventTouchUpInside];</span><br><span class="line">UIBarButtonItem *leftBarButtonItems = [[UIBarButtonItem alloc]initWithCustomView:leftButton];</span><br><span class="line">//解决按钮不靠左 靠右的问题.</span><br><span class="line">UIBarButtonItem *nagetiveSpacer = [[UIBarButtonItemalloc]initWithBarButtonSystemItem:UIBarButtonSystemItemFixedSpace</span><br><span class="line">target:nil action:nil];</span><br><span class="line">nagetiveSpacer.width = -15;//这个值可以根据自己需要自己调整</span><br><span class="line">self.navigationItem.leftBarButtonItems = @[nagetiveSpacer, leftBarButtonItems];</span><br></pre></td></tr></table></figure><h4 id="7、不同屏幕尺寸字体显示字体大小问题"><a href="#7、不同屏幕尺寸字体显示字体大小问题" class="headerlink" title="7、不同屏幕尺寸字体显示字体大小问题"></a>7、不同屏幕尺寸字体显示字体大小问题</h4><p>我们应该清楚，UI设计图大多数是以iPhone6 为模版设计的，但开发中腰考虑不同的屏幕尺寸显示字体大小不同的情况。<br>网上给出的大多数是针对<code>Xib</code>和<code>storyboard</code>做的处理，下面我说一下针对纯代码开发的处理方法。<br>其实很简单，在pch文件中设置宏定义，针对不同的机型做一下简单判断，在开发中使用宏定义字体大小就可以了。<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#define kDevice_Is_iPhone4 ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(640, 960), [[UIScreen mainScreen] currentMode].size) : NO)</span><br><span class="line">#define kDevice_Is_iPhone5 ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(640, 1136), [[UIScreen mainScreen] currentMode].size) : NO)</span><br><span class="line">#define kDevice_Is_iPhone6 ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(750, 1334), [[UIScreen mainScreen] currentMode].size) : NO)</span><br><span class="line">#define kDevice_Is_iPhone6Plus ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(1242, 2208), [[UIScreen mainScreen] currentMode].size) : NO)</span><br><span class="line">//字体大小（以6s为基准,以6p为判断）</span><br><span class="line">#define kFontSize10  kDevice_Is_iPhone6Plus ? 12:10</span><br><span class="line">#define kFontSize11  kDevice_Is_iPhone6Plus ? 13:11</span><br><span class="line">#define kFontSize12  kDevice_Is_iPhone6Plus ? 14:12</span><br><span class="line">#define kFontSize13  kDevice_Is_iPhone6Plus ? 15:13</span><br><span class="line">#define kFontSize14  kDevice_Is_iPhone6Plus ? 16:14</span><br><span class="line">#define kFontSize15  kDevice_Is_iPhone6Plus ? 17:15</span><br><span class="line">#define kFontSize16  kDevice_Is_iPhone6Plus ? 18:16</span><br><span class="line">#define kFontSize17  kDevice_Is_iPhone6Plus ? 19:17</span><br><span class="line">#define kFontSize18  kDevice_Is_iPhone6Plus ? 20:18</span><br><span class="line">#define kFontSize19  kDevice_Is_iPhone6Plus ? 21:19</span><br><span class="line">#define kFontSize20  kDevice_Is_iPhone6Plus ? 22:20</span><br><span class="line">#define kFontSize21  kDevice_Is_iPhone6Plus ? 23:21</span><br><span class="line">#define kFontSize22  kDevice_Is_iPhone6Plus ? 24:22</span><br><span class="line">#define kFontSize23  kDevice_Is_iPhone6Plus ? 25:23</span><br><span class="line">#define kFontSize24  kDevice_Is_iPhone6Plus ? 26:24</span><br><span class="line">#define kFontSize25  kDevice_Is_iPhone6Plus ? 27:25</span><br><span class="line">#define kFontSize34  kDevice_Is_iPhone6Plus ? 35:34</span><br><span class="line">#define kFontSize36  kDevice_Is_iPhone6Plus ? 38:36</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UILabel *label = [UILabel new];</span><br><span class="line">label.text = @&quot;&quot;;</span><br><span class="line">label.textColor = [UIColor darkGrayColor];</span><br><span class="line">label.textAlignment = NSTextAlignmentCenter;</span><br><span class="line">label.font = [UIFont systemFontOfSize:kFontSize16];</span><br><span class="line">[self addSubview:label];</span><br></pre></td></tr></table></figure><p>这样就不需要每次使用字体都判断不同屏幕尺寸了。</p><h4 id="8、view上有tableView，view添加手势后与tableView手势冲突问题"><a href="#8、view上有tableView，view添加手势后与tableView手势冲突问题" class="headerlink" title="8、view上有tableView，view添加手势后与tableView手势冲突问题"></a>8、view上有tableView，view添加手势后与tableView手势冲突问题</h4><p> 解决这个问题，我们需要利用系统的方法做个判断：如果点击了tableView，就不接收Touch点击事件。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> - (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch &#123;</span><br><span class="line">    // 点击的view的类名</span><br><span class="line">    NSLog(@&quot;%@&quot;, NSStringFromClass([touch.view class]));</span><br><span class="line">    // 点击了tableViewCell，view的类名为UITableViewCellContentView，则不接收Touch点击事件</span><br><span class="line">    if ([NSStringFromClass([touch.view class]) isEqualToString:@&quot;UITableViewCellContentView&quot;]) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    return  YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法用来执行点击View的操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - UIGestureRecognizerDelegate methods</span><br><span class="line">-(void)viewtapClicked:(UITapGestureRecognizer *)tap</span><br><span class="line">&#123;</span><br><span class="line">    CGPoint point = [tap locationInView:self];</span><br><span class="line">    BOOL isTouch = CGRectContainsPoint(self.baseView.frame, point);</span><br><span class="line">    if (isTouch) &#123;</span><br><span class="line">        NSLog(@&quot;点击tableView&quot;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        [UIView animateWithDuration:1.0 animations:^&#123;</span><br><span class="line">            [self removeFromSuperview];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9、断网重连后更新界面"><a href="#9、断网重连后更新界面" class="headerlink" title="9、断网重连后更新界面"></a>9、断网重连后更新界面</h4><p>我们在开发项目中，网络状态的监听基本设置在<code>appDelegate</code>中。所以需要在这里针对网络状态做一个广播通知，在需要网络重连后更新界面的地方注册该广播进行界面的刷新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//注册网络监控通知</span><br><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(notificationHandler:) name:kIsNetWork object:nil];</span><br><span class="line">- (void)notificationHandler:(NSNotification *) notification</span><br><span class="line">&#123;</span><br><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">    [self requestHomeInfoData];</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h3&gt;&lt;p&gt;两年多以来，基本上都是独立开发或者维护项目，不得不自嘲的说挺锻炼人的。最近的一家公司是涉足金融行列的，算是第一次踏足金融吧，过程怎样
      
    
    </summary>
    
      <category term="iOS" scheme="http://guohuaden.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://guohuaden.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>WKWebView使用遇到的问题</title>
    <link href="http://guohuaden.com/2017/10/03/WKWebView-issue/"/>
    <id>http://guohuaden.com/2017/10/03/WKWebView-issue/</id>
    <published>2017-10-03T02:30:40.000Z</published>
    <updated>2018-08-21T04:58:56.682Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p><code>WKWebView</code>在iOS8之后正式替代<code>UIWebView</code>，速度方面确实提升了不少。关于<code>WKWebView</code>的简单使用，在《<a href="http://guohuaden.com/2017/02/11/WKWebView/">聊一聊WKWebView</a>》中我已经介绍过了，这里就不再絮叨，本篇主要记录s三个开发中遇到的问题。</p><h4 id="1、去缓存问题"><a href="#1、去缓存问题" class="headerlink" title="1、去缓存问题"></a>1、去缓存问题</h4><p>我们在第一次打开webView后，移动端为了使用的便捷，会在本地做一个缓存，服务器端也有类似的缓存。但有时服务器端更改信息或者web端更改界面信息。我们往往打开移动端的webView界面，仍然是原来的界面状态，这就是缓存机制造成的现象。<br>解决方法：如果不考虑流量，则需要在请求时忽略本地和远程的缓存即可,使用<code>NSURLRequestReloadIgnoringLocalAndRemoteCacheData</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSURLRequest *request = [[NSURLRequest alloc]initWithURL:[NSURL URLWithString:url] cachePolicy:NSURLRequestReloadIgnoringLocalAndRemoteCacheData timeoutInterval:20];</span><br><span class="line">[self.webView loadRequest:request];</span><br></pre></td></tr></table></figure><p>这里附上iOS提供的请求缓存类型:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSUInteger, NSURLRequestCachePolicy)</span><br><span class="line">&#123;</span><br><span class="line">    NSURLRequestUseProtocolCachePolicy = 0,</span><br><span class="line">    NSURLRequestReloadIgnoringLocalCacheData = 1,</span><br><span class="line">    NSURLRequestReloadIgnoringLocalAndRemoteCacheData = 4, // Unimplemented</span><br><span class="line">    NSURLRequestReloadIgnoringCacheData = NSURLRequestReloadIgnoringLocalCacheData,</span><br><span class="line">    NSURLRequestReturnCacheDataElseLoad = 2,</span><br><span class="line">    NSURLRequestReturnCacheDataDontLoad = 3,</span><br><span class="line">    NSURLRequestReloadRevalidatingCacheData = 5, // Unimplemented</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也可以看看这篇文章：《<a href="http://www.cnblogs.com/lolDragon/p/6774509.html" target="_blank" rel="noopener">iOS webview加载时序和缓存问题总结</a>》</p><h4 id="2、拦截WKWebView中界面的URL，自己进行处理跳转（例如跳转到appstore、支付宝等）"><a href="#2、拦截WKWebView中界面的URL，自己进行处理跳转（例如跳转到appstore、支付宝等）" class="headerlink" title="2、拦截WKWebView中界面的URL，自己进行处理跳转（例如跳转到appstore、支付宝等）"></a>2、拦截WKWebView中界面的URL，自己进行处理跳转（例如跳转到appstore、支付宝等）</h4><p>如果在<code>webView</code>界面中有跳转<code>appstore</code>、支付宝等调手机中app的点击按钮时，如果iOS端不做处理的话，是调不起来手机中的app的。<br>我们需要做的就是在代理方法中截取<code>webView</code>的<code>url</code>，再使用iOS的代码进行跳转。<br>例如打开<code>appstore</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler</span><br><span class="line">&#123;</span><br><span class="line">    NSURL *url = navigationAction.request.URL;</span><br><span class="line">    UIApplication *app = [UIApplication sharedApplication];</span><br><span class="line">    // 打开appstore</span><br><span class="line">    if ([url.absoluteString containsString:@&quot;https://itunes.apple.com/&quot;])&#123;</span><br><span class="line">        if ([app canOpenURL:url])&#123;</span><br><span class="line">            [[UIApplication sharedApplication] openURL:url];</span><br><span class="line">            decisionHandler(WKNavigationActionPolicyCancel);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    decisionHandler(WKNavigationActionPolicyAllow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、在WKWebView中点击事件需要上传cookie中的数据，但cookie数据有问题"><a href="#4、在WKWebView中点击事件需要上传cookie中的数据，但cookie数据有问题" class="headerlink" title="4、在WKWebView中点击事件需要上传cookie中的数据，但cookie数据有问题"></a>4、在WKWebView中点击事件需要上传cookie中的数据，但cookie数据有问题</h4><p>开发中发现，在WKWebView中点击获取验证码等失败（抓包工具查看，发现需要和请求一块上传cookie中的数据，实际并没有上传或者数据丢失一部分）</p><p>在WKWebView中，cookie的是需要我们自己去设置的，这一点和UIWebView不同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-(void)setUIWebviewcookie&#123;</span><br><span class="line">    NSHTTPCookieStorage *cs = [NSHTTPCookieStorage sharedHTTPCookieStorage];</span><br><span class="line">    [cs setCookieAcceptPolicy:NSHTTPCookieAcceptPolicyAlways];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在webView响应请求的代理方法中，查看cookie</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler&#123;</span><br><span class="line">    NSHTTPURLResponse *response = (NSHTTPURLResponse *)navigationResponse.response;</span><br><span class="line">    NSArray *cookies =[NSHTTPCookie cookiesWithResponseHeaderFields:[response allHeaderFields] forURL:response.URL];</span><br><span class="line">    //读取wkwebview中的cookie 方法1</span><br><span class="line">    for (NSHTTPCookie *cookie in cookies) &#123;</span><br><span class="line">        //[[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookie:cookie];</span><br><span class="line">        NSLog(@&quot;wkwebview中的cookie:%@&quot;, cookie);</span><br><span class="line">    &#125;</span><br><span class="line">    //读取wkwebview中的cookie 方法2 读取Set-Cookie字段</span><br><span class="line">    NSString *cookieString = [[response allHeaderFields] valueForKey:@&quot;Set-Cookie&quot;];</span><br><span class="line">    NSLog(@&quot;wkwebview中的cookie:%@&quot;, cookieString);</span><br><span class="line">    //看看存入到了NSHTTPCookieStorage了没有</span><br><span class="line">    NSHTTPCookieStorage *cookieJar2 = [NSHTTPCookieStorage sharedHTTPCookieStorage];</span><br><span class="line">    for (NSHTTPCookie *cookie in cookieJar2.cookies) &#123;</span><br><span class="line">        NSLog(@&quot;NSHTTPCookieStorage中的cookie%@&quot;, cookie);</span><br><span class="line">    &#125;</span><br><span class="line">    decisionHandler(WKNavigationResponsePolicyAllow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h3&gt;&lt;p&gt;&lt;code&gt;WKWebView&lt;/code&gt;在iOS8之后正式替代&lt;code&gt;UIWebView&lt;/code&gt;，速度方面确实提升了不
      
    
    </summary>
    
      <category term="iOS" scheme="http://guohuaden.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://guohuaden.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>一个自定义的搜索框：GH_SearchView</title>
    <link href="http://guohuaden.com/2017/05/20/GH-SearchView/"/>
    <id>http://guohuaden.com/2017/05/20/GH-SearchView/</id>
    <published>2017-05-20T05:46:13.000Z</published>
    <updated>2018-08-21T04:57:49.367Z</updated>
    
    <content type="html"><![CDATA[<p>对于iOS自带的搜索框，其实我用着也挺好的，但低版本的使用：  高版本的使用:UISearchController，两个难有个统一。很多项目中都是将着两套代码都写入项目中去，这样做难免显得代码冗余。所以就简单的自定义个搜索框。</p><p><a href="https://github.com/Wheat-Qin/GH_SearchView" target="_blank" rel="noopener">下载地址：https://github.com/Wheat-Qin/GH_SearchView  【支持pods】</a></p><p>怎样使用<code>‘GH_SearchView’:</code></p><p>安装CocoaPods：<code>pod ‘GH_SearchView’ </code></p><p>手动倒入：<br>拖动<code>GH_SearchView</code>文件夹中的所有文件到工程项目中</p><p>引入主要文件：<code>#import “GH_SearchView.h”</code></p><p>使用时实现起来也很简单，一句代码创建：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GH_SearchView *searchView_1 = [[GH_SearchView alloc]initWithFrame:CGRectMake(10, 80, IPHONE_WIDTH-20, 44.f) withTarget:self backgroundColor:[UIColor redColor] placeholderContent:@&quot;请输入搜索内容&quot; searchImage:@&quot;GH_search&quot; withTableView:nil];</span><br><span class="line"> </span><br><span class="line">//自定制取消按钮字体颜色</span><br><span class="line">[searchView_1  setCancelButtonTitleColor:[UIColor blueColor]];</span><br><span class="line">//设置背景色透明度</span><br><span class="line">[searchView_1 setBackgroundColorWithAlphaComponent:0.5];</span><br><span class="line">//设置激活状态</span><br><span class="line">[searchView_1 setSearchActiveState:YES];</span><br><span class="line">    </span><br><span class="line">[self.view addSubview:searchView_1];</span><br><span class="line">//或者</span><br><span class="line">//self.tableView.tableHeaderView = self.searchView;</span><br></pre></td></tr></table></figure><p>使用时需遵守<code>GH_searchDelegate</code>协议。<br>其中必需实现的协议方法有一种:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 搜索按钮</span><br><span class="line"></span><br><span class="line"> @param content 搜索的内容</span><br><span class="line"> */</span><br><span class="line">-(void)searchClickedWithContent:(NSString *)content;</span><br></pre></td></tr></table></figure><p>可选的协议方法有三种:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 实时搜索协议方法</span><br><span class="line"> @param content 搜索的内容</span><br><span class="line"> */</span><br><span class="line">-(void)searchBoxContentDidChange:(NSString *)content;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 搜索框开始输入</span><br><span class="line"> @param content 搜索的内容</span><br><span class="line"> */</span><br><span class="line">-(void)searchDidBeginEditing:(NSString *)content;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 搜索框输入结束</span><br><span class="line"> @param content 搜索的内容</span><br><span class="line"> */</span><br><span class="line">-(void)searchDidEndEditing:(NSString *)content;</span><br></pre></td></tr></table></figure><p>效果图如下：<br>无tableView情况下：<br><img src="http://obzx0h1re.bkt.clouddn.com/GH_searchView_1.png" alt="GH_searchView_1"></p><p>有tableView情况下：<br><img src="http://obzx0h1re.bkt.clouddn.com/GH_searchView_2.png" alt="GH_searchView_2"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于iOS自带的搜索框，其实我用着也挺好的，但低版本的使用：  高版本的使用:UISearchController，两个难有个统一。很多项目中都是将着两套代码都写入项目中去，这样做难免显得代码冗余。所以就简单的自定义个搜索框。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https:/
      
    
    </summary>
    
      <category term="iOS" scheme="http://guohuaden.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://guohuaden.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>利用通知(NSNotificationCenter)获取键盘的高度,以及显示和隐藏键盘时修改界面的注意事项</title>
    <link href="http://guohuaden.com/2017/04/30/get-keyboard-height/"/>
    <id>http://guohuaden.com/2017/04/30/get-keyboard-height/</id>
    <published>2017-04-30T02:42:19.000Z</published>
    <updated>2018-08-21T04:57:51.076Z</updated>
    
    <content type="html"><![CDATA[<p>我们在开发中会遇到这样的情况：调用键盘时需要界面有一个调整，避免键盘遮掩输入框。</p><p>但实现时你会发现，在不同的手机上键盘的高度是不同的。这里列举一下：</p><pre>//获取键盘的高度/* iphone 6: 中文 2014-12-31 11:16:23.643 Demo[686:41289] 键盘高度是  258 2014-12-31 11:16:23.644 Demo[686:41289] 键盘宽度是  375 英文 2014-12-31 11:55:21.417 Demo[1102:58972] 键盘高度是  216 2014-12-31 11:55:21.417 Demo[1102:58972] 键盘宽度是  375 iphone  6 plus： 英文： 2014-12-31 11:31:14.669 Demo[928:50593] 键盘高度是  226 2014-12-31 11:31:14.669 Demo[928:50593] 键盘宽度是  414 中文： 2015-01-07 09:22:49.438 Demo[622:14908] 键盘高度是  271 2015-01-07 09:22:49.439 Demo[622:14908] 键盘宽度是  414 iPhone 7 2016-11-13 17:44:48.315 LoginDemo[2431:120937] 键盘高度是  258 2016-11-13 17:44:48.316 LoginDemo[2431:120937] 键盘宽度是  375 iPhone 7 Plus 2016-11-13 17:43:20.683 LoginDemo[2322:119257] 键盘高度是  271 2016-11-13 17:43:20.683 LoginDemo[2322:119257] 键盘宽度是  414 iphone 5 : 2014-12-31 11:19:36.452 Demo[755:43233] 键盘高度是  216 2014-12-31 11:19:36.452 Demo[755:43233] 键盘宽度是  320 ipad Air： 2014-12-31 11:28:32.178 Demo[851:48085] 键盘高度是  264 2014-12-31 11:28:32.178 Demo[851:48085] 键盘宽度是  768 ipad2 ： 2014-12-31 11:33:57.258 Demo[1014:53043] 键盘高度是  264 2014-12-31 11:33:57.258 Demo[1014:53043] 键盘宽度是  768 */</pre> 我们看出不同的手机设备键盘的高度是不同的，而且英文和中文键盘的高度也是不一样的。 下面我们说一下利用通知来获取键盘的高度：<pre>//增加监听，当键盘出现或改变时收出消息[[NSNotificationCenter defaultCenter] addObserver:self                                      selector:@selector(keyboardWillShow:)                                      name:UIKeyboardWillShowNotification                                      object:nil];//增加监听，当键退出时收出消息[[NSNotificationCenter defaultCenter] addObserver:self                                      selector:@selector(keyboardWillHide:)                                      name:UIKeyboardWillHideNotification                                      object:nil];</pre> 显示键盘的代码： <pre>- (void)keyboardWillShow:(NSNotification *)aNotification{    //获取键盘的高度    NSDictionary *userInfo = [aNotification userInfo];    NSValue *aValue = [userInfo objectForKey:UIKeyboardFrameEndUserInfoKey];    CGRect keyboardRect = [aValue CGRectValue];    int height = keyboardRect.size.height;    int width = keyboardRect.size.width;    NSLog(@"键盘高度是  %d",height);    NSLog(@"键盘宽度是  %d",width);}</pre><p>隐藏键盘的高度：</p><pre>//当键盘隐藏的时候- (void)keyboardWillBeHidden:(NSNotification*)aNotification{     //do something}</pre><p> 当然在注册通知(NSNotificationCenter)后，记得最后的注销通知：</p><pre>-(void)viewWillDisappear:(BOOL)animated{    [[NSNotificationCenter defaultCenter] removeObserver:self];}</pre><p>注意⚠️：切换键盘时也会产生UIKeyboardWillShowNotification，所以很可能方法被调用多次。最好在keyboardWillShow中不要写与调用次数有关的代码。在键盘第一次产生时，如果不是默认的英文键盘也会调用多次方法。</p><p> 比如：</p><pre>#pragma mark -  ******************打开键盘********- (void) keyboardWillShowOfFeedBackVC:(NSNotification *)notify {    //这样写是不正确的：因为切换中英文键盘时都会调用该方法。//    CGRect frame = self.view.frame;//    frame.origin.y = self.view.frame.origin.y - 64;//    self.view.frame = frame;    self.view.frame = CGRectMake(0, -40, IPHONE_WIDTH, IPHONE_HEIGHT);}</pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们在开发中会遇到这样的情况：调用键盘时需要界面有一个调整，避免键盘遮掩输入框。&lt;/p&gt;
&lt;p&gt;但实现时你会发现，在不同的手机上键盘的高度是不同的。这里列举一下：&lt;/p&gt;
&lt;pre&gt;
//获取键盘的高度
/*
 iphone 6:
 中文
 2014-12-31 11:16
      
    
    </summary>
    
      <category term="iOS" scheme="http://guohuaden.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://guohuaden.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>统计项目代码量</title>
    <link href="http://guohuaden.com/2017/04/29/Project-code-number/"/>
    <id>http://guohuaden.com/2017/04/29/Project-code-number/</id>
    <published>2017-04-29T01:48:46.000Z</published>
    <updated>2018-08-21T04:57:41.202Z</updated>
    
    <content type="html"><![CDATA[<p>有遇到过这样的情况，项目经理在写文档时会要求开发人员提供项目的代码量。下面就说一下代码量的统计问题。</p><h4 id="1、统计总的代码量（代码的行数）"><a href="#1、统计总的代码量（代码的行数）" class="headerlink" title="1、统计总的代码量（代码的行数）"></a>1、统计总的代码量（代码的行数）</h4><p>在终端中，cd 到项目文件夹；输入下面的指令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;*.m&quot; -or -name &quot;*.h&quot; -or -name &quot;*.xib&quot; -or -name &quot;*.c&quot; |xargs grep -v &quot;^$&quot;|wc -l</span><br></pre></td></tr></table></figure><p>该指令是统计总共的代码量，并不统计具体的文件代码<br>其中<code>grep -v “^$”</code>：去除空行</p><p>注释是包含在代码量中的，这一点要注意。</p><p>统计效果图：<br><img src="http://obzx0h1re.bkt.clouddn.com/ProjectCodeTotal.png" alt="统计总的代码量"></p><h4 id="2、统计每个文件的代码量（代码的行数）"><a href="#2、统计每个文件的代码量（代码的行数）" class="headerlink" title="2、统计每个文件的代码量（代码的行数）"></a>2、统计每个文件的代码量（代码的行数）</h4><p>在终端中，cd 到项目文件夹；输入下面的指令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;*.m&quot; -or -name &quot;*.h&quot; -or -name &quot;*.xib&quot; -or -name &quot;*.c&quot; |xargs wc -l</span><br></pre></td></tr></table></figure></p><p>该指令会统计具体的文件代码行数。</p><p>统计效果图：<br><img src="http://obzx0h1re.bkt.clouddn.com/ProjectCodeNumber1.png" alt="统计每个文件的代码量1"></p><p><img src="http://obzx0h1re.bkt.clouddn.com/ProjectCodeNumber2.png" alt="统计每个文件的代码量2"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有遇到过这样的情况，项目经理在写文档时会要求开发人员提供项目的代码量。下面就说一下代码量的统计问题。&lt;/p&gt;
&lt;h4 id=&quot;1、统计总的代码量（代码的行数）&quot;&gt;&lt;a href=&quot;#1、统计总的代码量（代码的行数）&quot; class=&quot;headerlink&quot; title=&quot;1、
      
    
    </summary>
    
      <category term="统计代码量" scheme="http://guohuaden.com/categories/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E9%87%8F/"/>
    
    
      <category term="iOS and Swift" scheme="http://guohuaden.com/tags/iOS-and-Swift/"/>
    
  </entry>
  
  <entry>
    <title>iOS中关于图片、PDF等文件加密</title>
    <link href="http://guohuaden.com/2017/04/27/fileEncryptionAndDecryption/"/>
    <id>http://guohuaden.com/2017/04/27/fileEncryptionAndDecryption/</id>
    <published>2017-04-27T03:20:25.000Z</published>
    <updated>2018-08-21T04:57:52.719Z</updated>
    
    <content type="html"><![CDATA[<p>这里加密使用的是三方库：<code>RNCryptor</code>,它是一个跨语言AES加密/解密库。</p><p>主要目标是<code>Swift</code>和<code>Objective-C</code>，但<code> C </code>,<code>C ++</code>,<code>C＃</code>,<code> Erlang </code>,<code> Go </code>,<code> Haskell </code>,<code> Java </code>,<code> PHP </code>,<code> Python </code>,<code> Javascript </code>和<code> Ruby </code>中都有实现。</p><p>RNCryptor地址：</p><p><a href="https://github.com/RNCryptor/RNCryptor" target="_blank" rel="noopener">RNCryptor ：https://github.com/RNCryptor/RNCryptor</a></p><p>以及OC专用的地址:</p><p><a href="https://github.com/RNCryptor/RNCryptor-objc" target="_blank" rel="noopener">RNCryptor-objc ：https://github.com/RNCryptor/RNCryptor-objc</a></p><p>下面就用到的图片和PDF文件加密做一下简单的介绍。</p><h4 id="1、图片加解密"><a href="#1、图片加解密" class="headerlink" title="1、图片加解密"></a>1、图片加解密</h4><p>这个没有什么思想可言，直接看下代码</p><pre>#pragma  mark --Image加解密-(void)imageEncryptionAndDecryption{    NSData *data = [NSData dataWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"default.jpg" ofType:nil]];    NSError *error;    //加密    NSData *encryptedData = [RNEncryptor encryptData:data withSettings:kRNCryptorAES256Settings password:aPassword error:&error ];    if (!error) {        NSLog(@"^_^ 加密成功 ……——(^_^)\n");//        NSLog(@"encryptedData==%@",encryptedData);    }    //解密    NSData *decryptedData = [RNDecryptor decryptData:encryptedData withPassword:aPassword error:&error];    if (!error) {        NSLog(@"^_^ 解密成功 ……——(^_^)\n");//        NSLog(@"decryptedData==%@",decryptedData);        self.imageView.image = [UIImage imageWithData:decryptedData];    }  }</pre><h4 id="2、PDF加解密"><a href="#2、PDF加解密" class="headerlink" title="2、PDF加解密"></a>2、PDF加解密</h4><p>考虑到PDF文件可能较大的原因，这里在加解密时使用了子线程，以避免加解密过程耗时。</p><p>另：PDF查看需要提供路径，而这也是关键。</p><p>思路：</p><ol><li>将网络请求下来的数据流（NSData）直接进行加密，加密成功后存入沙盒目录中。</li><li>在查看PDF时,先对加密的PDF进行解密，再将解密的PDF存入沙盒目录中（区分加解密PDF文件）。</li><li>获取解密的PDF文件路径，查看PDF文件。</li><li>退出查看当前的PDF文件时，删除解密后的PDF文件缓存，保留加密的PDF缓存。</li></ol><p>查看代码：</p><p><strong>加密</strong></p><pre>#pragma mark --PDF加密-(void)PDFEncryption{    __block NSData *encryptedData;    __block NSError *error;    NSString *filePath = [[NSBundle mainBundle]pathForResource:@"11.pdf" ofType:nil];    NSString *fileEncryPath = [NSHomeDirectory()stringByAppendingPathComponent:@"/Documents/TKAMC.qgh"];    NSFileManager *fileManager = [NSFileManager defaultManager];    //判断是否已存在加密文件，若存在直接执行解密过程。    if ([fileManager fileExistsAtPath:fileEncryPath]) {        [self PDFDecryptedData:[NSData dataWithContentsOfFile:fileEncryPath]];        return;    }    //异步去加密，防止占用太多内存    dispatch_async(dispatch_get_global_queue(0, 0), ^{        NSData *data = [NSData dataWithContentsOfFile:filePath];        //加密        encryptedData = [RNEncryptor encryptData:data withSettings:kRNCryptorAES256Settings password:aPassword error:&error ];        if (!error) {            NSLog(@"^_^ PDF加密成功 ……——(^_^)\n");//            NSLog(@"encryptedData==%@",encryptedData);        }        //在主线程上写入文件        dispatch_sync(dispatch_get_main_queue(), ^{            BOOL yes = [encryptedData writeToFile:fileEncryPath atomically:NO];            if (yes) {                NSLog(@"加密文件写入成功");            }else{                NSLog(@"加密文件写入失败");            }            NSLog(@"写入PDF路径：%@",fileEncryPath);            [self PDFDecryptedData:encryptedData];        });    });}</pre><p><strong>解密</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark ---PDF解密</span><br><span class="line">-(void)PDFDecryptedData:(NSData *)encryptedData&#123;</span><br><span class="line"></span><br><span class="line">    NSString *fileDecryPath = [NSHomeDirectory()stringByAppendingPathComponent:@&quot;/Documents/TKAMC&quot;];</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">        //    解密</span><br><span class="line">        NSError *error;</span><br><span class="line">        </span><br><span class="line">        if (encryptedData != nil || aPassword != nil) &#123;</span><br><span class="line">            NSData *decryptedData = [RNDecryptor decryptData:encryptedData</span><br><span class="line">                                                withPassword:aPassword</span><br><span class="line">                                                       error:&amp;error];</span><br><span class="line">            </span><br><span class="line">            dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                 BOOL yes = [decryptedData writeToFile:fileDecryPath atomically:NO];</span><br><span class="line">                if (yes) &#123;</span><br><span class="line">                    NSLog(@&quot;解密文件写入成功&quot;);</span><br><span class="line">                    NSLog(@&quot;写入解密PDF路径：%@&quot;,fileDecryPath);</span><br><span class="line">                    self.filepath = fileDecryPath;</span><br><span class="line">                    [self pushVC];</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    NSLog(@&quot;解密文件写入失败&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            NSLog(@&quot;加密数据为空&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="#FF6347"><strong>注：</strong></font>这里加解密时并没有具体实现网络请求模块，只是简单的对本地文件进行了实践，但大体实现过程已经实现。</p><p><strong>退出PDF时，删除解密的PDF文件</strong></p><pre>#pragma mark - ReaderViewControllerDelegate methods- (void)dismissReaderViewController:(ReaderViewController *)viewController{    //MARK:退出查看PDF时删除解密存储文件。    NSFileManager *fileManager = [NSFileManager defaultManager];    [fileManager removeItemAtPath:self.filepath error:nil];    [self dismissViewControllerAnimated:YES completion:nil];}</pre><hr><p>这里提供一个个人测试使用的一个Demo，仅供参考</p><p><a href="https://github.com/Wheat-Qin/FileEncryption_Demo" target="_blank" rel="noopener">FileEncryption_Demo ：https://github.com/Wheat-Qin/FileEncryption_Demo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里加密使用的是三方库：&lt;code&gt;RNCryptor&lt;/code&gt;,它是一个跨语言AES加密/解密库。&lt;/p&gt;
&lt;p&gt;主要目标是&lt;code&gt;Swift&lt;/code&gt;和&lt;code&gt;Objective-C&lt;/code&gt;，但&lt;code&gt; C &lt;/code&gt;,&lt;code&gt;C ++
      
    
    </summary>
    
      <category term="iOS" scheme="http://guohuaden.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://guohuaden.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Xcode中常用的标记(MARK、TODO、FIXME)</title>
    <link href="http://guohuaden.com/2017/04/22/MARK-TODO-FIXME/"/>
    <id>http://guohuaden.com/2017/04/22/MARK-TODO-FIXME/</id>
    <published>2017-04-22T05:55:39.000Z</published>
    <updated>2018-08-21T04:57:43.213Z</updated>
    
    <content type="html"><![CDATA[<p>在项目中以<code>ViewController</code>界面为例，在创建很多方法的情况下，会导致代码在翻阅时很浪费时间。但我们也是有对应的便捷方法。例如：<code>#pragma mark</code>以及 打断点引起注意的方式都可以达到我们想要的效果。</p><p>但细心的开发者会注意到，苹果提供了三个标记(<code>MARK、TODO、FIXME</code>)来给我们提供便利。至于用法也是很简单，和<code>#pragma mark</code>类似。下面👇做解释：</p><p><strong>MARK:标注</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//MARK:视图将要消失（viewWillDisappear）</span><br><span class="line">- (void)viewWillDisappear:(BOOL)animated&#123;</span><br><span class="line">    [super viewWillDisappear:animated];</span><br><span class="line">    [[NSNotificationCenter defaultCenter] removeObserver:self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>TODO:备忘录</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//TODO: back super ViewController(返回上级视图)</span><br><span class="line">- (void)goback:(id)sender&#123;</span><br><span class="line">    if (self.myBlock) &#123;</span><br><span class="line">        self.myBlock(NO);</span><br><span class="line">    &#125;</span><br><span class="line">    [super goback:sender];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>FIXME:通常在bug的位置做该标记</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//FIXME:如果使用点击空白处，取消键盘响应事件，打开下面👇代码</span><br><span class="line">//- (void)tapGestures:(UIGestureRecognizer *)gesture&#123;</span><br><span class="line">//    [self.view endEditing:YES];</span><br><span class="line">//&#125;</span><br></pre></td></tr></table></figure><p><strong>#pragma mark:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark UIImagePickerControllerDelegate图片选择代理方法</span><br><span class="line">- (void)imagePickerControllerDidCancel:(UIImagePickerController *)picker</span><br><span class="line">&#123;</span><br><span class="line">    [self.IPCView disappear];</span><br><span class="line">    [picker dismissViewControllerAnimated:YES completion:Nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下效果：<br><img src="http://obzx0h1re.bkt.clouddn.com/TODO_sign.png" alt="MARK-TODO-FIXME"><br>下面是关于写警告的方法，这个警告是我们在项目中自己制造的，旨在引起注意</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#pragma message &quot;warn one&quot;</span><br><span class="line">#warning &quot;warn two&quot;</span><br></pre></td></tr></table></figure><p>警告效果：<br><img src="http://obzx0h1re.bkt.clouddn.com/warn_sign.png" alt="warning"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在项目中以&lt;code&gt;ViewController&lt;/code&gt;界面为例，在创建很多方法的情况下，会导致代码在翻阅时很浪费时间。但我们也是有对应的便捷方法。例如：&lt;code&gt;#pragma mark&lt;/code&gt;以及 打断点引起注意的方式都可以达到我们想要的效果。&lt;/p&gt;

      
    
    </summary>
    
      <category term="iOS" scheme="http://guohuaden.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://guohuaden.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>借我</title>
    <link href="http://guohuaden.com/2017/04/21/borrow-me/"/>
    <id>http://guohuaden.com/2017/04/21/borrow-me/</id>
    <published>2017-04-21T01:44:16.000Z</published>
    <updated>2018-08-21T04:58:00.724Z</updated>
    
    <content type="html"><![CDATA[<p><strong>借我一个暮年，</strong></p><p><strong>借我碎片，</strong></p><p><strong>借我瞻前与顾后，</strong></p><p><strong>借我执拗如少年。</strong></p><p><strong>借我后天长成的先天，</strong></p><p><strong>借我变如不曾改变。</strong></p><p><strong>借我素淡的世故和明白的愚，</strong></p><p><strong>借我可预知的险。</strong></p><p><strong>借我悲怆的磊落，</strong></p><p><strong>借我温软的鲁莽和玩笑的庄严。</strong></p><p><strong>借我最初与最终的不敢，借我不言而喻的不见。</strong></p><p><strong>借我一场秋啊，可你说这已是冬天。</strong><br><br> </p><p><font color="#DC143C"><strong>注：</strong></font>这首诗感觉很特别，初次读到时是在一个好朋友发表的说说中，那时的感觉很是欢喜，也有一些自责。欢喜是因为很喜欢，而且最终还是看到了这首诗；自责是因为，这么好的一首诗，我却迟迟未曾发现，如果不是因为这个好朋友发的说说，我也许就会错过。<br><br></p><p><font color="#DC143C"><strong>另注：</strong></font>有人说这首诗是樊小纯写给木心的，也有人说是木心写的。我不确定，所以没有注明作者。但这并不影响我对这首诗的喜欢，我喜欢的始终是诗，跟作者的是谁关系并不太大，但写出这首诗的作者，我是很佩服的。  <br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;借我一个暮年，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;借我碎片，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;借我瞻前与顾后，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;借我执拗如少年。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;借
      
    
    </summary>
    
      <category term="欠下的时光" scheme="http://guohuaden.com/categories/%E6%AC%A0%E4%B8%8B%E7%9A%84%E6%97%B6%E5%85%89/"/>
    
    
      <category term="欠下的时光" scheme="http://guohuaden.com/tags/%E6%AC%A0%E4%B8%8B%E7%9A%84%E6%97%B6%E5%85%89/"/>
    
  </entry>
  
  <entry>
    <title>__bridge 和 Core Foundation</title>
    <link href="http://guohuaden.com/2017/03/14/bridge-understand/"/>
    <id>http://guohuaden.com/2017/03/14/bridge-understand/</id>
    <published>2017-03-14T02:25:36.000Z</published>
    <updated>2018-08-21T04:57:59.165Z</updated>
    
    <content type="html"><![CDATA[<p>这篇知识比较偏，是偏低层一些的。</p><p><strong>一：__birdge</strong></p><p>由于<code>__bridge</code>很少接触，所以专门去查找了一下。其实它的作用很简单，就是：实现<code>id</code>类型与<code>void*</code> 类型的相互转换。</p><p>看下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id obj = [[NSObject alloc]init];</span><br><span class="line">void *c = (__bridge void *)(obj); </span><br><span class="line">id d = (__bridge id)(c);</span><br><span class="line">NSLog(@&quot;\n obj=%@,\n c=%@,\n d=%@\n&quot;,obj,c,d);</span><br></pre></td></tr></table></figure><p>这里我们就用到了<code>__bridge</code>。<br>打印结果如下：</p><p><img src="http://obzx0h1re.bkt.clouddn.com/__bridgePrint.png" alt="__bridgePrint"></p><p>下面看下使用和不使用<code>__bridge</code>的对比</p><p><img src="http://obzx0h1re.bkt.clouddn.com/__bridgeError.png" alt="__bridgeError"></p><p><img src="http://obzx0h1re.bkt.clouddn.com/__bridge.png" alt="__bridge"></p><p>   <br></p><p><strong>二：Core Foundation</strong></p><p><strong>1、什么是Core Foundation</strong></p><p><code>Core Foundation</code>框架 (CoreFoundation.framework) 是一组C语言接口，它们为iOS应用程序提供基本数据管理和服务功能。</p><p><strong>注：</strong><code>Core Foundation</code>是底层框架，它的对象并不在ARC管理下，所以需要开发者自己去维护这些对象的引用计数。</p><p><strong>2、Core Foundaton 的作用</strong><br>至于它的作用，这里有一段英文解释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The programming interfaces of Core Foundation objects have been designed for ease of use and reuse. At a general level, Core Foundation:</span><br><span class="line">    Enables sharing of code and data among various frameworks and libraries.</span><br><span class="line">    Makes some degree of operating-system independence possible .</span><br><span class="line">    Supports internationalization with Unicode strings.</span><br><span class="line">    Provides common API and other useful capabilities, including a plug-in architecture, XML property lists, and preferences.</span><br><span class="line">Core Foundation makes it possible for the different frameworks and libraries on OS X to share code and data. Applications, libraries, and frameworks can define C routines that incorporate Core Foundation types in their external interfaces; they can thus communicate data—as Core Foundation objects—to each other through these interfaces.</span><br></pre></td></tr></table></figure><p>翻译后，大致意思是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Core Foundation对象的编程接口已设计为易于使用和重用。 在一般的意义，Core Foundation：</span><br><span class="line">     1、支持在各种框架和库之间共享代码和数据</span><br><span class="line">     2、使某种程度的操作系统独立性成为可能</span><br><span class="line">     3、支持使用Unicode字符串进行国际化</span><br><span class="line">     4、提供通用API和其他有用的功能，包括插件架构，XML属性列表和首选项</span><br><span class="line">Core Foundation使得OS X上的不同框架和库可以共享代码和数据。 应用程序，库和框架可以定义在其外部接口中并入Core Foundation类型的C例程; 它们因此可以通过这些接口将数据作为Core Foundation对象传递到彼此。</span><br></pre></td></tr></table></figure><p><strong>三、Objective-C 和 Core Foundation 对象之间转换</strong></p><p>iOS允许<code>Objective-C</code> 和 <code>Core Foundation</code> 对象之间可以轻松的转换。</p><p>在《iOS开发进阶》一书中，唐巧提到：在ARC下，有时候需要将一个<code>Core Foundation</code>对象转换成一个<code>Object-C</code>对象，这个时候我们需要告诉编译器，转换过程中引用计数需要如何调整，这时也会用到<code>bridge</code>这个关键字。</p><ul><li><code>__bridge</code>: 只做类型转换，不修改相关对象的引用计数，原来的Core Foundation对象在不用时，需要调用CFRelease方法。</li><li><code>__bridge_retained</code>: 类型转换后将相关对象的引用计数加1，原来的<code>Core Foundation</code>对象在不用时，需要调用<code>CFRelease</code>方法。</li><li><code>__bridge_transfer</code>: 类型转换后，将该对象的引用计数交给ARC管理，<code>Core Foundation</code>对象在不用时，不再需要调用<code>CFRelease</code>方法。</li></ul><hr><p><code><strong>__bridge</strong></code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    id obj = [[NSObject alloc]init];</span><br><span class="line">//    void *a = obj;</span><br><span class="line">//    id b = a;</span><br><span class="line">    void *c = (__bridge void *)(obj);//只做类型转换，不修改相关对象的引用计数</span><br><span class="line">    NSLog(@&quot;obj-c count is %ld&quot;, CFGetRetainCount(c));//输出结果： obj-c count is 1</span><br><span class="line">    id d = (__bridge id)(c); </span><br><span class="line">    NSLog(@&quot;obj-d retainCount %ld&quot;,CFGetRetainCount((__bridge CFTypeRef)(d)));//输出结果：obj-d retainCount 2</span><br><span class="line">    NSLog(@&quot;\n obj=%@,\n c=%@,\n d=%@\n&quot;,obj,c,d);</span><br><span class="line">    //__bridge</span><br><span class="line">    CFStringRef CFString = CFStringCreateWithCString(kCFAllocatorDefault, &quot;hello Core Foundation&quot;, kCFStringEncodingASCII);</span><br><span class="line">    NSLog(@&quot;CFString retainCount= %ld&quot;,CFGetRetainCount(CFString));//CFString retainCount= 1</span><br><span class="line">    NSString *string = (__bridge NSString *)CFString;</span><br><span class="line">    NSLog(@&quot;CFstring==%@,\nstring==%@\n&quot;,CFString,string);</span><br><span class="line">    NSString *qStr = @&quot;qgh&quot;;</span><br><span class="line">    CFStringRef qCFStr = (__bridge CFStringRef)qStr;</span><br><span class="line">    NSLog(@&quot;qStr==%@,qCFStr==%@\n&quot;,qStr,qCFStr);</span><br><span class="line">    NSArray *array = @[@&quot;a&quot;,@&quot;b&quot;,@&quot;c&quot;,@&quot;d&quot;,@&quot;e&quot;,@&quot;f&quot;,@&quot;g&quot;,@&quot;h&quot;];</span><br><span class="line">    CFArrayRef CFArray = (__bridge CFArrayRef)(array);</span><br><span class="line">    NSLog(@&quot;CFArray retainCount= %ld&quot;,CFGetRetainCount(CFArray));//CFArray retainCount= 1</span><br><span class="line">    NSLog(@&quot;array==%@&quot;,CFArray);</span><br></pre></td></tr></table></figure><hr><p><strong><code>__bridge_transfer</code></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//__bridge_transfer:类型转换后，将该对象的引用计数交给ARC管理.</span><br><span class="line">NSString *transferString = [[NSString alloc]initWithFormat:@&quot;test:::__bridge_transfer&quot;];</span><br><span class="line">CFStringRef CFTransferString = (__bridge_retained CFStringRef)(transferString);</span><br><span class="line">NSLog(@&quot;CFTransferString count is %ld&quot;, CFGetRetainCount(CFTransferString));//CFTransferString count is 2</span><br><span class="line">transferString = (__bridge_transfer NSString *)(CFTransferString);</span><br><span class="line">NSLog(@&quot;transferString count is %ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(transferString)));//transferString count is 1</span><br></pre></td></tr></table></figure><hr><p><strong><code>__bridge_retained</code></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//__bridge_retained: 类型被转换时，其对象的所有权也将被变换后变量所持有</span><br><span class="line">void *y = 0;</span><br><span class="line">id object = [[NSObject alloc]init];</span><br><span class="line">y = (__bridge_retained void*)(object);//类型转换后将相关对象的引用计数加1</span><br><span class="line">NSLog(@&quot;object-y count is %ld&quot;, CFGetRetainCount(y));//object-y count is 2</span><br><span class="line">NSLog(@&quot;class=%@&quot;,[(__bridge id)(y) class]);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇知识比较偏，是偏低层一些的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一：__birdge&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于&lt;code&gt;__bridge&lt;/code&gt;很少接触，所以专门去查找了一下。其实它的作用很简单，就是：实现&lt;code&gt;id&lt;/code&gt;类型与&lt;code&gt;
      
    
    </summary>
    
      <category term="iOS" scheme="http://guohuaden.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://guohuaden.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>我和这个世界不熟 --北岛</title>
    <link href="http://guohuaden.com/2017/03/12/I-am-not-familiar-with-this-world/"/>
    <id>http://guohuaden.com/2017/03/12/I-am-not-familiar-with-this-world/</id>
    <published>2017-03-12T01:04:32.000Z</published>
    <updated>2018-08-21T04:57:46.902Z</updated>
    
    <content type="html"><![CDATA[<p>　　我和这个世界不熟。 </p><p>　　这并非是我安静的原因。 </p><p>　　我依旧有很多问题， </p><p>　　问南方，问故里，问希望，问距离。  <br>　　 </p><p>　　我和这个世界不熟。 </p><p>　　这并非是我绝望的原因。 </p><p>　　我依旧有很多热情， </p><p>　　给分开，给死亡，给昨天，给安寂。  <br>　　 </p><p>　　我和这个世界不熟。 </p><p>　　这并非是我虚假的原因。 </p><p>　　我依旧有很多真诚， </p><p>　　离不开，放不下，活下去，爱得起。  <br>　　 </p><p>　　我和这个世界不熟。 </p><p>　　这并非是我孤寂的原因。 </p><p>　　我依旧有很多诉求， </p><p>　　需慰藉，待分享，惹心烦，告诉你。  <br>　　 </p><p>　　我和这个世界不熟。 </p><p>　　这并非是我冷漠的原因。 </p><p>　　我依旧有很多动情， </p><p>　　为时间，为白云，为天黑，畏天命。  <br>　　 </p><p>　　我和这个世界不熟。 </p><p>　　这并非是我逃避的原因。 </p><p>　　我依旧有很多憧憬， </p><p>　　对梦想，对记忆，对失败，对希冀。  <br>　　 </p><p>　　我和这个世界不熟。 </p><p>　　这并非是我卑微的原因。 </p><p>　　我依旧有很多勇敢， </p><p>　　不信输，不信神，不信天，不信地。  <br>　　 </p><p>　　我和这个世界不熟。 </p><p>　　这并非是我失落的原因。 </p><p>　　我依旧有很多高昂， </p><p>　　有存在，有价值，有独特，有意义。  <br>　　 </p><p>　　我和这个世界不熟。 </p><p>　　这并非是我迷茫的原因。 </p><p>　　我依旧有很多方向， </p><p>　　往前走，回头望，会跳跃，会停息。  <br>　　 </p><p>　　我和这个世界不熟。 </p><p>　　这并非是我撕裂的原因。 </p><p>　　我依旧有很多完整， </p><p>　　至少我要成全我自己。  <br>　　 </p><p>　　我和这个世界不熟。 </p><p>　　这并非是我选择死亡或者生存的原因。 </p><p>　　我依旧有很多选择， </p><p>　　刚巧，这两者，都不是选项之一。  <br>　　</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　我和这个世界不熟。 &lt;/p&gt;
&lt;p&gt;　　这并非是我安静的原因。 &lt;/p&gt;
&lt;p&gt;　　我依旧有很多问题， &lt;/p&gt;
&lt;p&gt;　　问南方，问故里，问希望，问距离。  &lt;br&gt;
　　 &lt;/p&gt;
&lt;p&gt;　　我和这个世界不熟。 &lt;/p&gt;
&lt;p&gt;　　这并非是我绝望的原因。 &lt;/p&gt;

      
    
    </summary>
    
      <category term="欠下的时光" scheme="http://guohuaden.com/categories/%E6%AC%A0%E4%B8%8B%E7%9A%84%E6%97%B6%E5%85%89/"/>
    
    
      <category term="欠下的时光" scheme="http://guohuaden.com/tags/%E6%AC%A0%E4%B8%8B%E7%9A%84%E6%97%B6%E5%85%89/"/>
    
  </entry>
  
  <entry>
    <title>iOS之防止用户重复点击Button（按钮）问题</title>
    <link href="http://guohuaden.com/2017/03/10/Repeat-ButtonClick/"/>
    <id>http://guohuaden.com/2017/03/10/Repeat-ButtonClick/</id>
    <published>2017-03-10T06:46:31.000Z</published>
    <updated>2018-08-21T04:58:27.565Z</updated>
    
    <content type="html"><![CDATA[<p>在项目中，我们往往会遇到这样的问题：因为网络较慢的原因，用户会不耐烦的一直去点击按钮，这样导致的结果时：相关代码一遍一遍的被重复执行，如果按钮的事件是网络请求的话，这样又导致一种网络请求的循环。所以我们解决的方法是在执行按钮点击事件时，为<code>Button</code>加上防止重复点击的方法。</p><p>具体的有以下几种方法：</p><font color="#0B1746"><strong>1、使用<code>performSelector</code>方法</strong></font><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay;</span><br></pre></td></tr></table></figure><p>我们在点击事件中添加延迟执行事件，在延迟的这个期间，该按钮的<code>enabled</code>设置为NO，即不能点击。过了延迟时间后再设置为<code>YES</code>。以这种方式防止用户重复点击按钮。</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-(void)buttonClicked:(id)sender</span><br><span class="line">&#123;</span><br><span class="line">   sender.enabled = NO;</span><br><span class="line">  //防止用户重复点击</span><br><span class="line">  [self performSelector:@selector(changeButtonStatus:) withObject:nil afterDelay:1.0f];</span><br><span class="line">&#125;</span><br><span class="line">-(void)changeButtonStatus:(id)sender</span><br><span class="line">&#123;</span><br><span class="line">    sender.enabled = YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的方法可以很好的解决我们重复点击按钮的问题，但更推荐的却是下面的这种方法：</p><font color="#0B1746"><strong>2、使用<code>cancelPreviousPerformRequestsWithTarget</code> 和  <code>performSelector</code> 结合的方法（推荐使用</strong>）</font><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (void)cancelPreviousPerformRequestsWithTarget:(id)aTarget selector:(SEL)aSelector object:(nullable id)anArgument;</span><br><span class="line">- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay;</span><br></pre></td></tr></table></figure><p>原理是：我们每次点击按钮时，先执行取消之前的按钮点击执行事件，然后再去执行一个延迟执行方法（方法中执行的是按钮执行的事件）。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)buttonClicked:(id)sender</span><br><span class="line">&#123;</span><br><span class="line">    //在这里做按钮的想做的事情。</span><br><span class="line">&#125;</span><br><span class="line">- (void)starButtonClicked:(id)sender</span><br><span class="line">&#123;</span><br><span class="line">    //先将未到时间执行前的任务取消。</span><br><span class="line">    [[self class] cancelPreviousPerformRequestsWithTarget:self selector:@selector(buttonClicked:)object:sender];</span><br><span class="line">    [self performSelector:@selector(buttonClicked:)withObject:sender afterDelay:0.2f];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种是我们比较推荐的方法，但这两种方法都可以解决按钮被重复点击的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在项目中，我们往往会遇到这样的问题：因为网络较慢的原因，用户会不耐烦的一直去点击按钮，这样导致的结果时：相关代码一遍一遍的被重复执行，如果按钮的事件是网络请求的话，这样又导致一种网络请求的循环。所以我们解决的方法是在执行按钮点击事件时，为&lt;code&gt;Button&lt;/code
      
    
    </summary>
    
      <category term="iOS" scheme="http://guohuaden.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://guohuaden.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>服务器返回的json数据中含有null的处理方法</title>
    <link href="http://guohuaden.com/2017/03/06/json-dataNull/"/>
    <id>http://guohuaden.com/2017/03/06/json-dataNull/</id>
    <published>2017-03-06T05:33:53.000Z</published>
    <updated>2018-08-21T04:57:45.041Z</updated>
    
    <content type="html"><![CDATA[<p>因为有遇到过类似情况，所以就想到了一些解决方法，并且实践了一下，这里简单的做个记录。</p><p><strong>注：</strong>有看到不少的评价，有说后台责任，也有说怪移动端没有做容错处理。我这里就事论事的说下，移动端从服务器得到的数据中确实是不应该包含<code>null</code>的，因为这本身就是不合理的。（当然，我的就事论事是站在iOS立场上说的，这个无可厚非）。</p><p>下面👇说一下想到的几种方法：</p><p><strong>一、 对于所有使用到的json中的对象做判断（当然这是最笨的方法）</strong></p><pre><code>NSString *msg ;if ([str isKindOfClass: [NSNull class]]){    NSLog(@&quot;str 为空！&quot;);}//或者使用[str isEqual:[NSNull null]]</code></pre><p>为什么首先说这种方法呢，大抵是因为这个方法的工作量比较大吧。但有时候你是完全不能避免这种情况的，尤其是在老旧的项目中，当你看到项目中所有的解析都是<code>KVO</code>模式时，你就知道一个个去判断是多么让人纠结的事情了。</p><hr><p><strong>二、使用<code>JSONModel</code>等第三方json解析库</strong>  </p><p><code>JSONModel</code>有专门针对对象为<code>null</code>的处理，使其返回<code>“<null>“</null></code>。iOS移动端赋值为<code>nil</code>。</p><hr><p><strong>三、有一个专门针对数据为<code>null</code>的处理库，<code>NullSafe</code></strong></p><p>这个库是专门处理对象为null的。只有一个<code>.m</code>文件。使用也简单，因为你只需要添加到项目中就可以了，不再需要引入头文件等其他任意操作。</p><p>这里放一个我测试是使用的简单demo</p><p><a href="https://github.com/Wheat-Qin/Data_null_test" target="_blank" rel="noopener">github:data_nullDemo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为有遇到过类似情况，所以就想到了一些解决方法，并且实践了一下，这里简单的做个记录。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;有看到不少的评价，有说后台责任，也有说怪移动端没有做容错处理。我这里就事论事的说下，移动端从服务器得到的数据中确实是不应该包含&lt;code
      
    
    </summary>
    
      <category term="iOS" scheme="http://guohuaden.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://guohuaden.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>WebView 打不开问题 (转码问题)</title>
    <link href="http://guohuaden.com/2017/02/27/WebView-ErrorOpen/"/>
    <id>http://guohuaden.com/2017/02/27/WebView-ErrorOpen/</id>
    <published>2017-02-27T01:56:54.000Z</published>
    <updated>2018-08-21T04:58:50.775Z</updated>
    
    <content type="html"><![CDATA[<p>无意中遇到一个问题，项目中使用<code>UIWebView</code>打不开<code>web</code>界面，检查过<code>URL</code>和代码，发现并没有问题。随考虑到一点：<strong>URL中包含汉字</strong>。</p><p>处理如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NSString *URLString = [NSString stringWithFormat:@&quot;%@id=%@&amp;email=%@&quot;,ProviderOrder,self.orderID,emailStr];</span><br><span class="line">//方法是用来进行转码的，即将汉字转码</span><br><span class="line">NSString *encodedString1 = [URLString stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLQueryAllowedCharacterSet]];</span><br><span class="line">//该方法用来进行转码的，即将汉字转码（在Xcode7中，iOS9）</span><br><span class="line">//NSString *encodedString = [URLString stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">NSURL *url =[NSURL URLWithString:[NSString stringWithFormat:@&quot;%@&quot;,encodedString1]];</span><br><span class="line">self.webView = [[UIWebView alloc]initWithFrame:self.view.bounds];</span><br><span class="line">self.webView.delegate = self;</span><br><span class="line">NSURLRequest *request = [NSURLRequest requestWithURL:url ];</span><br><span class="line">[self.webView loadRequest:request];</span><br><span class="line">[self.view addSubview:self.webView];</span><br></pre></td></tr></table></figure><p>上面为什么推荐使用<br><code>(NSString *)stringByAddingPercentEncodingWithAllowedCharacters:(NSCharacterSet *)allowedCharacters</code>,<br>这里是文档中给出的解释：</p><p><strong>其一：</strong></p><pre>Use -stringByAddingPercentEncodingWithAllowedCharacters: instead, which always uses the recommended UTF-8 encoding, and which encodes for a specific URL component or subcomponent since each URL component or subcomponent has different rules for what characters are valid.</pre><p>翻译如下：</p><p>使用<code>-stringByAddingPercentEncodingWithAllowedCharacters：</code>改为，<br>它总是使用推荐的<code>UTF-8</code>编码，<br>并且其对特定的URL组件或子组件进行编码，因为每个URL组件或子组件对于什么字符是有效的具有不同的规则。</p><p><strong>其二：</strong></p><pre>Returns a new string made from the receiver by replacing all characters not in the allowedCharacters set with percent encoded characters. UTF-8 encoding is used to determine the correct percent encoded characters. Entire URL strings cannot be percent-encoded. This method is intended to percent-encode an URL component or subcomponent string, NOT the entire URL string. Any characters in allowedCharacters outside of the 7-bit ASCII range are ignored.</pre><p>翻译如下：</p><p>通过替换不在allowedCharacters中的所有字符，使用百分比编码字符返回从接收器创建的新字符串。 UTF-8编码用于确定正确的百分比编码字符。 整个URL字符串不能进行百分号编码。 此方法旨在对URL组件或子组件字符串（而不是整个URL字符串）进行百分比编码。 将忽略7位ASCII范围之外的allowedCharacters中的任何字符。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;无意中遇到一个问题，项目中使用&lt;code&gt;UIWebView&lt;/code&gt;打不开&lt;code&gt;web&lt;/code&gt;界面，检查过&lt;code&gt;URL&lt;/code&gt;和代码，发现并没有问题。随考虑到一点：&lt;strong&gt;URL中包含汉字&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;处理如下：&lt;
      
    
    </summary>
    
      <category term="iOS" scheme="http://guohuaden.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://guohuaden.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>对于Xcode中 Build Active Architecture Only 的认识</title>
    <link href="http://guohuaden.com/2017/02/16/Build-Active-Architecture-Only-Query/"/>
    <id>http://guohuaden.com/2017/02/16/Build-Active-Architecture-Only-Query/</id>
    <published>2017-02-16T07:11:12.000Z</published>
    <updated>2018-08-21T04:57:57.582Z</updated>
    
    <content type="html"><![CDATA[<p>之前在给项目适配64位时，看到Xcode中有这个设置，因为关系到适配问题，又比较好奇，就了解了一番。发现这个设置也有不小的作用。</p><p><img src="http://obzx0h1re.bkt.clouddn.com/Build%20Active%20Architecture%20Only2.png" alt="Build Active Architecture Only2"></p><font color="#9ACD32"><code>Build Active Architecture Only</code>：指定是否只对当前连接设备所支持的指令集编译</font><p>系统默认是：Debug设置为<code>Yes</code>，Release设置为<code>No</code>。</p><p><strong>原因</strong>是：</p><p>当直接把<code>Build Active Architecture Only</code> 设置为<code>Yes</code>时，可以使Debug的时候编译速度更快，因为它只编译当前的Architecture版本。</p><p>而如果设置为<code>No</code>，则编译的事所有的版本。</p><p><strong>注</strong>：<font color="#FF7F50">    其中提到的版本是Architecture的支持版本：<code>arm64</code>、<code>armv7</code>、<code>armv7s</code>、<code>i386</code>、<code>x86_64</code>等。</font></p><p>其中</p><font color="#808000"><br><strong><code>i386</code>是针对intel通用微处理器32位处理器</strong><br><br><strong><code>x86_64</code>是针对x86架构的64位处理器</strong><br><br><strong>模拟器32位处理器测试需要<code>i386</code>架构</strong><br><br><strong>模拟器64位处理器测试需要<code>x86_64</code>架构</strong><br><br><strong>真机32位处理器需要<code>armv7</code>,或者<code>armv7s</code>架构</strong><br><br><strong>真机64位处理器需要<code>arm64</code>架构</strong><br><br></font><p>所以我们一般默认Debug设置为<code>Yes</code>，Release设置为<code>No</code>。编译出的版本是向下兼容的，连接的设备的指令集匹配是由高到低（<code>arm64</code> &gt; <code>armv7s</code> &gt; <code>armv7</code>）依次匹配的。比如你设置此值为yes，用iphone4编译出来的是<code>armv7</code>版本的，iphone5也可以运行，但是<code>armv6</code>的设备就不能运行。  所以，一般Debug的时候可以选择设置为<code>Yes</code>，Release的时候要改为<code>No</code>，以便于适配不同的版本。<br><img src="http://obzx0h1re.bkt.clouddn.com/Build%20Active%20Architecture%20Only%20Picture.png" alt="    Build Active Architecture Only Picture"></p><p><strong>但也有直接将<code>Build Active Architecture Only</code>设置为<code>No</code>的情况</strong><br><img src="http://obzx0h1re.bkt.clouddn.com/Build%20Active%20Architecture%20Only1.png" alt="Build Active Architecture Only1"></p><p>这样做的原因是因为使用默认设置运行项目时出现错误：<font color="#FF6347"><strong><code>Module ‘Alamofire’ has no member ‘request’</code></strong></font><br>解决方法就是直接都设置为<code>No</code>。</p><p><font color="#008000"><strong>问题</strong>：</font><br><img src="http://obzx0h1re.bkt.clouddn.com/Module%20%27Alamofire%27%20has%20no%20member%20%27request%27.png" alt="Module &#39;Alamofire&#39; has no member &#39;request&#39;"></p><p><font color="#008000"><strong>方法</strong>：</font><br><img src="http://obzx0h1re.bkt.clouddn.com/Module%20%27Alamofire%27%20has%20no%20member%20%27request%27-answer.png" alt="Module &#39;Alamofire&#39; has no member &#39;request&#39;-answer"></p><p>一些有益非浅的链接：</p><p><a href="http://blog.csdn.net/lizhongfu2013/article/details/42387311" target="_blank" rel="noopener">iOS开发～制作同时支持armv7,armv7s,arm64,i386,x86_64的静态库.a</a></p><p><a href="http://www.cnblogs.com/hikoming/p/3708659.html" target="_blank" rel="noopener">Xcode的Architectures、Valid Architectures和Build Active Architecture Only属性(原创)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前在给项目适配64位时，看到Xcode中有这个设置，因为关系到适配问题，又比较好奇，就了解了一番。发现这个设置也有不小的作用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://obzx0h1re.bkt.clouddn.com/Build%20Active%20Archi
      
    
    </summary>
    
      <category term="iOS" scheme="http://guohuaden.com/categories/iOS/"/>
    
    
      <category term="Xcode" scheme="http://guohuaden.com/tags/Xcode/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊WKWebView</title>
    <link href="http://guohuaden.com/2017/02/11/WKWebView/"/>
    <id>http://guohuaden.com/2017/02/11/WKWebView/</id>
    <published>2017-02-11T02:33:52.000Z</published>
    <updated>2018-08-21T04:59:04.799Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>由于之前一直在用<code>UIWebView</code>,所以对于<code>WKWebView</code>只是停留在知道，了解的状态，并未深入的去研究。前天一个项目要求支持iOS8以上，要加入一个web界面。在习惯性使用<code>UIWebView</code>写到一半的时候，突然想使用<code>WKWebView</code>去实现，所以专门花费了些时间去研究了一下<code>WKWebView</code>，很是喜欢。</p><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>接下来纪录一下使用<code>WKWebView</code>的过程细节。但关于<code>WKWebView</code>与<code>js</code>互交的部分保留意见，因为并没有深入去研究这一点。</p><h3 id="1、引入WebKit库"><a href="#1、引入WebKit库" class="headerlink" title="1、引入WebKit库"></a>1、引入WebKit库</h3><p>Apple方面为使用<code>WKWebView</code>专门添加了<code>WebKit</code>库，在使用<code>WKWebView</code>时候必须引入<code>WebKit</code>库才可以。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;WebKit/WebKit.h&gt;</span><br></pre></td></tr></table></figure></p><h3 id="2、初始化WKWebView"><a href="#2、初始化WKWebView" class="headerlink" title="2、初始化WKWebView"></a>2、初始化WKWebView</h3><p>在文档中可以看出，<code>WKWebView</code>的初始化方法有两种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithFrame:(CGRect)frame;</span><br><span class="line">- (instancetype)initWithFrame:(CGRect)frame configuration:(WKWebViewConfiguration *)configuration NS_DESIGNATED_INITIALIZER</span><br></pre></td></tr></table></figure><ul><li>我们大多使用第一种方式，这也是文档中默认的一种方式。这里不再多说。</li><li>关于第二种方式，其实就是在初始化<code>WKWebView</code>时，给<code>webView</code>做一个配置，我这里给出一段简单的配置代码：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc]init];</span><br><span class="line">config.preferences = [WKPreferences new];</span><br><span class="line">config.preferences.minimumFontSize = 20.f;</span><br><span class="line">config.preferences.javaScriptEnabled = YES; //The default value is YES</span><br><span class="line">config.preferences.javaScriptCanOpenWindowsAutomatically = NO;//The default value is NO in iOS and YES in OS X.</span><br><span class="line">//config.preferences.javaEnabled = NO ; //The default value is NO .不在iphone中使用的方法</span><br><span class="line">config.userContentController = [WKUserContentController new];  </span><br><span class="line">self.webView = [[WKWebView alloc]initWithFrame:self.view.bounds configuration:config];</span><br></pre></td></tr></table></figure><p><strong>注：</strong>其实第一种方式，虽然我们并没有指定初始化的配置，但Apple也为我们指定了一个默认的配置。</p><h3 id="3、加载网页"><a href="#3、加载网页" class="headerlink" title="3、加载网页"></a>3、加载网页</h3><p>方法有几种，我们常用的是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSURLRequest *request = [[NSURLRequest alloc]initWithURL:[NSURL URLWithString:@&quot;https://www.baidu.com&quot;]];</span><br><span class="line">[self.webView loadRequest:request];</span><br></pre></td></tr></table></figure><p>剩下的几种为：</p><pre><code>[self.webView loadHTMLString:(nonnull NSString *) baseURL:(nullable NSURL *)];[self.webView loadFileURL:(nonnull NSURL *) allowingReadAccessToURL:(nonnull NSURL *)];[self.webView loadData:(nonnull NSData *) MIMEType:(nonnull NSString *) characterEncodingName:(nonnull NSString *) baseURL:(nonnull NSURL *)];</code></pre><h3 id="4、加载js代码"><a href="#4、加载js代码" class="headerlink" title="4、加载js代码"></a>4、加载js代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 图片缩放的js代码</span><br><span class="line">NSString *js = @&quot;var count = document.images.length;for (var i = 0; i &lt; count; i++) &#123;var image = document.images[i];image.style.width=500;image.style.height=600;&#125;;window.alert(&apos;找到&apos; + count + &apos;张图&apos;);&quot;;</span><br><span class="line">// 根据JS字符串初始化WKUserScript对象</span><br><span class="line">WKUserScript *script = [[WKUserScript alloc] initWithSource:js injectionTime:WKUserScriptInjectionTimeAtDocumentEnd forMainFrameOnly:YES];</span><br><span class="line">// 根据生成的WKUserScript对象，初始化WKWebViewConfiguration</span><br><span class="line">WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init];</span><br><span class="line">[config.userContentController addUserScript:script];</span><br><span class="line">_webView = [[WKWebView alloc] initWithFrame:self.view.bounds configuration:config];</span><br><span class="line">[_webView loadHTMLString:@&quot;&lt;head&gt;&lt;/head&gt;&lt;img src=&apos;http://og3hqoz3g.bkt.clouddn.com/%E5%B9%B8%E7%A6%8F%E9%82%AE%E5%B1%80.jpg&apos; /&gt;&quot;baseURL:nil];</span><br><span class="line">[self.view addSubview:_webView];</span><br></pre></td></tr></table></figure><h3 id="5、代理"><a href="#5、代理" class="headerlink" title="5、代理"></a>5、代理</h3><p><code>WKWebView</code>的代理有两个：<code>WKNavigationDelegate</code> 和 <code>WKUIDelegate</code></p><ul><li><strong>5.1、 WKNavigationDelegate（加载界面时调用的协议方法）</strong></li></ul><p>过程：</p><ol><li>在请求发送之前，决定是否跳转</li><li>页面开始加载时调用</li><li>在收到响应后，决定是否跳转</li><li>内容开始加载时调用</li><li>接收到服务器跳转请求之后调用（不一定调用该方法）</li><li>页面加载完成时调用</li><li>请求失败时调用</li></ol><p>协议方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">//页面开始加载时调用</span><br><span class="line">- (void)webView:(WKWebView *)webView didStartProvisionalNavigation:(null_unspecified WKNavigation *)navigation</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;页面开始加载时调用。   2&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//内容返回时调用，得到请求内容时调用(内容开始加载) -&gt; view的过渡动画可在此方法中加载</span><br><span class="line">- (void)webView:(WKWebView *)webView didCommitNavigation:( WKNavigation *)navigation</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;内容返回时调用，得到请求内容时调用。 4&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//页面加载完成时调用</span><br><span class="line">- (void)webView:(WKWebView *)webView didFinishNavigation:( WKNavigation *)navigation</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;页面加载完成时调用。 5&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//请求失败时调用</span><br><span class="line">- (void)webView:(WKWebView *)webView didFailProvisionalNavigation:(WKNavigation *)navigation withError:(NSError *)error</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;error1:%@&quot;,error);</span><br><span class="line">&#125;</span><br><span class="line">-(void)webView:(WKWebView *)webView didFailNavigation:(WKNavigation *)navigation withError:(NSError *)error</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;error2:%@&quot;,error);</span><br><span class="line">&#125;</span><br><span class="line">//在请求发送之前，决定是否跳转 -&gt; 该方法如果不实现，系统默认跳转。如果实现该方法，则需要设置允许跳转，不设置则报错。</span><br><span class="line">//该方法执行在加载界面之前</span><br><span class="line">//Terminating app due to uncaught exception &apos;NSInternalInconsistencyException&apos;, reason: &apos;Completion handler passed to -[ViewController webView:decidePolicyForNavigationAction:decisionHandler:] was not called&apos;</span><br><span class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler</span><br><span class="line">&#123;</span><br><span class="line">    //允许跳转</span><br><span class="line">    decisionHandler(WKNavigationActionPolicyAllow);</span><br><span class="line">    </span><br><span class="line">    //不允许跳转</span><br><span class="line">//    decisionHandler(WKNavigationActionPolicyCancel);</span><br><span class="line">    NSLog(@&quot;在请求发送之前，决定是否跳转。  1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//在收到响应后，决定是否跳转（同上）</span><br><span class="line">//该方法执行在内容返回之前</span><br><span class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler</span><br><span class="line">&#123;</span><br><span class="line">    //允许跳转</span><br><span class="line">    decisionHandler(WKNavigationResponsePolicyAllow);</span><br><span class="line">    //不允许跳转</span><br><span class="line">//    decisionHandler(WKNavigationResponsePolicyCancel);</span><br><span class="line">    NSLog(@&quot;在收到响应后，决定是否跳转。 3&quot;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">//接收到服务器跳转请求之后调用</span><br><span class="line">- (void)webView:(WKWebView *)webView didReceiveServerRedirectForProvisionalNavigation:(null_unspecified WKNavigation *)navigation</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;接收到服务器跳转请求之后调用&quot;);</span><br><span class="line">&#125;</span><br><span class="line">-(void)webViewWebContentProcessDidTerminate:(WKWebView *)webView</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;webViewWebContentProcessDidTerminate&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>5.2、WKUIDelegate</strong></li></ul><p>这方面包括：创建新的WebView、界面弹出提示框<br><strong><em>创建新的WebView</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个新的WebView</span><br><span class="line">- (WKWebView *)webView:(WKWebView *)webView createWebViewWithConfiguration:(WKWebViewConfiguration *)configuration forNavigationAction:(WKNavigationAction *)navigationAction windowFeatures:(WKWindowFeatures *)windowFeatures;</span><br></pre></td></tr></table></figure><p><strong><em>界面弹出提示框</em></strong></p><p>系统提供了三种弹出提示框的方法：警告框、确认框、输入框</p><p>直接查看代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//警告框</span><br><span class="line">/**</span><br><span class="line"> webView界面中有弹出警告框时调用</span><br><span class="line"> @param webView             web视图调用委托方法</span><br><span class="line"> @param message             警告框提示内容</span><br><span class="line"> @param frame               主窗口</span><br><span class="line"> @param completionHandler   警告框消失调用</span><br><span class="line"> */</span><br><span class="line">- (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    completionHandler();</span><br><span class="line">    NSLog(@&quot;警告框&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//输入框</span><br><span class="line">/**</span><br><span class="line"> web界面中弹出输入框时调用</span><br><span class="line"> @param webView             web视图调用委托方法</span><br><span class="line"> @param prompt              输入消息的显示</span><br><span class="line"> @param defaultText         初始化时显示的输入文本</span><br><span class="line"> @param frame               主窗口</span><br><span class="line"> @param completionHandler   输入结束后调用</span><br><span class="line"> */</span><br><span class="line">-(void)webView:(WKWebView *)webView runJavaScriptTextInputPanelWithPrompt:(NSString *)prompt defaultText:(NSString *)defaultText initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(NSString * _Nullable))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;输入框&quot;);</span><br><span class="line">    completionHandler(@&quot;http&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//确认框</span><br><span class="line">/**</span><br><span class="line"> 显示一个JavaScript确认面板</span><br><span class="line"> @param webView             web视图调用委托方法</span><br><span class="line"> @param message             显示的信息</span><br><span class="line"> @param frame               主窗口</span><br><span class="line"> @param completionHandler   确认后完成处理程序调用</span><br><span class="line"> */</span><br><span class="line">-(void)webView:(WKWebView *)webView runJavaScriptConfirmPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(BOOL))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;确认框&quot;);</span><br><span class="line">    completionHandler(YES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>以上就是WKWebView基本使用方法，其他的不做扩展和补充。也许以后再深入研究时，会有不一样的看法，到时再做推翻或补充。</em></p><p>以下是个人的一点看法：</p><ol><li><code>WKWebView</code>是在iOS8之后出现的新的网页加载控件，将来也必将取代<code>UIWebView</code>，这是毋庸置疑的事情。</li><li>关于项目优化方面：其实很多人建议在项目中添加<code>WKWebView</code>去替代<code>UIWebView</code>。以未来的发展趋势来看，这点无可厚非。</li></ol><p>我下面想说的是站在老项目并且其中内嵌网页比较多的立场的，iOS8以上使用<code>WKWebView</code>，iOS8以下使用<code>UIWebView</code>。这是目前解决方案的好办法。但维护和优化都需要成本，时间也是成本的一部分。</p><p>这里附上demo一份：<a href="https://github.com/Wheat-Qin/WKWebView_test" target="_blank" rel="noopener">WKWebView代码</a></p><p>这里给出几个讲解<code>WKWebView</code>的🔗,对我帮助很大：</p><ol><li><a href="http://www.brighttj.com/ios/ios-wkwebview-new-features-and-use.html" target="_blank" rel="noopener">WKWebView的新特性与使用</a></li><li><a href="http://www.jianshu.com/p/6ba2507445e4" target="_blank" rel="noopener">使用WKWebView替换UIWebView</a> </li><li><a href="http://www.cnblogs.com/junhuawang/p/5759224.html" target="_blank" rel="noopener">UIWebView、WKWebView使用详解及性能分析</a></li><li><a href="http://www.jianshu.com/p/7bb5f15f1daa" target="_blank" rel="noopener">WKWebView学习笔记</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;由于之前一直在用&lt;code&gt;UIWebView&lt;/code&gt;,所以对于&lt;code&gt;WKWebView&lt;/code&gt;只是停留在知道，了解的状态
      
    
    </summary>
    
      <category term="iOS" scheme="http://guohuaden.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://guohuaden.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>关于app支持64bit</title>
    <link href="http://guohuaden.com/2017/01/15/support-64bit/"/>
    <id>http://guohuaden.com/2017/01/15/support-64bit/</id>
    <published>2017-01-15T07:18:34.000Z</published>
    <updated>2018-08-21T04:58:33.412Z</updated>
    
    <content type="html"><![CDATA[<p>关于iOS应用，其实苹果很早就就发布消息：2015年的2月开始，提交App Store的应用必须支持64-bit。而Apple在iPhone 5s 就已经搭配64位双核苹果A7处理器。还是在15年6月，苹果App Store中所有应用更新都必须支持64bit。</p><p>但这对于企业级应用来说，并不能限制应用去支持64bit，因为企业级应用不必提交App Store审核。但Apple又有了新的对策：在iOS 10.1测试版中加入了一项提示，如果用户下载的是一个32位应用，系统会提示<code>“XXX”可能使iPhone变慢，应用开发者需要更新此应用以改进其兼容性。</code></p><p><img src="http://obzx0h1re.bkt.clouddn.com/64Bit-Prompt.jpg" alt="提示效果图"><br>现在看来Apple这种方式，可算是最有效的方式了，因为这样会直接导致用户对一个应用的不同态度。甚至是不止降低用户量。如果是企业级用户，可以直接引起用户的强烈不满。</p><p>不管怎么说，作为一个iOS开发者，既然Apple已经提出，还是要去支持64-bit。</p><p>具体做法：<br><img src="http://obzx0h1re.bkt.clouddn.com/64Bit-Work.png" alt="方法如图"></p><p>关于Xcode <code>“Build Setting”</code>中的<code>Architectures</code>参数问题：</p><ul><li><p><code>Architectures</code>：你想支持的指令集。（支持指令集是通过编译生成对应的二进制数据包实现的，如果支持的指令集数目有多个，就会编译出包含多个指令集代码的数据包，造成最终编译的包很大。）</p></li><li><p><code>Valid architectures</code>：即将编译的指令集。（<code>Valid architectures</code> 和 <code>Architecture</code>两个集合的交集为最终编译生成的版本）</p></li><li><p><code>Build Active Architecture Only</code>：是否只编译当前设备适用的指令集（如果这个参数设为YES，使用iPhone 6调试，那么最终生成的一个支持ARM64指令集的Binary。一般在DEBUG模式下设为YES，RELEASE设为NO）</p></li></ul><p>对于支持64-bit,我们可以设置<code>Architectures</code>为 <code>Standard architectures</code>，它包括 <code>armv7、armv7s 和 arm64</code>。</p><p>而是对于代码中的改变其实也就分为：<strong>数据类型和方法调用</strong> 两个部分。</p><p>比如：<code>int -&gt; NSInteger</code></p><p>以及得到数组个数的方法：<code>[dataArray count] -&gt; dataArray.count</code></p><p>这是关于数据类型改变的总结：<br><img src="http://obzx0h1re.bkt.clouddn.com/64bit-Summary.png" alt="64bit-Summary"><br>上图所说：</p><ul><li>避免将长整型long赋值给整型int (64-bit上会导致数据丢失)</li><li>避免将指针类型pointer赋值给整型int (64-bit导致地址数据丢失)。</li><li>留意数值计算，避免指针和长整型在运算上的截断问题(掩码计算,无符号整数和有符号整数同时使用等)。</li><li>留意对齐方法带来的变化。</li><li>32-bit到64-bit之间数据转化(通过网络传递的用户数据，可能同时存在于32-bit和64-bit的环境下)。</li><li>重写汇编代码，让你的代码使用新的64-bit操作码和运行时。</li><li>不要在可变参数方法和不可变参数方法之前进行强制转化。</li></ul><p>具体可以看：《<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/CocoaTouch64BitGuide/Major64-BitChanges/Major64-BitChanges.html" target="_blank" rel="noopener">64-Bit Transition Guide for Cocoa Touch</a>》</p><p>关于iOS应用支持64位的一些详情，可以看看这篇不错的文章：<br>《<a href="http://www.codeceo.com/article/ios-64-bit.html" target="_blank" rel="noopener">iOS应用如何实现64位的支持</a>》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于iOS应用，其实苹果很早就就发布消息：2015年的2月开始，提交App Store的应用必须支持64-bit。而Apple在iPhone 5s 就已经搭配64位双核苹果A7处理器。还是在15年6月，苹果App Store中所有应用更新都必须支持64bit。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="iOS" scheme="http://guohuaden.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://guohuaden.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS之项目总结二：关于项目中一些功能的改进建议（从一个维护者的角度）</title>
    <link href="http://guohuaden.com/2017/01/11/project-summary-two/"/>
    <id>http://guohuaden.com/2017/01/11/project-summary-two/</id>
    <published>2017-01-11T15:38:00.000Z</published>
    <updated>2018-08-21T04:58:21.073Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>最近一直在维护老的项目，遇到的问题也千奇百怪，需要修补的，需要优化的，需要特殊处理的，感觉总是那么的无语。也许这时候也应该感叹一句：路漫漫其修远兮，吾将上下而求索吧。<br>这篇文章就只是讲讲老项目中遇到的种种不敢苟同的代码写法，以及遇到一些问题时的处理方法。</p><h3 id="1、关于按钮事件的重复点击问题"><a href="#1、关于按钮事件的重复点击问题" class="headerlink" title="1、关于按钮事件的重复点击问题"></a>1、关于按钮事件的重复点击问题</h3><p>我们开发中大概都经历过这样的事情，我的一个<code>button</code>被重复的快速点击，（我们开发者应该更清楚的知道这意味着什么）。那我们再深入的想一下（给这样的事件安排一个特定的环境）：例如当网络较差的情况下，再例如当<code>button</code>的执行事件较为耗时时。这时就会出现很多的问题：有时是界面出现问题（当<code>button</code>执行事件中出现调节界面<code>frame</code>的时候）；有时则会出现卡顿，更甚至会出现崩溃现象。对于这种问题，我们要提前考虑到，做好防范处理：即点击按钮事件时,添加防止重复点击功能。</p><p><strong>思路是</strong>：防止按钮重复点击<br>比较推荐的解决方法代码：</p><pre> - (void)btnClicked:(id)sender {    //在这里做按钮的想做的事情。}- (void)buttonClicked:(id)sender {   //先将未到时间执行前的任务取消。    [[self class] cancelPreviousPerformRequestsWithTarget:self selector:@selector(btnClicked:)object:sender];    [self performSelector:@selector(btnClicked:)withObject:sender afterDelay:0.2f];}</pre><p><strong>原理是</strong> ：我们每次点击按钮时，先执行取消之前的按钮点击执行事件，然后再去执行一个延迟执行方法（方法中执行的是按钮执行的事件）。</p><p>还有一种方法也是可以实现的：具体的看《<a href="http://www.cnblogs.com/LQCQ-Silent/p/6082086.html" target="_blank" rel="noopener">iOS之防止用户重复点击Button（按钮）问题</a> 》</p><h3 id="2、很多界面共用一个界面时：使用枚举做类型判断"><a href="#2、很多界面共用一个界面时：使用枚举做类型判断" class="headerlink" title="2、很多界面共用一个界面时：使用枚举做类型判断"></a>2、很多界面共用一个界面时：使用枚举做类型判断</h3><p>老的项目中会出现很多这样的现象：很多界面重复使用一个界面，这样就自然而然的需要在不同的界面跳转到复用的界面时去做判断。而奇怪的地方在于：判断的依据是<code>self.title</code>。那么就会出现这样一种现象：在跳转界面后会有一大段<code>if</code>去判断字符串是否等于<code>self.title</code> 。</p><p><strong>如果我们做一些改变：使用枚举来做界面类型的判断，使用<code>switch case</code>语句做判断执行代码。这样会不会更优美，简洁一些。</strong></p><h3 id="3、关于老项目中iOS10以上的情况下，导航栏中按钮不显示问题"><a href="#3、关于老项目中iOS10以上的情况下，导航栏中按钮不显示问题" class="headerlink" title="3、关于老项目中iOS10以上的情况下，导航栏中按钮不显示问题"></a>3、关于老项目中iOS10以上的情况下，导航栏中按钮不显示问题</h3><p>如果你的<code>viewController</code>都继承于基类，那么在基类中添加这样一段代码（这也是目前我发现的最省事的方法）：</p><pre>- (void)viewWillAppear:(BOOL)animated {     [super viewWillAppear:animated];    [self.navigationController setNavigationBarHidden:YES animated:NO];    [self.navigationController setNavigationBarHidden:NO animated:NO];}- (void)viewWillDisappear:(BOOL)animated {    [super viewWillDisappear:animated];    [self.navigationController setNavigationBarHidden:YES animated:NO];    [self.navigationController setNavigationBarHidden:NO animated:NO];}</pre><h3 id="4、事件方法要每个界面区分开"><a href="#4、事件方法要每个界面区分开" class="headerlink" title="4、事件方法要每个界面区分开"></a>4、事件方法要每个界面区分开</h3><p>老项目中会有这种情况：在本界面 command点击一个<code>button</code>执行事件方法或者手势事件方法时，会莫名其妙的跳转到另外一个界面。<br>我们在开发时最好给不同界面<code>button</code>的<code>clicked</code>事件命名是区分开来，例如：界面名 + <code>ButtonClicked</code></p><h3 id="5、对象为空现象"><a href="#5、对象为空现象" class="headerlink" title="5、对象为空现象"></a>5、对象为空现象</h3><p>在开发中如果存在<code>image</code>为空，或者必须显示的<code>String</code>为空现象，<br>记得在代码中作判断，图片可以直接设置默认图片，字符串也可以设置默认字符串<br>这一点可以学一下SDWebImage库中对于网络请求图片不存在的处理方法：</p><pre>//给一张默认图片，先使用默认图片，当图片加载完成后再替换[self.image1 sd_setImageWithURL:imagePath1 placeholderImage:[UIImage imageNamed:@"default"]];</pre><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UIImage *image = [UIImage imageNamed:@&quot;image&quot;];</span><br><span class="line">UIImage *defaultImage = [UIImage imageNamed:@&quot;defaultImage&quot;];</span><br><span class="line">UIImageView *imageView = [[UIImageView alloc]initWithImage:image==nil ?  image:defaultImage];</span><br></pre></td></tr></table></figure><p>字符串当然也是类似，其实看似有些费事甚至有的显得多余的写法，会使以后的维护变得更加的如意。</p><h3 id="6、一个界面多网络请求问题，而且需要多个请求都完成后，对界面有一些操作。"><a href="#6、一个界面多网络请求问题，而且需要多个请求都完成后，对界面有一些操作。" class="headerlink" title="6、一个界面多网络请求问题，而且需要多个请求都完成后，对界面有一些操作。"></a>6、一个界面多网络请求问题，而且需要多个请求都完成后，对界面有一些操作。</h3><p>这是一个老的话题了，我之所以重新提及这个话题，原因是我从一些文章中发现了一个从来没使用过的方法，这个下面会提到，现在就让我们列举出来比较常用的方法。就以一个界面两个网络请求为例 A和B.</p><p><strong>（1）两个请求互套)(也是最笨的方法)</strong><br>     具体是这样的，我在A请求成功后，再请求B。当然如果请求多的话，这个肯定是作废的。</p><p><strong>（2）使用GCD中的通知</strong></p><p><pre>dispatch_group_t serviceGroup = dispatch_group_create();<br>// 开始第一个网络请求<br>servicedispatch_group_enter(serviceGroup);<br>[self.configService startWithCompletion:^(ConfigResponse <em>results, NSError </em>error) {<br> //请求成功后的操作<br>    configError = error;<br>    dispatch_group_leave(serviceGroup);//完成后离开分组<br>}];<br>// 开始第二个请求<br>dispatch_group_enter(serviceGroup);<br>[self.preferenceService startWithCompletion:^(PreferenceResponse <em>results, NSError </em>error) {<br> //请求成功后的操作<br>    preferenceError = error;<br>    dispatch_group_leave(serviceGroup);//完成后离开分组<br>}];<br>dispatch_group_notify(serviceGroup,dispatch_get_main_queue(),^{<br> // Assess any errors<br>     NSError *overallError = nil;<br>    if (configError || preferenceError)  {<br> // 判断时候请求有失败<br>        overallError = configError ?: preferenceError;<br>     }<br>// 最后完成后执行的block<br>    completion(overallError);<br>});<br></pre></p><p><strong>（3）利用GCD中的信号量</strong></p><p>在GCD中有三个函数是<code>semaphore</code>的操作，分别是：　　<br><code>dispatch_semaphore_create</code> 创建一个semaphore　　<br><code>dispatch_semaphore_signal</code> 发送一个信号　<br><code>dispatch_semaphore_wait</code> 等待信号　　<br>简单的介绍一下这三个函数，第一个函数有一个整形的参数，我们可以理解为信号的总量，<code>dispatch_semaphore_signal</code>是发送一个信号，自然会让信号总量加1，<code>dispatch_semaphore_wait</code>等待信号，当信号总量少于0的时候就会一直等待，否则就可以正常的执行，并让信号总量-1，根据这样的原理，我们便可以快速的创建一个并发控制来同步任务和有限资源访问控制。</p><p>利用这样的机制，当信号量达到我们网络请求的数量时，请求结束。</p><p><strong>（4）这个也是我上面说的无意中看到的一个方法，仅拿出来作为参考</strong></p><p><pre>dispatch_async(concurrent_queue, ^{<br>     NSLog(@”—并发任务1—“);<br>});<br>dispatch_async(concurrent_queue, ^{<br>     NSLog(@”—并发任务2—“);<br>});<br>dispatch_barrier_async(concurrent_queue, ^{<br>    dispatch_async(dispatch_get_main_queue(), ^{<br>        NSLog(@”—所有并发任务结束后回到主线程刷新—“);<br>    });<br>}); </pre></p><p>以上就是关于一界面多请求的不同解决方案。</p><h3 id="7、代码规范问题"><a href="#7、代码规范问题" class="headerlink" title="7、代码规范问题"></a>7、代码规范问题</h3><ul><li>为什么这个普通的话题放到最后呢，大概是因为我觉得这个很重要的问题吧，毕竟技术水平不高，还是可以提升的。但代码不规范的话，养成习惯后很难改的，我见过太多项目中使用【拼音命名、不注意驼峰命名法、define预处理指令满天飞等等的代码】这些出现在项目中就像时时刻刻在提醒你，看这样的项目是一种煎熬。</li><li>其实代码规范不仅仅是公司对开发者的要求,也是开发者对自己的一个要求。因为如果统一每个人的写作规范，是一件耗时，耗财的事情。小一些的公司是做不来，中型的公司大多是不想做。而大型的公司总是花费近几个月的时间去培养员工的代码规范，这就是财大气粗吧。而且开发者本身对于技术的提升、追求等，都无形中要求自己注意代码规范问题。</li><li>对于这部分，建议看看《Effective Objective-C 2.0》这本书，其中提到了这部分内容。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h3&gt;&lt;p&gt;最近一直在维护老的项目，遇到的问题也千奇百怪，需要修补的，需要优化的，需要特殊处理的，感觉总是那么的无语。也许这时候也应该感叹一句：
      
    
    </summary>
    
      <category term="iOS" scheme="http://guohuaden.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://guohuaden.com/tags/iOS/"/>
    
  </entry>
  
</feed>
