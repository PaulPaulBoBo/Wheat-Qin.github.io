<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wheat</title>
  <subtitle>晨钟一叩，万境皆空</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https:guohuaden.com/"/>
  <updated>2017-03-15T03:23:33.000Z</updated>
  <id>https:guohuaden.com/</id>
  
  <author>
    <name>青卷三部</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>__bridge 和 Core Foundation</title>
    <link href="https:guohuaden.com/2017/03/14/bridge-understand/"/>
    <id>https:guohuaden.com/2017/03/14/bridge-understand/</id>
    <published>2017-03-14T02:25:36.000Z</published>
    <updated>2017-03-15T03:23:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇知识比较偏，是偏低层一些的。</p>
<p><strong>一：__birdge</strong></p>
<p>由于<code>__bridge</code>很少接触，所以专门去查找了一下。其实它的作用很简单，就是：实现<code>id</code>类型与<code>void*</code> 类型的相互转换。</p>
<p>看下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">id obj = [[NSObject alloc]init];</div><div class="line">void *c = (__bridge void *)(obj); </div><div class="line">id d = (__bridge id)(c);</div><div class="line">NSLog(@&quot;\n obj=%@,\n c=%@,\n d=%@\n&quot;,obj,c,d);</div></pre></td></tr></table></figure>
<p>这里我们就用到了<code>__bridge</code>。<br>打印结果如下：</p>
<p><img src="http://obzx0h1re.bkt.clouddn.com/__bridgePrint.png" alt="__bridgePrint"></p>
<p>下面看下使用和不使用<code>__bridge</code>的对比</p>
<p><img src="http://obzx0h1re.bkt.clouddn.com/__bridgeError.png" alt="__bridgeError"></p>
<p><img src="http://obzx0h1re.bkt.clouddn.com/__bridge.png" alt="__bridge"></p>
<p>   <br></p>
<p><strong>二：Core Foundation</strong></p>
<p><strong>1、什么是Core Foundation</strong></p>
<p>Core Foundation框架 (CoreFoundation.framework) 是一组C语言接口，它们为iOS应用程序提供基本数据管理和服务功能。</p>
<p><strong>注：</strong>Core Foundation是底层框架，它的对象并不在ARC管理下，所以需要开发者自己去维护这些对象的引用计数。</p>
<p><strong>2、Core Foundaton 的作用</strong><br>至于它的作用，这里有一段英文解释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">The programming interfaces of Core Foundation objects have been designed for ease of use and reuse. At a general level, Core Foundation:</div><div class="line">    Enables sharing of code and data among various frameworks and libraries.</div><div class="line">    Makes some degree of operating-system independence possible .</div><div class="line">    Supports internationalization with Unicode strings.</div><div class="line">    Provides common API and other useful capabilities, including a plug-in architecture, XML property lists, and preferences.</div><div class="line">Core Foundation makes it possible for the different frameworks and libraries on OS X to share code and data. Applications, libraries, and frameworks can define C routines that incorporate Core Foundation types in their external interfaces; they can thus communicate data—as Core Foundation objects—to each other through these interfaces.</div></pre></td></tr></table></figure>
<p>翻译后，大致意思是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Core Foundation对象的编程接口已设计为易于使用和重用。 在一般的意义，Core Foundation：</div><div class="line">     1、支持在各种框架和库之间共享代码和数据</div><div class="line">     2、使某种程度的操作系统独立性成为可能</div><div class="line">     3、支持使用Unicode字符串进行国际化</div><div class="line">     4、提供通用API和其他有用的功能，包括插件架构，XML属性列表和首选项</div><div class="line">Core Foundation使得OS X上的不同框架和库可以共享代码和数据。 应用程序，库和框架可以定义在其外部接口中并入Core Foundation类型的C例程; 它们因此可以通过这些接口将数据作为Core Foundation对象传递到彼此。</div></pre></td></tr></table></figure>
<p><strong>三、Objective-C 和 Core Foundation 对象之间转换</strong></p>
<p>iOS允许Objective-C 和 Core Foundation 对象之间可以轻松的转换。</p>
<p>在《iOS开发进阶》一书中，唐巧提到：在ARC下，有时候需要将一个Core Foundation对象转换成一个Object-C对象，这个时候我们需要告诉编译器，转换过程中引用计数需要如何调整，这时也会用到bridge这个关键字。</p>
<ul>
<li>__bridge: 只做类型转换，不修改相关对象的引用计数，原来的Core Foundation对象在不用时，需要调用CFRelease方法。</li>
<li>__bridge_retained: 类型转换后将相关对象的引用计数加1，原来的Core Foundation对象在不用时，需要调用CFRelease方法。</li>
<li>__bridge_transfer: 类型转换后，将该对象的引用计数交给ARC管理，Core Foundation对象在不用时，不再需要调用CFRelease方法。</li>
</ul>
<hr>
<p><code><strong>__bridge</strong></code></p>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">    id obj = [[NSObject alloc]init];</div><div class="line">//    void *a = obj;</div><div class="line">//    id b = a;</div><div class="line">    void *c = (__bridge void *)(obj);//只做类型转换，不修改相关对象的引用计数</div><div class="line">    NSLog(@&quot;obj-c count is %ld&quot;, CFGetRetainCount(c));//输出结果： obj-c count is 1</div><div class="line">    id d = (__bridge id)(c); </div><div class="line">    NSLog(@&quot;obj-d retainCount %ld&quot;,CFGetRetainCount((__bridge CFTypeRef)(d)));//输出结果：obj-d retainCount 2</div><div class="line">    NSLog(@&quot;\n obj=%@,\n c=%@,\n d=%@\n&quot;,obj,c,d);</div><div class="line">    //__bridge</div><div class="line">    CFStringRef CFString = CFStringCreateWithCString(kCFAllocatorDefault, &quot;hello Core Foundation&quot;, kCFStringEncodingASCII);</div><div class="line">    NSLog(@&quot;CFString retainCount= %ld&quot;,CFGetRetainCount(CFString));//CFString retainCount= 1</div><div class="line">    NSString *string = (__bridge NSString *)CFString;</div><div class="line">    NSLog(@&quot;CFstring==%@,\nstring==%@\n&quot;,CFString,string);</div><div class="line">    NSString *qStr = @&quot;qgh&quot;;</div><div class="line">    CFStringRef qCFStr = (__bridge CFStringRef)qStr;</div><div class="line">    NSLog(@&quot;qStr==%@,qCFStr==%@\n&quot;,qStr,qCFStr);</div><div class="line">    NSArray *array = @[@&quot;a&quot;,@&quot;b&quot;,@&quot;c&quot;,@&quot;d&quot;,@&quot;e&quot;,@&quot;f&quot;,@&quot;g&quot;,@&quot;h&quot;];</div><div class="line">    CFArrayRef CFArray = (__bridge CFArrayRef)(array);</div><div class="line">    NSLog(@&quot;CFArray retainCount= %ld&quot;,CFGetRetainCount(CFArray));//CFArray retainCount= 1</div><div class="line">    NSLog(@&quot;array==%@&quot;,CFArray);</div></pre></td></tr></table></figure>
<hr>
<p><strong><code>__bridge_transfer</code></strong></p>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//__bridge_transfer:类型转换后，将该对象的引用计数交给ARC管理.</div><div class="line">NSString *transferString = [[NSString alloc]initWithFormat:@&quot;test:::__bridge_transfer&quot;];</div><div class="line">CFStringRef CFTransferString = (__bridge_retained CFStringRef)(transferString);</div><div class="line">NSLog(@&quot;CFTransferString count is %ld&quot;, CFGetRetainCount(CFTransferString));//CFTransferString count is 2</div><div class="line">transferString = (__bridge_transfer NSString *)(CFTransferString);</div><div class="line">NSLog(@&quot;transferString count is %ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(transferString)));//transferString count is 1</div></pre></td></tr></table></figure>
<hr>
<p><strong><code>__bridge_retained</code></strong></p>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//__bridge_retained: 类型被转换时，其对象的所有权也将被变换后变量所持有</div><div class="line">void *y = 0;</div><div class="line">id object = [[NSObject alloc]init];</div><div class="line">y = (__bridge_retained void*)(object);//类型转换后将相关对象的引用计数加1</div><div class="line">NSLog(@&quot;object-y count is %ld&quot;, CFGetRetainCount(y));//object-y count is 2</div><div class="line">NSLog(@&quot;class=%@&quot;,[(__bridge id)(y) class]);</div></pre></td></tr></table></figure>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇知识比较偏，是偏低层一些的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一：__birdge&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于&lt;code&gt;__bridge&lt;/code&gt;很少接触，所以专门去查找了一下。其实它的作用很简单，就是：实现&lt;code&gt;id&lt;/code&gt;类型与&lt;code&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="https:guohuaden.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>借我</title>
    <link href="https:guohuaden.com/2017/03/12/borrow-me/"/>
    <id>https:guohuaden.com/2017/03/12/borrow-me/</id>
    <published>2017-03-12T01:44:16.000Z</published>
    <updated>2017-03-13T02:18:33.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>借我一个暮年，</strong></p>
<p><strong>借我碎片，</strong></p>
<p><strong>借我瞻前与顾后，</strong></p>
<p><strong>借我执拗如少年。</strong></p>
<p><strong>借我后天长成的先天，</strong></p>
<p><strong>借我变如不曾改变。</strong></p>
<p><strong>借我素淡的世故和明白的愚，</strong></p>
<p><strong>借我可预知的险。</strong></p>
<p><strong>借我悲怆的磊落，</strong></p>
<p><strong>借我温软的鲁莽和玩笑的庄严。</strong></p>
<p><strong>借我最初与最终的不敢，借我不言而喻的不见。</strong></p>
<p><strong>借我一场秋啊，可你说这已是冬天。</strong><br><br> </p>
<p><font color="#DC143C"><strong>注：</strong></font>这首诗感觉很特别，初次读到时是在一个好朋友发表的说说中，那时的感觉很是欢喜，也有一些自责。欢喜是因为很喜欢，而且最终还是看到了这首诗；自责是因为，这么好的一首诗，我却迟迟未曾发现，如果不是因为这个好朋友发的说说，我也许就会错过。<br><br></p>
<p><font color="#DC143C"><strong>另注：</strong></font>有人说这首诗是樊小纯写给木心的，也有人说是木心写的。我不确定，所以没有注明作者。但这并不影响我对这首诗的喜欢，我喜欢的始终是诗，跟作者的是谁关系并不太大，但写出这首诗的作者，我是很佩服的。  <br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;借我一个暮年，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;借我碎片，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;借我瞻前与顾后，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;借我执拗如少年。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;借
    
    </summary>
    
    
      <category term="诗文集" scheme="https:guohuaden.com/tags/%E8%AF%97%E6%96%87%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>我和这个世界不熟 --北岛</title>
    <link href="https:guohuaden.com/2017/03/12/I-am-not-familiar-with-this-world/"/>
    <id>https:guohuaden.com/2017/03/12/I-am-not-familiar-with-this-world/</id>
    <published>2017-03-12T01:04:32.000Z</published>
    <updated>2017-03-13T01:21:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　我和这个世界不熟。 </p>
<p>　　这并非是我安静的原因。 </p>
<p>　　我依旧有很多问题， </p>
<p>　　问南方，问故里，问希望，问距离。  <br>
　　 </p>
<p>　　我和这个世界不熟。 </p>
<p>　　这并非是我绝望的原因。 </p>
<p>　　我依旧有很多热情， </p>
<p>　　给分开，给死亡，给昨天，给安寂。  <br>
　　 </p>
<p>　　我和这个世界不熟。 </p>
<p>　　这并非是我虚假的原因。 </p>
<p>　　我依旧有很多真诚， </p>
<p>　　离不开，放不下，活下去，爱得起。  <br>
　　 </p>
<p>　　我和这个世界不熟。 </p>
<p>　　这并非是我孤寂的原因。 </p>
<p>　　我依旧有很多诉求， </p>
<p>　　需慰藉，待分享，惹心烦，告诉你。  <br>
　　 </p>
<p>　　我和这个世界不熟。 </p>
<p>　　这并非是我冷漠的原因。 </p>
<p>　　我依旧有很多动情， </p>
<p>　　为时间，为白云，为天黑，畏天命。  <br>
　　 </p>
<p>　　我和这个世界不熟。 </p>
<p>　　这并非是我逃避的原因。 </p>
<p>　　我依旧有很多憧憬， </p>
<p>　　对梦想，对记忆，对失败，对希冀。  <br>
　　 </p>
<p>　　我和这个世界不熟。 </p>
<p>　　这并非是我卑微的原因。 </p>
<p>　　我依旧有很多勇敢， </p>
<p>　　不信输，不信神，不信天，不信地。  <br>
　　 </p>
<p>　　我和这个世界不熟。 </p>
<p>　　这并非是我失落的原因。 </p>
<p>　　我依旧有很多高昂， </p>
<p>　　有存在，有价值，有独特，有意义。  <br>
　　 </p>
<p>　　我和这个世界不熟。 </p>
<p>　　这并非是我迷茫的原因。 </p>
<p>　　我依旧有很多方向， </p>
<p>　　往前走，回头望，会跳跃，会停息。  <br>
　　 </p>
<p>　　我和这个世界不熟。 </p>
<p>　　这并非是我撕裂的原因。 </p>
<p>　　我依旧有很多完整， </p>
<p>　　至少我要成全我自己。  <br>
　　 </p>
<p>　　我和这个世界不熟。 </p>
<p>　　这并非是我选择死亡或者生存的原因。 </p>
<p>　　我依旧有很多选择， </p>
<p>　　刚巧，这两者，都不是选项之一。  <br>
　　</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　我和这个世界不熟。 &lt;/p&gt;
&lt;p&gt;　　这并非是我安静的原因。 &lt;/p&gt;
&lt;p&gt;　　我依旧有很多问题， &lt;/p&gt;
&lt;p&gt;　　问南方，问故里，问希望，问距离。  &lt;br&gt;
　　 &lt;/p&gt;
&lt;p&gt;　　我和这个世界不熟。 &lt;/p&gt;
&lt;p&gt;　　这并非是我绝望的原因。 &lt;/p&gt;

    
    </summary>
    
    
      <category term="诗文集" scheme="https:guohuaden.com/tags/%E8%AF%97%E6%96%87%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>iOS之防止用户重复点击Button（按钮）问题</title>
    <link href="https:guohuaden.com/2017/03/10/Repeat-ButtonClick/"/>
    <id>https:guohuaden.com/2017/03/10/Repeat-ButtonClick/</id>
    <published>2017-03-10T06:46:31.000Z</published>
    <updated>2017-03-10T06:59:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>在项目中，我们往往会遇到这样的问题：因为网络较慢的原因，用户会不耐烦的一直去点击按钮，这样导致的结果时：相关代码一遍一遍的被重复执行，如果按钮的事件是网络请求的话，这样又导致一种网络请求的循环。所以我们解决的方法是在执行按钮点击事件时，为<code>Button</code>加上防止重复点击的方法。</p>
<p>具体的有以下几种方法：</p>
<font color="#0B1746"><strong>1、使用<code>performSelector</code>方法</strong></font>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay;</div></pre></td></tr></table></figure>
<p>我们在点击事件中添加延迟执行事件，在延迟的这个期间，该按钮的<code>enabled</code>设置为NO，即不能点击。过了延迟时间后再设置为<code>YES</code>。以这种方式防止用户重复点击按钮。</p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">-(void)buttonClicked:(id)sender</div><div class="line">&#123;</div><div class="line">   sender.enabled = NO;</div><div class="line">  //防止用户重复点击</div><div class="line">  	[self performSelector:@selector(changeButtonStatus:) withObject:nil afterDelay:1.0f];</div><div class="line">&#125;</div><div class="line">-(void)changeButtonStatus:(id)sender</div><div class="line">&#123;</div><div class="line">    sender.enabled = YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上的方法可以很好的解决我们重复点击按钮的问题，但更推荐的却是下面的这种方法：</p>
<font color="#0B1746"><strong>2、使用<code>cancelPreviousPerformRequestsWithTarget</code> 和  <code>performSelector</code> 结合的方法（推荐使用</strong>）</font>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">+ (void)cancelPreviousPerformRequestsWithTarget:(id)aTarget selector:(SEL)aSelector object:(nullable id)anArgument;</div><div class="line">- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay;</div></pre></td></tr></table></figure>
<p>原理是：我们每次点击按钮时，先执行取消之前的按钮点击执行事件，然后再去执行一个延迟执行方法（方法中执行的是按钮执行的事件）。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (void)buttonClicked:(id)sender</div><div class="line">&#123;</div><div class="line">    //在这里做按钮的想做的事情。</div><div class="line">&#125;</div><div class="line">- (void)starButtonClicked:(id)sender</div><div class="line">&#123;</div><div class="line">    //先将未到时间执行前的任务取消。</div><div class="line">    [[self class] cancelPreviousPerformRequestsWithTarget:self selector:@selector(buttonClicked:)object:sender];</div><div class="line">    [self performSelector:@selector(buttonClicked:)withObject:sender afterDelay:0.2f];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第二种是我们比较推荐的方法，但这两种方法都可以解决按钮被重复点击的问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在项目中，我们往往会遇到这样的问题：因为网络较慢的原因，用户会不耐烦的一直去点击按钮，这样导致的结果时：相关代码一遍一遍的被重复执行，如果按钮的事件是网络请求的话，这样又导致一种网络请求的循环。所以我们解决的方法是在执行按钮点击事件时，为&lt;code&gt;Button&lt;/code
    
    </summary>
    
    
      <category term="iOS" scheme="https:guohuaden.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>服务器返回的json数据中含有null的处理方法</title>
    <link href="https:guohuaden.com/2017/03/06/json-dataNull/"/>
    <id>https:guohuaden.com/2017/03/06/json-dataNull/</id>
    <published>2017-03-06T05:33:53.000Z</published>
    <updated>2017-03-10T05:49:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>因为有遇到过类似情况，所以就想到了一些解决方法，并且实践了一下，这里简单的做个记录。</p>
<p><strong>注：</strong>有看到不少的评价，有说后台责任，也有说怪移动端没有做容错处理。我这里就事论事的说下，移动端从服务器得到的数据中确实是不应该包含<code>null</code>的，因为这本身就是不合理的。（当然，我的就事论事是站在iOS立场上说的，这个无可厚非）。</p>
<p>下面👇说一下想到的几种方法：</p>
<p><strong>一、 对于所有使用到的json中的对象做判断（当然这是最笨的方法）</strong></p>
<pre><code>NSString *msg ;
if ([str isKindOfClass: [NSNull class]]){
    NSLog(@&quot;str 为空！&quot;);
}
//或者使用[str isEqual:[NSNull null]]
</code></pre><p>为什么首先说这种方法呢，大抵是因为这个方法的工作量比较大吧。但有时候你是完全不能避免这种情况的，尤其是在老旧的项目中，当你看到项目中所有的解析都是<code>KVO</code>模式时，你就知道一个个去判断是多么让人纠结的事情了。</p>
<hr>
<p><strong>二、使用<code>JSONModel</code>等第三方json解析库</strong>  </p>
<p><code>JSONModel</code>有专门针对对象为<code>null</code>的处理，使其返回<code>“<null>“</null></code>。iOS移动端赋值为<code>nil</code>。</p>
<hr>
<p><strong>三、有一个专门针对数据为<code>null</code>的处理库，<code>NullSafe</code></strong></p>
<p>这个库是专门处理对象为null的。只有一个<code>.m</code>文件。使用也简单，因为你只需要添加到项目中就可以了，不再需要引入头文件等其他任意操作。</p>
<p>这里放一个我测试是使用的简单demo</p>
<p><a href="https://github.com/Wheat-Qin/Data_null_test" target="_blank" rel="external">github:data_nullDemo</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为有遇到过类似情况，所以就想到了一些解决方法，并且实践了一下，这里简单的做个记录。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;有看到不少的评价，有说后台责任，也有说怪移动端没有做容错处理。我这里就事论事的说下，移动端从服务器得到的数据中确实是不应该包含&lt;code
    
    </summary>
    
    
      <category term="iOS" scheme="https:guohuaden.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>WebView 打不开问题 (转码问题)</title>
    <link href="https:guohuaden.com/2017/02/27/WebView-ErrorOpen/"/>
    <id>https:guohuaden.com/2017/02/27/WebView-ErrorOpen/</id>
    <published>2017-02-27T01:56:54.000Z</published>
    <updated>2017-03-08T02:23:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>无意中遇到一个问题，项目中使用<code>UIWebView</code>打不开<code>web</code>界面，检查过<code>URL</code>和代码，发现并没有问题。随考虑到一点：<strong>URL中包含汉字</strong>。</p>
<p>处理如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">NSString *URLString = [NSString stringWithFormat:@&quot;%@id=%@&amp;email=%@&quot;,ProviderOrder,self.orderID,emailStr];</div><div class="line">//方法是用来进行转码的，即将汉字转码</div><div class="line">NSString *encodedString1 = [URLString stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLQueryAllowedCharacterSet]];</div><div class="line">//该方法用来进行转码的，即将汉字转码（在Xcode7中，iOS9）</div><div class="line">//NSString *encodedString = [URLString stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];</div><div class="line">NSURL *url =[NSURL URLWithString:[NSString stringWithFormat:@&quot;%@&quot;,encodedString1]];</div><div class="line">self.webView = [[UIWebView alloc]initWithFrame:self.view.bounds];</div><div class="line">self.webView.delegate = self;</div><div class="line">NSURLRequest *request = [NSURLRequest requestWithURL:url ];</div><div class="line">[self.webView loadRequest:request];</div><div class="line">[self.view addSubview:self.webView];</div></pre></td></tr></table></figure>
<p>上面为什么推荐使用<br><code>(NSString *)stringByAddingPercentEncodingWithAllowedCharacters:(NSCharacterSet *)allowedCharacters</code>,<br>这里是文档中给出的解释：</p>
<p><strong>其一：</strong></p>
<pre>
Use -stringByAddingPercentEncodingWithAllowedCharacters: instead, 
which always uses the recommended UTF-8 encoding, 
and which encodes for a specific URL component or subcomponent since each URL component or subcomponent has different rules for what characters are valid.
</pre>

<p>翻译如下：</p>
<p>使用<code>-stringByAddingPercentEncodingWithAllowedCharacters：</code>改为，<br>它总是使用推荐的<code>UTF-8</code>编码，<br>并且其对特定的URL组件或子组件进行编码，因为每个URL组件或子组件对于什么字符是有效的具有不同的规则。</p>
<p><strong>其二：</strong></p>
<pre>
Returns a new string made from the receiver by replacing all characters not in the allowedCharacters set with percent encoded characters. 
UTF-8 encoding is used to determine the correct percent encoded characters. 
Entire URL strings cannot be percent-encoded. 
This method is intended to percent-encode an URL component or subcomponent string, NOT the entire URL string. 
Any characters in allowedCharacters outside of the 7-bit ASCII range are ignored.
</pre>

<p>翻译如下：</p>
<p>通过替换不在allowedCharacters中的所有字符，使用百分比编码字符返回从接收器创建的新字符串。 UTF-8编码用于确定正确的百分比编码字符。 整个URL字符串不能进行百分号编码。 此方法旨在对URL组件或子组件字符串（而不是整个URL字符串）进行百分比编码。 将忽略7位ASCII范围之外的allowedCharacters中的任何字符。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无意中遇到一个问题，项目中使用&lt;code&gt;UIWebView&lt;/code&gt;打不开&lt;code&gt;web&lt;/code&gt;界面，检查过&lt;code&gt;URL&lt;/code&gt;和代码，发现并没有问题。随考虑到一点：&lt;strong&gt;URL中包含汉字&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;处理如下：&lt;
    
    </summary>
    
    
      <category term="iOS" scheme="https:guohuaden.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>对于Xcode中 Build Active Architecture Only 的认识</title>
    <link href="https:guohuaden.com/2017/02/16/Build-Active-Architecture-Only-Query/"/>
    <id>https:guohuaden.com/2017/02/16/Build-Active-Architecture-Only-Query/</id>
    <published>2017-02-16T07:11:12.000Z</published>
    <updated>2017-02-16T08:57:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前在给项目适配64位时，看到Xcode中有这个设置，因为关系到适配问题，又比较好奇，就了解了一番。发现这个设置也有不小的作用。</p>
<p><img src="http://obzx0h1re.bkt.clouddn.com/Build%20Active%20Architecture%20Only2.png" alt="Build Active Architecture Only2"></p>
<font color="#9ACD32"><code>Build Active Architecture Only</code>：指定是否只对当前连接设备所支持的指令集编译</font>

<p>系统默认是：Debug设置为<code>Yes</code>，Release设置为<code>No</code>。</p>
<p><strong>原因</strong>是：</p>
<p>当直接把<code>Build Active Architecture Only</code> 设置为<code>Yes</code>时，可以使Debug的时候编译速度更快，因为它只编译当前的Architecture版本。</p>
<p>而如果设置为<code>No</code>，则编译的事所有的版本。</p>
<p><strong>注</strong>：<font color="#FF7F50">    其中提到的版本是Architecture的支持版本：<code>arm64</code>、<code>armv7</code>、<code>armv7s</code>、<code>i386</code>、<code>x86_64</code>等。</font></p>
<p>其中</p>
<font color="#808000"><br><strong><code>i386</code>是针对intel通用微处理器32位处理器</strong><br><br><strong><code>x86_64</code>是针对x86架构的64位处理器</strong><br><br><strong>模拟器32位处理器测试需要<code>i386</code>架构</strong><br><br><strong>模拟器64位处理器测试需要<code>x86_64</code>架构</strong><br><br><strong>真机32位处理器需要<code>armv7</code>,或者<code>armv7s</code>架构</strong><br><br><strong>真机64位处理器需要<code>arm64</code>架构</strong><br><br></font>

<p>所以我们一般默认Debug设置为<code>Yes</code>，Release设置为<code>No</code>。编译出的版本是向下兼容的，连接的设备的指令集匹配是由高到低（<code>arm64</code> &gt; <code>armv7s</code> &gt; <code>armv7</code>）依次匹配的。比如你设置此值为yes，用iphone4编译出来的是<code>armv7</code>版本的，iphone5也可以运行，但是<code>armv6</code>的设备就不能运行。  所以，一般Debug的时候可以选择设置为<code>Yes</code>，Release的时候要改为<code>No</code>，以便于适配不同的版本。<br><img src="http://obzx0h1re.bkt.clouddn.com/Build%20Active%20Architecture%20Only%20Picture.png" alt="    
Build Active Architecture Only Picture"></p>
<p><strong>但也有直接将<code>Build Active Architecture Only</code>设置为<code>No</code>的情况</strong><br><img src="http://obzx0h1re.bkt.clouddn.com/Build%20Active%20Architecture%20Only1.png" alt="Build Active Architecture Only1"></p>
<p>这样做的原因是因为使用默认设置运行项目时出现错误：<font color="#FF6347"><strong><code>Module ‘Alamofire’ has no member ‘request’</code></strong></font><br>解决方法就是直接都设置为<code>No</code>。</p>
<p><font color="#008000"><strong>问题</strong>：</font><br><img src="http://obzx0h1re.bkt.clouddn.com/Module%20%27Alamofire%27%20has%20no%20member%20%27request%27.png" alt="Module &#39;Alamofire&#39; has no member &#39;request&#39;"></p>
<p><font color="#008000"><strong>方法</strong>：</font><br><img src="http://obzx0h1re.bkt.clouddn.com/Module%20%27Alamofire%27%20has%20no%20member%20%27request%27-answer.png" alt="Module &#39;Alamofire&#39; has no member &#39;request&#39;-answer"></p>
<p>一些有益非浅的链接：</p>
<p><a href="http://blog.csdn.net/lizhongfu2013/article/details/42387311" target="_blank" rel="external">iOS开发～制作同时支持armv7,armv7s,arm64,i386,x86_64的静态库.a</a></p>
<p><a href="http://www.cnblogs.com/hikoming/p/3708659.html" target="_blank" rel="external">Xcode的Architectures、Valid Architectures和Build Active Architecture Only属性(原创)</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前在给项目适配64位时，看到Xcode中有这个设置，因为关系到适配问题，又比较好奇，就了解了一番。发现这个设置也有不小的作用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://obzx0h1re.bkt.clouddn.com/Build%20Active%20Archi
    
    </summary>
    
    
      <category term="Xcode" scheme="https:guohuaden.com/tags/Xcode/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊WKWebView</title>
    <link href="https:guohuaden.com/2017/02/11/WKWebView/"/>
    <id>https:guohuaden.com/2017/02/11/WKWebView/</id>
    <published>2017-02-11T02:33:52.000Z</published>
    <updated>2017-02-14T00:57:40.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>由于之前一直在用<code>UIWebView</code>,所以对于<code>WKWebView</code>只是停留在知道，了解的状态，并未深入的去研究。前天一个项目要求支持iOS8以上，要加入一个web界面。在习惯性使用<code>UIWebView</code>写到一半的时候，突然想使用<code>WKWebView</code>去实现，所以专门花费了些时间去研究了一下<code>WKWebView</code>，很是喜欢。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>接下来纪录一下使用<code>WKWebView</code>的过程细节。但关于<code>WKWebView</code>与<code>js</code>互交的部分保留意见，因为并没有深入去研究这一点。</p>
<h3 id="1、引入WebKit库"><a href="#1、引入WebKit库" class="headerlink" title="1、引入WebKit库"></a>1、引入WebKit库</h3><p>Apple方面为使用<code>WKWebView</code>专门添加了<code>WebKit</code>库，在使用<code>WKWebView</code>时候必须引入<code>WebKit</code>库才可以。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#import &lt;WebKit/WebKit.h&gt;</div></pre></td></tr></table></figure></p>
<h3 id="2、初始化WKWebView"><a href="#2、初始化WKWebView" class="headerlink" title="2、初始化WKWebView"></a>2、初始化WKWebView</h3><p>在文档中可以看出，<code>WKWebView</code>的初始化方法有两种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (instancetype)initWithFrame:(CGRect)frame;</div><div class="line">- (instancetype)initWithFrame:(CGRect)frame configuration:(WKWebViewConfiguration *)configuration NS_DESIGNATED_INITIALIZER</div></pre></td></tr></table></figure>
<ul>
<li>我们大多使用第一种方式，这也是文档中默认的一种方式。这里不再多说。</li>
<li>关于第二种方式，其实就是在初始化<code>WKWebView</code>时，给<code>webView</code>做一个配置，我这里给出一段简单的配置代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc]init];</div><div class="line">config.preferences = [WKPreferences new];</div><div class="line">config.preferences.minimumFontSize = 20.f;</div><div class="line">config.preferences.javaScriptEnabled = YES; //The default value is YES</div><div class="line">config.preferences.javaScriptCanOpenWindowsAutomatically = NO;//The default value is NO in iOS and YES in OS X.</div><div class="line">//config.preferences.javaEnabled = NO ; //The default value is NO .不在iphone中使用的方法</div><div class="line">config.userContentController = [WKUserContentController new];  </div><div class="line">self.webView = [[WKWebView alloc]initWithFrame:self.view.bounds configuration:config];</div></pre></td></tr></table></figure>
<p><strong>注：</strong>其实第一种方式，虽然我们并没有指定初始化的配置，但Apple也为我们指定了一个默认的配置。</p>
<h3 id="3、加载网页"><a href="#3、加载网页" class="headerlink" title="3、加载网页"></a>3、加载网页</h3><p>方法有几种，我们常用的是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSURLRequest *request = [[NSURLRequest alloc]initWithURL:[NSURL URLWithString:@&quot;https://www.baidu.com&quot;]];</div><div class="line">[self.webView loadRequest:request];</div></pre></td></tr></table></figure>
<p>剩下的几种为：</p>
<pre><code>[self.webView loadHTMLString:(nonnull NSString *) baseURL:(nullable NSURL *)];

[self.webView loadFileURL:(nonnull NSURL *) allowingReadAccessToURL:(nonnull NSURL *)];

[self.webView loadData:(nonnull NSData *) MIMEType:(nonnull NSString *) characterEncodingName:(nonnull NSString *) baseURL:(nonnull NSURL *)];
</code></pre><h3 id="4、加载js代码"><a href="#4、加载js代码" class="headerlink" title="4、加载js代码"></a>4、加载js代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 图片缩放的js代码</div><div class="line">NSString *js = @&quot;var count = document.images.length;for (var i = 0; i &lt; count; i++) &#123;var image = document.images[i];image.style.width=500;image.style.height=600;&#125;;window.alert(&apos;找到&apos; + count + &apos;张图&apos;);&quot;;</div><div class="line">// 根据JS字符串初始化WKUserScript对象</div><div class="line">WKUserScript *script = [[WKUserScript alloc] initWithSource:js injectionTime:WKUserScriptInjectionTimeAtDocumentEnd forMainFrameOnly:YES];</div><div class="line">// 根据生成的WKUserScript对象，初始化WKWebViewConfiguration</div><div class="line">WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init];</div><div class="line">[config.userContentController addUserScript:script];</div><div class="line">_webView = [[WKWebView alloc] initWithFrame:self.view.bounds configuration:config];</div><div class="line">[_webView loadHTMLString:@&quot;&lt;head&gt;&lt;/head&gt;&lt;img src=&apos;http://og3hqoz3g.bkt.clouddn.com/%E5%B9%B8%E7%A6%8F%E9%82%AE%E5%B1%80.jpg&apos; /&gt;&quot;baseURL:nil];</div><div class="line">[self.view addSubview:_webView];</div></pre></td></tr></table></figure>
<h3 id="5、代理"><a href="#5、代理" class="headerlink" title="5、代理"></a>5、代理</h3><p><code>WKWebView</code>的代理有两个：<code>WKNavigationDelegate</code> 和 <code>WKUIDelegate</code></p>
<ul>
<li><strong>5.1、 WKNavigationDelegate（加载界面时调用的协议方法）</strong></li>
</ul>
<p>过程：</p>
<ol>
<li>在请求发送之前，决定是否跳转</li>
<li>页面开始加载时调用</li>
<li>在收到响应后，决定是否跳转</li>
<li>内容开始加载时调用</li>
<li>接收到服务器跳转请求之后调用（不一定调用该方法）</li>
<li>页面加载完成时调用</li>
<li>请求失败时调用</li>
</ol>
<p>协议方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">//页面开始加载时调用</div><div class="line">- (void)webView:(WKWebView *)webView didStartProvisionalNavigation:(null_unspecified WKNavigation *)navigation</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;页面开始加载时调用。   2&quot;);</div><div class="line">&#125;</div><div class="line">//内容返回时调用，得到请求内容时调用(内容开始加载) -&gt; view的过渡动画可在此方法中加载</div><div class="line">- (void)webView:(WKWebView *)webView didCommitNavigation:( WKNavigation *)navigation</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;内容返回时调用，得到请求内容时调用。 4&quot;);</div><div class="line">&#125;</div><div class="line">//页面加载完成时调用</div><div class="line">- (void)webView:(WKWebView *)webView didFinishNavigation:( WKNavigation *)navigation</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;页面加载完成时调用。 5&quot;);</div><div class="line">&#125;</div><div class="line">//请求失败时调用</div><div class="line">- (void)webView:(WKWebView *)webView didFailProvisionalNavigation:(WKNavigation *)navigation withError:(NSError *)error</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;error1:%@&quot;,error);</div><div class="line">&#125;</div><div class="line">-(void)webView:(WKWebView *)webView didFailNavigation:(WKNavigation *)navigation withError:(NSError *)error</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;error2:%@&quot;,error);</div><div class="line">&#125;</div><div class="line">//在请求发送之前，决定是否跳转 -&gt; 该方法如果不实现，系统默认跳转。如果实现该方法，则需要设置允许跳转，不设置则报错。</div><div class="line">//该方法执行在加载界面之前</div><div class="line">//Terminating app due to uncaught exception &apos;NSInternalInconsistencyException&apos;, reason: &apos;Completion handler passed to -[ViewController webView:decidePolicyForNavigationAction:decisionHandler:] was not called&apos;</div><div class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler</div><div class="line">&#123;</div><div class="line">    //允许跳转</div><div class="line">    decisionHandler(WKNavigationActionPolicyAllow);</div><div class="line">    </div><div class="line">    //不允许跳转</div><div class="line">//    decisionHandler(WKNavigationActionPolicyCancel);</div><div class="line">    NSLog(@&quot;在请求发送之前，决定是否跳转。  1&quot;);</div><div class="line">&#125;</div><div class="line">//在收到响应后，决定是否跳转（同上）</div><div class="line">//该方法执行在内容返回之前</div><div class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler</div><div class="line">&#123;</div><div class="line">    //允许跳转</div><div class="line">    decisionHandler(WKNavigationResponsePolicyAllow);</div><div class="line">    //不允许跳转</div><div class="line">//    decisionHandler(WKNavigationResponsePolicyCancel);</div><div class="line">    NSLog(@&quot;在收到响应后，决定是否跳转。 3&quot;);</div><div class="line">    </div><div class="line">&#125;</div><div class="line">//接收到服务器跳转请求之后调用</div><div class="line">- (void)webView:(WKWebView *)webView didReceiveServerRedirectForProvisionalNavigation:(null_unspecified WKNavigation *)navigation</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;接收到服务器跳转请求之后调用&quot;);</div><div class="line">&#125;</div><div class="line">-(void)webViewWebContentProcessDidTerminate:(WKWebView *)webView</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;webViewWebContentProcessDidTerminate&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>5.2、WKUIDelegate</strong></li>
</ul>
<p>这方面包括：创建新的WebView、界面弹出提示框<br><strong><em>创建新的WebView</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 创建一个新的WebView</div><div class="line">- (WKWebView *)webView:(WKWebView *)webView createWebViewWithConfiguration:(WKWebViewConfiguration *)configuration forNavigationAction:(WKNavigationAction *)navigationAction windowFeatures:(WKWindowFeatures *)windowFeatures;</div></pre></td></tr></table></figure>
<p><strong><em>界面弹出提示框</em></strong></p>
<p>系统提供了三种弹出提示框的方法：警告框、确认框、输入框</p>
<p>直接查看代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">//警告框</div><div class="line">/**</div><div class="line"> webView界面中有弹出警告框时调用</div><div class="line"> @param webView             web视图调用委托方法</div><div class="line"> @param message             警告框提示内容</div><div class="line"> @param frame               主窗口</div><div class="line"> @param completionHandler   警告框消失调用</div><div class="line"> */</div><div class="line">- (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler</div><div class="line">&#123;</div><div class="line">    completionHandler();</div><div class="line">    NSLog(@&quot;警告框&quot;);</div><div class="line">&#125;</div><div class="line">//输入框</div><div class="line">/**</div><div class="line"> web界面中弹出输入框时调用</div><div class="line"> @param webView             web视图调用委托方法</div><div class="line"> @param prompt              输入消息的显示</div><div class="line"> @param defaultText         初始化时显示的输入文本</div><div class="line"> @param frame               主窗口</div><div class="line"> @param completionHandler   输入结束后调用</div><div class="line"> */</div><div class="line">-(void)webView:(WKWebView *)webView runJavaScriptTextInputPanelWithPrompt:(NSString *)prompt defaultText:(NSString *)defaultText initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(NSString * _Nullable))completionHandler</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;输入框&quot;);</div><div class="line">    completionHandler(@&quot;http&quot;);</div><div class="line">&#125;</div><div class="line">//确认框</div><div class="line">/**</div><div class="line"> 显示一个JavaScript确认面板</div><div class="line"> @param webView             web视图调用委托方法</div><div class="line"> @param message             显示的信息</div><div class="line"> @param frame               主窗口</div><div class="line"> @param completionHandler   确认后完成处理程序调用</div><div class="line"> */</div><div class="line">-(void)webView:(WKWebView *)webView runJavaScriptConfirmPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(BOOL))completionHandler</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;确认框&quot;);</div><div class="line">    completionHandler(YES);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>以上就是WKWebView基本使用方法，其他的不做扩展和补充。也许以后再深入研究时，会有不一样的看法，到时再做推翻或补充。</em></p>
<p>以下是个人的一点看法：</p>
<ol>
<li><code>WKWebView</code>是在iOS8之后出现的新的网页加载控件，将来也必将取代<code>UIWebView</code>，这是毋庸置疑的事情。</li>
<li>关于项目优化方面：其实很多人建议在项目中添加<code>WKWebView</code>去替代<code>UIWebView</code>。以未来的发展趋势来看，这点无可厚非。</li>
</ol>
<p>我下面想说的是站在老项目并且其中内嵌网页比较多的立场的，iOS8以上使用<code>WKWebView</code>，iOS8以下使用<code>UIWebView</code>。这是目前解决方案的好办法。但维护和优化都需要成本，时间也是成本的一部分。</p>
<p>这里附上demo一份：<a href="https://github.com/Wheat-Qin/WKWebView_test" target="_blank" rel="external">WKWebView代码</a></p>
<p>这里给出几个讲解<code>WKWebView</code>的🔗,对我帮助很大：</p>
<ol>
<li><a href="http://www.brighttj.com/ios/ios-wkwebview-new-features-and-use.html" target="_blank" rel="external">WKWebView的新特性与使用</a></li>
<li><a href="http://www.jianshu.com/p/6ba2507445e4" target="_blank" rel="external">使用WKWebView替换UIWebView</a> </li>
<li><a href="http://www.cnblogs.com/junhuawang/p/5759224.html" target="_blank" rel="external">UIWebView、WKWebView使用详解及性能分析</a></li>
<li><a href="http://www.jianshu.com/p/7bb5f15f1daa" target="_blank" rel="external">WKWebView学习笔记</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;由于之前一直在用&lt;code&gt;UIWebView&lt;/code&gt;,所以对于&lt;code&gt;WKWebView&lt;/code&gt;只是停留在知道，了解的状态
    
    </summary>
    
    
      <category term="iOS" scheme="https:guohuaden.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>关于app支持64bit</title>
    <link href="https:guohuaden.com/2017/01/15/support-64bit/"/>
    <id>https:guohuaden.com/2017/01/15/support-64bit/</id>
    <published>2017-01-15T07:18:34.000Z</published>
    <updated>2017-01-16T02:13:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于iOS应用，其实苹果很早就就发布消息：2015年的2月开始，提交App Store的应用必须支持64-bit。而Apple在iPhone 5s 就已经搭配64位双核苹果A7处理器。还是在15年6月，苹果App Store中所有应用更新都必须支持64bit。</p>
<p>但这对于企业级应用来说，并不能限制应用去支持64bit，因为企业级应用不必提交App Store审核。但Apple又有了新的对策：在iOS 10.1测试版中加入了一项提示，如果用户下载的是一个32位应用，系统会提示<code>“XXX”可能使iPhone变慢，应用开发者需要更新此应用以改进其兼容性。</code></p>
<p><img src="http://obzx0h1re.bkt.clouddn.com/64Bit-Prompt.jpg" alt="提示效果图"><br>现在看来Apple这种方式，可算是最有效的方式了，因为这样会直接导致用户对一个应用的不同态度。甚至是不止降低用户量。如果是企业级用户，可以直接引起用户的强烈不满。</p>
<p>不管怎么说，作为一个iOS开发者，既然Apple已经提出，还是要去支持64-bit。</p>
<p>具体做法：<br><img src="http://obzx0h1re.bkt.clouddn.com/64Bit-Work.png" alt="方法如图"></p>
<p>关于Xcode <code>“Build Setting”</code>中的<code>Architectures</code>参数问题：</p>
<ul>
<li><p><code>Architectures</code>：你想支持的指令集。（支持指令集是通过编译生成对应的二进制数据包实现的，如果支持的指令集数目有多个，就会编译出包含多个指令集代码的数据包，造成最终编译的包很大。）</p>
</li>
<li><p><code>Valid architectures</code>：即将编译的指令集。（<code>Valid architectures</code> 和 <code>Architecture</code>两个集合的交集为最终编译生成的版本）</p>
</li>
<li><p><code>Build Active Architecture Only</code>：是否只编译当前设备适用的指令集（如果这个参数设为YES，使用iPhone 6调试，那么最终生成的一个支持ARM64指令集的Binary。一般在DEBUG模式下设为YES，RELEASE设为NO）</p>
</li>
</ul>
<p>对于支持64-bit,我们可以设置<code>Architectures</code>为 <code>Standard architectures</code>，它包括 <code>armv7、armv7s 和 arm64</code>。</p>
<p>而是对于代码中的改变其实也就分为：<strong>数据类型和方法调用</strong> 两个部分。</p>
<p>比如：<code>int -&gt; NSInteger</code></p>
<p>以及得到数组个数的方法：<code>[dataArray count] -&gt; dataArray.count</code></p>
<p>这是关于数据类型改变的总结：<br><img src="http://obzx0h1re.bkt.clouddn.com/64bit-Summary.png" alt="64bit-Summary"><br>上图所说：</p>
<ul>
<li>避免将长整型long赋值给整型int (64-bit上会导致数据丢失)</li>
<li>避免将指针类型pointer赋值给整型int (64-bit导致地址数据丢失)。</li>
<li>留意数值计算，避免指针和长整型在运算上的截断问题(掩码计算,无符号整数和有符号整数同时使用等)。</li>
<li>留意对齐方法带来的变化。</li>
<li>32-bit到64-bit之间数据转化(通过网络传递的用户数据，可能同时存在于32-bit和64-bit的环境下)。</li>
<li>重写汇编代码，让你的代码使用新的64-bit操作码和运行时。</li>
<li>不要在可变参数方法和不可变参数方法之前进行强制转化。</li>
</ul>
<p>具体可以看：《<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/CocoaTouch64BitGuide/Major64-BitChanges/Major64-BitChanges.html" target="_blank" rel="external">64-Bit Transition Guide for Cocoa Touch</a>》</p>
<p>关于iOS应用支持64位的一些详情，可以看看这篇不错的文章：<br>《<a href="http://www.codeceo.com/article/ios-64-bit.html" target="_blank" rel="external">iOS应用如何实现64位的支持</a>》</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于iOS应用，其实苹果很早就就发布消息：2015年的2月开始，提交App Store的应用必须支持64-bit。而Apple在iPhone 5s 就已经搭配64位双核苹果A7处理器。还是在15年6月，苹果App Store中所有应用更新都必须支持64bit。&lt;/p&gt;
&lt;p
    
    </summary>
    
    
      <category term="iOS" scheme="https:guohuaden.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS之项目总结二：关于项目中一些功能的改进建议（从一个维护者的角度）</title>
    <link href="https:guohuaden.com/2017/01/11/project-summary-two/"/>
    <id>https:guohuaden.com/2017/01/11/project-summary-two/</id>
    <published>2017-01-11T15:38:00.000Z</published>
    <updated>2017-01-14T02:11:44.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>最近一直在维护老的项目，遇到的问题也千奇百怪，需要修补的，需要优化的，需要特殊处理的，感觉总是那么的无语。也许这时候也应该感叹一句：路漫漫其修远兮，吾将上下而求索吧。<br>这篇文章就只是讲讲老项目中遇到的种种不敢苟同的代码写法，以及遇到一些问题时的处理方法。</p>
<h3 id="1、关于按钮事件的重复点击问题"><a href="#1、关于按钮事件的重复点击问题" class="headerlink" title="1、关于按钮事件的重复点击问题"></a>1、关于按钮事件的重复点击问题</h3><p>我们开发中大概都经历过这样的事情，我的一个<code>button</code>被重复的快速点击，（我们开发者应该更清楚的知道这意味着什么）。那我们再深入的想一下（给这样的事件安排一个特定的环境）：例如当网络较差的情况下，再例如当<code>button</code>的执行事件较为耗时时。这时就会出现很多的问题：有时是界面出现问题（当<code>button</code>执行事件中出现调节界面<code>frame</code>的时候）；有时则会出现卡顿，更甚至会出现崩溃现象。对于这种问题，我们要提前考虑到，做好防范处理：即点击按钮事件时,添加防止重复点击功能。</p>
<p><strong>思路是</strong>：防止按钮重复点击<br>比较推荐的解决方法代码：</p>
<pre> - (void)btnClicked:(id)sender {
    //在这里做按钮的想做的事情。
}
- (void)buttonClicked:(id)sender {
   //先将未到时间执行前的任务取消。
    [[self class] cancelPreviousPerformRequestsWithTarget:self selector:@selector(btnClicked:)object:sender];
    [self performSelector:@selector(btnClicked:)withObject:sender afterDelay:0.2f];
}</pre>

<p><strong>原理是</strong> ：我们每次点击按钮时，先执行取消之前的按钮点击执行事件，然后再去执行一个延迟执行方法（方法中执行的是按钮执行的事件）。</p>
<p>还有一种方法也是可以实现的：具体的看《<a href="http://www.cnblogs.com/LQCQ-Silent/p/6082086.html" target="_blank" rel="external">iOS之防止用户重复点击Button（按钮）问题</a> 》</p>
<h3 id="2、很多界面共用一个界面时：使用枚举做类型判断"><a href="#2、很多界面共用一个界面时：使用枚举做类型判断" class="headerlink" title="2、很多界面共用一个界面时：使用枚举做类型判断"></a>2、很多界面共用一个界面时：使用枚举做类型判断</h3><p>老的项目中会出现很多这样的现象：很多界面重复使用一个界面，这样就自然而然的需要在不同的界面跳转到复用的界面时去做判断。而奇怪的地方在于：判断的依据是<code>self.title</code>。那么就会出现这样一种现象：在跳转界面后会有一大段<code>if</code>去判断字符串是否等于<code>self.title</code> 。</p>
<p><strong>如果我们做一些改变：使用枚举来做界面类型的判断，使用<code>switch case</code>语句做判断执行代码。这样会不会更优美，简洁一些。</strong></p>
<h3 id="3、关于老项目中iOS10以上的情况下，导航栏中按钮不显示问题"><a href="#3、关于老项目中iOS10以上的情况下，导航栏中按钮不显示问题" class="headerlink" title="3、关于老项目中iOS10以上的情况下，导航栏中按钮不显示问题"></a>3、关于老项目中iOS10以上的情况下，导航栏中按钮不显示问题</h3><p>如果你的<code>viewController</code>都继承于基类，那么在基类中添加这样一段代码（这也是目前我发现的最省事的方法）：</p>
<pre>- (void)viewWillAppear:(BOOL)animated { 
    [super viewWillAppear:animated];
    [self.navigationController setNavigationBarHidden:YES animated:NO];
    [self.navigationController setNavigationBarHidden:NO animated:NO];
}
- (void)viewWillDisappear:(BOOL)animated {
    [super viewWillDisappear:animated];
    [self.navigationController setNavigationBarHidden:YES animated:NO];
    [self.navigationController setNavigationBarHidden:NO animated:NO];
}</pre>



<h3 id="4、事件方法要每个界面区分开"><a href="#4、事件方法要每个界面区分开" class="headerlink" title="4、事件方法要每个界面区分开"></a>4、事件方法要每个界面区分开</h3><p>老项目中会有这种情况：在本界面 command点击一个<code>button</code>执行事件方法或者手势事件方法时，会莫名其妙的跳转到另外一个界面。<br>我们在开发时最好给不同界面<code>button</code>的<code>clicked</code>事件命名是区分开来，例如：界面名 + <code>ButtonClicked</code></p>
<h3 id="5、对象为空现象"><a href="#5、对象为空现象" class="headerlink" title="5、对象为空现象"></a>5、对象为空现象</h3><p>在开发中如果存在<code>image</code>为空，或者必须显示的<code>String</code>为空现象，<br>记得在代码中作判断，图片可以直接设置默认图片，字符串也可以设置默认字符串<br>这一点可以学一下SDWebImage库中对于网络请求图片不存在的处理方法：</p>
<p><pre>//给一张默认图片，先使用默认图片，当图片加载完成后再替换<br>[self.image1 sd_setImageWithURL:imagePath1 placeholderImage:[UIImage imageNamed:@”default”]];</pre>例如：</p>
<p><pre><br>UIImage *image = [UIImage imageNamed:@”image”];</pre></p>
<p>UIImage *defaultImage = [UIImage imageNamed:@”defaultImage”];</p>
<p>UIImageView *imageView = [[UIImageView alloc]initWithImage:image==nil ?  image:defaultImage];<br>字符串当然也是类似，其实看似有些费事甚至有的显得多余的写法，会使以后的维护变得更加的如意。</p>
<h3 id="6、一个界面多网络请求问题，而且需要多个请求都完成后，对界面有一些操作。"><a href="#6、一个界面多网络请求问题，而且需要多个请求都完成后，对界面有一些操作。" class="headerlink" title="6、一个界面多网络请求问题，而且需要多个请求都完成后，对界面有一些操作。"></a>6、一个界面多网络请求问题，而且需要多个请求都完成后，对界面有一些操作。</h3><p>这是一个老的话题了，我之所以重新提及这个话题，原因是我从一些文章中发现了一个从来没使用过的方法，这个下面会提到，现在就让我们列举出来比较常用的方法。就以一个界面两个网络请求为例 A和B.</p>
<p><strong>（1）两个请求互套)(也是最笨的方法)</strong><br>     具体是这样的，我在A请求成功后，再请求B。当然如果请求多的话，这个肯定是作废的。</p>
<p><strong>（2）使用GCD中的通知</strong></p>
<p><pre>dispatch_group_t serviceGroup = dispatch_group_create();<br>// 开始第一个网络请求<br>servicedispatch_group_enter(serviceGroup);<br>[self.configService startWithCompletion:^(ConfigResponse <em>results, NSError </em>error) {<br> //请求成功后的操作<br>    configError = error;<br>    dispatch_group_leave(serviceGroup);//完成后离开分组<br>}];<br>// 开始第二个请求<br>dispatch_group_enter(serviceGroup);<br>[self.preferenceService startWithCompletion:^(PreferenceResponse <em>results, NSError </em>error) {<br> //请求成功后的操作<br>    preferenceError = error;<br>    dispatch_group_leave(serviceGroup);//完成后离开分组<br>}];<br>dispatch_group_notify(serviceGroup,dispatch_get_main_queue(),^{<br> // Assess any errors<br>     NSError *overallError = nil;<br>    if (configError || preferenceError)  {<br> // 判断时候请求有失败<br>        overallError = configError ?: preferenceError;<br>     }<br>// 最后完成后执行的block<br>    completion(overallError);<br>});<br></pre></p>
<p><strong>（3）利用GCD中的信号量</strong></p>
<p>在GCD中有三个函数是<code>semaphore</code>的操作，分别是：　　<br><code>dispatch_semaphore_create</code> 创建一个semaphore　　<br><code>dispatch_semaphore_signal</code> 发送一个信号　<br><code>dispatch_semaphore_wait</code> 等待信号　　<br>简单的介绍一下这三个函数，第一个函数有一个整形的参数，我们可以理解为信号的总量，<code>dispatch_semaphore_signal</code>是发送一个信号，自然会让信号总量加1，<code>dispatch_semaphore_wait</code>等待信号，当信号总量少于0的时候就会一直等待，否则就可以正常的执行，并让信号总量-1，根据这样的原理，我们便可以快速的创建一个并发控制来同步任务和有限资源访问控制。</p>
<p>利用这样的机制，当信号量达到我们网络请求的数量时，请求结束。</p>
<p><strong>（4）这个也是我上面说的无意中看到的一个方法，仅拿出来作为参考</strong></p>
<p><pre>dispatch_async(concurrent_queue, ^{<br>     NSLog(@”—并发任务1—“);<br>});<br>dispatch_async(concurrent_queue, ^{<br>     NSLog(@”—并发任务2—“);<br>});<br>dispatch_barrier_async(concurrent_queue, ^{<br>    dispatch_async(dispatch_get_main_queue(), ^{<br>        NSLog(@”—所有并发任务结束后回到主线程刷新—“);<br>    });<br>}); </pre></p>
<p>以上就是关于一界面多请求的不同解决方案。</p>
<h3 id="7、代码规范问题"><a href="#7、代码规范问题" class="headerlink" title="7、代码规范问题"></a>7、代码规范问题</h3><ul>
<li>为什么这个普通的话题放到最后呢，大概是因为我觉得这个很重要的问题吧，毕竟技术水平不高，还是可以提升的。但代码不规范的话，养成习惯后很难改的，我见过太多项目中使用【拼音命名、不注意驼峰命名法、define预处理指令满天飞等等的代码】这些出现在项目中就像时时刻刻在提醒你，看这样的项目是一种煎熬。</li>
<li>其实代码规范不仅仅是公司对开发者的要求,也是开发者对自己的一个要求。因为如果统一每个人的写作规范，是一件耗时，耗材的事情。小一些的公司是做不来，中型的公司大多是不想做。而大型的公司总是花费近几个月的时间去培养员工的代码规范，这就是财大气粗吧。而且开发者本身对于技术的提升、追求等，都无形中要求自己注意代码规范问题。</li>
<li>对于这部分，建议看看《Effective Objective-C 2.0》这本书，其中起到的。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h3&gt;&lt;p&gt;最近一直在维护老的项目，遇到的问题也千奇百怪，需要修补的，需要优化的，需要特殊处理的，感觉总是那么的无语。也许这时候也应该感叹一句：
    
    </summary>
    
    
      <category term="iOS" scheme="https:guohuaden.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>SVN提交错误：&quot;XXX&quot; is scheduled for addition, but is missing</title>
    <link href="https:guohuaden.com/2016/12/15/SVN-error/"/>
    <id>https:guohuaden.com/2016/12/15/SVN-error/</id>
    <published>2016-12-15T03:18:00.000Z</published>
    <updated>2017-01-15T07:14:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>最近在维护老项目，所以出现了很多以前没遇到过的问题。也算见识一番吧。<br>目前所在的公司使用SVN作为版本控制器，所以接下来这个问题也是就关于SVN的。</p>
<h3 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h3><p>今天使用SVN提交项目时，出现了这样的提示：<pre><code>“XXX” is scheduled for addition, but is missing。（无关紧要的东西用XXX代替）。 </code></pre><br>看报错说明是这样的：<code>“XXX”已经被列为添加状态，但我们提交时却缺少”XXX”这个。</code></p>
<h3 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h3><p>之前用SVN提交过的文件/文件夹，被标记为”addition”状态，等待被加入到仓库。虽然你把这个文件删除了，SVN提交的时候还是会尝试提交这个文件，所以就会提示：<code>“but is missing”。</code><br>当然删除这个东西，就是因为它多余，不然也不会多此一举。现在出现这种错误，我们不可能再去添加上去，所以解决方法只能从SVN上着手了，首先想到的就是更新SVN配置文件。<br>我的”XXX”是这样的：<pre><code> /Users/guohua/Desktop/项目/项目名字XXX/idealservice/idealservice/Classes/External/SDWebImage/FLAnimatedImage  </code></pre>缺少的文件夹是：<code>FLAnimatedImage  。</code><br>思路是对的，那就看解决方法吧：<br><code>命令行：svn revert  将”XXX”  revert（恢复） 到它的上级目录</code><br>具体这样：<pre><code><br>svn revert  /Users/guohua/Desktop/项目/项目名字XXX/idealservice/idealservice/Classes/External/SDWebImage –depth infinity </code></pre></p>
<p>如果你SVN提示缺少<code>XXX.png</code><br>可以直接复原到这个图片位置：<pre><code>svn revert  /Users/guohua/Desktop/项目/项目名字XXX/…/XXX.png  </code></pre></p>
<p>下面我们去提交，就没有这种报错提示了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h3&gt;&lt;p&gt;最近在维护老项目，所以出现了很多以前没遇到过的问题。也算见识一番吧。&lt;br&gt;目前所在的公司使用SVN作为版本控制器，所以接下来这个问
    
    </summary>
    
    
      <category term="SVN" scheme="https:guohuaden.com/tags/SVN/"/>
    
  </entry>
  
  <entry>
    <title>Swift之模糊效果（毛玻璃效果，虚化效果）的实现</title>
    <link href="https:guohuaden.com/2016/11/29/Swift-BlurEffect/"/>
    <id>https:guohuaden.com/2016/11/29/Swift-BlurEffect/</id>
    <published>2016-11-29T06:19:25.000Z</published>
    <updated>2017-03-10T06:55:31.000Z</updated>
    
    <content type="html"><![CDATA[<font color="#FF8000"><strong>前言：</strong></font>

<p>之前项目中有用到过<code>Objective-C</code>的的模糊效果，感觉很是不错，而且iOS8之后官方SDK也直接提供了可以实现毛玻璃效果的三个类：<code>UIBlurEffect</code>、<code>UIVibrancyEffect</code> 和 <code>UIVisualEffectView</code>。通过这三个类可以很容易的去实现毛玻璃效果。</p>
<p>最近在熟悉<code>Swift</code>，所以今天说的是使用Swift去实现这种效果。<br>前提：</p>
<p>我们去实现的模糊效果有个前提，就是需要背景有一个色调，这样才能使毛玻璃有一个明显的效果，这里我直接在底部添加一个背景图片吧</p>
<p><img src="http://obzx0h1re.bkt.clouddn.com/Swift-BlurImage.png" alt="背景图片"></p>
<p>我们就在这张背景图片上去实现模糊效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//MARK: ******* 创建背景图片 *************</div><div class="line">func createBackgroundImageView() &#123;</div><div class="line">    self.imageView1 = UIImageView(frame: self.view.bounds)</div><div class="line">    imageView1.layer.borderColor     = UIColor.black.cgColor</div><div class="line">    imageView1.layer.borderWidth     = 2 </div><div class="line">    imageView1.layer.cornerRadius    = 5</div><div class="line">    imageView1.clipsToBounds         = true</div><div class="line">    imageView1.image = UIImage(named: &quot;05&quot;)</div><div class="line">    self.view.addSubview(imageView1)  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<font color="#0B1746"><strong>1、<code>UIBlurEffect</code>类（用作创建一个模糊效果）</strong></font>

<p>SDK中提供的模糊效果有5种，其中两种是iOS10之后添加的，我们来看一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     public enum UIBlurEffectStyle : Int &#123;</div><div class="line">     </div><div class="line">     </div><div class="line">     case extraLight</div><div class="line">     </div><div class="line">     case light</div><div class="line">     </div><div class="line">     case dark</div><div class="line">     </div><div class="line">     </div><div class="line">     @available(iOS 10.0, *)</div><div class="line">     case regular // Adapts to user interface style</div><div class="line">     </div><div class="line">     @available(iOS 10.0, *)</div><div class="line">     case prominent // Adapts to user interface style</div><div class="line">     &#125;</div><div class="line">     */</div></pre></td></tr></table></figure>
<p>我们就直接创建好了，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//创建一个模糊效果</div><div class="line">  let blurEffect = UIBlurEffect(style: .light)</div></pre></td></tr></table></figure>
<p>上面使用的是普通的亮色。</p>
<font color="#0B1746"><strong>2、<code>UIVibrancyEffect</code>类</strong></font>

<p><code>UIVibrancyEffect</code> 主要用于放大和调整 <code>UIVisualEffectView</code> 视图下面的内容的颜色，同时让 <code>UIVisualEffectView</code> 的 <code>contentView</code> 中的内容看起来更加生动。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//创建并添加vibrancy&lt;/code&gt;视图</div><div class="line">let vibrancyEffect = UIVibrancyEffect(blurEffect: blurEffect)</div></pre></td></tr></table></figure>
<font color="#0B1746"><strong>3、<code>UIVisualEffectView</code>类</strong></font>

<p><code>UIVisualEffectView</code>：模糊视图。将前面创建的 <code>UIBlurEffect</code> 类的实例应用到这个模糊视图上。将 <code>UIVisualEffectView</code> 类的实例（模糊视图）置于待毛玻璃化的视图之上即可。在其下方的所有视图都会有模糊效果。值得一提的是：不要直接添加子视图去<code>UIVisualEffectView</code>，而是要添加到<code>contentView</code>上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//创建一个承载模糊效果的视图</div><div class="line">let blurView = UIVisualEffectView(effect: blurEffect)</div></pre></td></tr></table></figure>
<font color="#0B1746"><strong>4、整体的代码实现</strong></font>

<p>下面我们直接看整体的代码实现：</p>
<p>这部分分为两种，效果也是不一样的：</p>
<p>先看一下效果图：<br><img src="http://obzx0h1re.bkt.clouddn.com/Swift-blurEffec.png" alt="Swift-blurEffec"><br>毛玻璃效果图</p>
<font color="##87CEEB"><strong>4.1 <code>UIBlurEffect</code> 和 <code>UIVisualEffectView</code>两者配合使用</strong></font>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">func showBlurEffect() &#123;   </div><div class="line">//创建一个模糊效果</div><div class="line">let blurEffect = UIBlurEffect(style: .light)</div><div class="line">//创建一个承载模糊效果的视图</div><div class="line">let blurView = UIVisualEffectView(effect: blurEffect)   </div><div class="line">blurView.frame = CGRect(x: 0, y: 64, width: viewWidth+2*space, height: Double(viewHeight))</div><div class="line">let label = UILabel(frame: CGRect(x: 10, y: 100, width: viewWidth - 20, height: 100))   </div><div class="line">label.text = &quot;bfjnecsjdkcmslc,samosacmsacdfvneaui&quot;  </div><div class="line">label.font = UIFont.boldSystemFont(ofSize: 30)</div><div class="line">label.numberOfLines = 0</div><div class="line">label.textAlignment = .center</div><div class="line">label.textColor = UIColor.white    </div><div class="line">blurView.contentView.addSubview(label)   </div><div class="line">self.view.addSubview(blurView)   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<font color="##87CEEB"><strong>4.2 <code>UIBlurEffect</code>、<code>UIVibrancyEffect</code> 和 <code>UIVisualEffectView</code></strong></font>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">func showBlurEffectWithUIVibrancyEffect() &#123;</div><div class="line">//创建一个模糊效果</div><div class="line">let blurEffect = UIBlurEffect(style: .light)</div><div class="line">//创建一个承载模糊效果的视图</div><div class="line">let blurView = UIVisualEffectView(effect: blurEffect)    </div><div class="line">blurView.frame = CGRect(x: 0, y: Double(viewHeight+64), width: viewWidth+2*space, height: Double(viewHeight))    </div><div class="line">self.view.addSubview(blurView)    </div><div class="line">//创建并添加vibrancy视图</div><div class="line">let vibrancyEffect = UIVibrancyEffect(blurEffect: blurEffect)    </div><div class="line">let vibrancyView = UIVisualEffectView(effect:vibrancyEffect)</div><div class="line">vibrancyView.frame = self.view.bounds       </div><div class="line">let label = UILabel(frame: CGRect(x: 10, y: viewY, width: viewWidth - 20, height: 100))    </div><div class="line">label.text = &quot;bfjnecsjdkcmslc,samosacmsacdfvneaui&quot;    </div><div class="line">label.font = UIFont.boldSystemFont(ofSize: 30)</div><div class="line">label.numberOfLines = 0</div><div class="line">label.textAlignment = .center</div><div class="line">label.textColor = UIColor.white    </div><div class="line">vibrancyView.contentView.addSubview(label)    </div><div class="line">blurView.contentView.addSubview(vibrancyView)   </div><div class="line">self.view.addSubview(blurView)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> <font color="#6B8E23"><strong>图片的前者是：</strong></font><code>UIBlurEffect</code> 和 <code>UIVisualEffectView</code>两者配合使用</p>
<p><font color="#6B8E23"><strong>后者：</strong></font><code>UIBlurEffect</code>、<code>UIVibrancyEffect</code> 和 <code>UIVisualEffectView</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;font color=&quot;#FF8000&quot;&gt;&lt;strong&gt;前言：&lt;/strong&gt;&lt;/font&gt;

&lt;p&gt;之前项目中有用到过&lt;code&gt;Objective-C&lt;/code&gt;的的模糊效果，感觉很是不错，而且iOS8之后官方SDK也直接提供了可以实现毛玻璃效果的三个类：&lt;code&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="https:guohuaden.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>iOS之使用模拟器错误 (Code Sign Error:resource fork, Finder information, or similar detritus not allowed)</title>
    <link href="https:guohuaden.com/2016/11/14/Xcode-error-Code%20Sign%20Error/"/>
    <id>https:guohuaden.com/2016/11/14/Xcode-error-Code Sign Error/</id>
    <published>2016-11-14T12:01:31.000Z</published>
    <updated>2017-02-08T02:14:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>很奇怪的问题，使用真机测试没有问题。但使用模拟器测试的时候就会报这样的错误，错误类型为：<code>Code Sign Error</code></p>
<p>错误提示是这样：<code>resource fork, Finder information, or similar detritus not allowed。</code></p>
<p>找了很多资料，说的都是一半一半，有的看了仍是无从下手。最后看到的处理方式是这样的：</p>
<p>首先关闭<code>Xcode</code>，打开终端：</p>
<p>进入<code>DerivedData</code>目录</p>
<p><code>cd ~/Library/Developer/Xcode/DerivedData/ </code></p>
<p>然后再终端输入：<code>xattr -rc .</code> </p>
<p><code>xattr -rc .</code> </p>
<p>再次运行项目，就没有这样报错了。（也算是对症下药吧）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很奇怪的问题，使用真机测试没有问题。但使用模拟器测试的时候就会报这样的错误，错误类型为：&lt;code&gt;Code Sign Error&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;错误提示是这样：&lt;code&gt;resource fork, Finder information, or simil
    
    </summary>
    
    
      <category term="Xcode" scheme="https:guohuaden.com/tags/Xcode/"/>
    
  </entry>
  
  <entry>
    <title>iOS之退出app(项目)的几种方法</title>
    <link href="https:guohuaden.com/2016/11/13/Project-Logout/"/>
    <id>https:guohuaden.com/2016/11/13/Project-Logout/</id>
    <published>2016-11-13T03:01:32.000Z</published>
    <updated>2017-03-10T06:55:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>路漫漫其修远兮，吾将上下而求索。也算是对程序员的一种真实写照了吧。</p>
<p>今天想研究一下iOS中退出项目的方法，说是今天，其实也关注并去了解很久了。只是始终找不到自己认为很好的方法。今天就先把自己了解的列举一下，以后如果还能找到认为更好的，就在补充吧。</p>
<p>这里是我们在项目的<code>AppDelegate</code>中普遍写到的一句代码（至于扩展和丰富，我们暂不去深究）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; </div><div class="line">	LoginViewController *loginVC = [[LoginViewController alloc] init];</div><div class="line">//    UINavigationController *homeNavigationView = [[UINavigationController alloc] initWithRootViewController:loginVC];</div><div class="line">//    self.window.rootViewController = 	homeNavigationView;</div><div class="line">	self.window.rootViewController = loginVC;</div><div class="line">    return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面我们就围绕<code>LoginViewController</code>这个登录界面展开我们的讨论。我们都知道，登录的方式不同，才会导致退出的方式差异，有登录才有退出，这是因果关系。</p>
<p>而我们的登录方式无外乎这几种：利用 <code>Modal</code> 形式展示控制器 ；利用导航控制器<code>UINavigationController</code>跳转；当然也可以更改 <code>UIWindow</code> 的 <code>rootViewController</code>。下面我们就介绍一下这几种登录方式吧。</p>
<font color="#228B22"><strong>1、登录退出A</strong></font>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)login</div><div class="line">&#123;</div><div class="line">	HomeViewController *homeVC = [[HomeViewController alloc]init];  </div><div class="line">	[self presentViewController:homeVC animated:YES completion:nil];</div><div class="line">&#125; </div><div class="line">- (void)exit</div><div class="line">&#123;</div><div class="line">	[self dismissViewControllerAnimated:YES completion:nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是利用<code>model</code>形式登录和退出app的。当然登录的动画形式是多选的，你可以挑选一种喜欢的方式，你也可以自定义转场动画，这是你的自由。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     UIModalTransitionStyleCoverVertical = 0,</div><div class="line">     UIModalTransitionStyleFlipHorizontal __TVOS_PROHIBITED,</div><div class="line">     UIModalTransitionStyleCrossDissolve,</div><div class="line">     UIModalTransitionStylePartialCurl NS_ENUM_AVAILABLE_IOS(3_2) __TVOS_PROHIBITED,</div><div class="line">     */</div></pre></td></tr></table></figure>
<p>这里我做了个gif动画，是关于系统自带的，可以看下：<br><img src="http://obzx0h1re.bkt.clouddn.com/%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB.gif" alt="logout_gif"></p>
<font color="#228B22"><strong>2、登录退出B</strong></font>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)login</div><div class="line">&#123;</div><div class="line">	HomeViewController *homeVC = [[HomeViewController alloc]init];</div><div class="line">	[self.navigationController pushViewController:homeVC animated:YES];</div><div class="line">&#125;</div><div class="line">- (void)exit</div><div class="line">&#123;</div><div class="line">	[self.navigationController popViewControllerAnimated:YES];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是利用导航控制器<code>UINavigationController</code>跳转。也是我们在项目中经常用到的一种方式，当然，登录退出也是常用这种方式的。这里就不过多去述。</p>
<font color="#228B22"><strong>3、更改 <code>UIWindow</code> 的 <code>rootViewController</code></strong></font>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)login&#123;</div><div class="line">    HomeViewController *homeVC = [[HomeViewController alloc]init];</div><div class="line">    self.window.rootViewController = homeVC;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个是写在AppDelegate中的，退出时再调用该方法。</p>
<font color="#228B22"><strong>4、退出app程序（不推荐使用，这种方式会让用户觉得app闪退）</strong></font>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)exitApplication &#123;</div><div class="line">    UIWindow *window =  [UIApplication sharedApplication].keyWindow;</div><div class="line">    [UIView animateWithDuration:1.0f animations:^&#123;</div><div class="line">        window.alpha = 0;</div><div class="line">        window.frame = CGRectMake(0, window.bounds.size.width, 0, 0);</div><div class="line">    &#125; completion:^(BOOL finished) &#123;</div><div class="line">        exit(0);</div><div class="line">    &#125;];  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> <font color="#E3170D"><strong>警告：</strong></font>不要使用<code>exit</code>函数，调用<code>exit</code>会让用户感觉程序崩溃了，不会有按<code>Home</code>键返回时的平滑过渡和动画效果。</p>
<p> 另外，使用<code>exit</code>可能会丢失数据，因为调用<code>exit</code>并不会调用<code>-applicationWillTerminate:</code>方法和<code>UIApplicationDelegate</code>方法； </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;路漫漫其修远兮，吾将上下而求索。也算是对程序员的一种真实写照了吧。&lt;/p&gt;
&lt;p&gt;今天想研究一下iOS中退出项目的方法，说是今天，其实也关注并去了解很久了。只是始终找不到自己认为很好的方法。今天就先把自己了解的列举一下，以后如果还能找到认为更好的，就在补充吧。&lt;/p&gt;
&lt;p
    
    </summary>
    
    
      <category term="iOS" scheme="https:guohuaden.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Base64加密和DES加密、以及JAVA和iOS中DES加密统一性问题</title>
    <link href="https:guohuaden.com/2016/10/06/DES-encryption/"/>
    <id>https:guohuaden.com/2016/10/06/DES-encryption/</id>
    <published>2016-10-06T14:14:00.000Z</published>
    <updated>2017-01-14T13:07:16.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><em>我们在项目中为了安全方面的考虑，通常情况下会选择一种加密方式对需要安全性的文本进行加密，而Base64加密和DES64加密是常用的加密算法。我记得我在前一个项目中使用的就是这两种加密算法的结合：Base64 ＋ DES加密。当然这需要移动端和后台服务器做一个统一。</em></p>
<h3 id="1、Base64加解密"><a href="#1、Base64加解密" class="headerlink" title="1、Base64加解密"></a>1、Base64加解密</h3><p>值得一提的是：apple提供了基础的Base64加解密算法。这样我们就可以直接使用方法去实现Base64加解密。先看一下apple都提供了哪些方法：<br><pre>@interface NSData (NSDataBase64Encoding)<br>-(nullable instancetype)initWithBase64EncodedString:(NSString <em> )base64String options:(NSDataBase64DecodingOptions)options NS_AVAILABLE(10_9, 7_0);<br>-(NSString </em> )base64EncodedStringWithOptions:(NSDataBase64EncodingOptions)options NS_AVAILABLE(10_9, 7_0);<br>-(nullable instancetype)initWithBase64EncodedData:(NSData <em> )base64Data options:(NSDataBase64DecodingOptions)options NS_AVAILABLE(10_9, 7_0);<br>-(NSData </em> )base64EncodedDataWithOptions:(NSDataBase64EncodingOptions)options NS_AVAILABLE(10_9, 7_0);<br>@end</pre> </p>
<p>我们先创建一个NSData，再去一条一条的分析以上的方法</p>
<pre>NSData *data = [@"Base64 encoding string" dataUsingEncoding:NSUTF8StringEncoding];</pre>

<ul>
<li><p>（1）创建一个Data（从一个Base64编码字符串使用给出的设置创建一个Data）</p>
<pre>NSData *dataFromBase64String = [[NSData alloc]initWithBase64EncodedString:base64String options:0];</pre>
</li>
<li><p>(2)创建一个Base64编码字符串（从接受者内容创建）</p>
<pre>NSString *base64String = [data base64EncodedStringWithOptions:0];</pre>
</li>
<li><p>(3)创建一个Data（从一个Base64、UTF-8编码的Data创建）</p>
<pre>NSData *base64AndUTFData = [base64Data initWithBase64EncodedData:base64Data options:0];</pre>
</li>
<li><p>(4)创建一个Base64、UTF-8编码的Data（从接受者内容创建）</p>
<pre>NSData *base64Data = [data base64EncodedDataWithOptions:0];</pre>


</li>
</ul>
<p><strong>当然，我们最后也可以将Data转化成String类型。</strong></p>
<pre>NSString *base64Decoded = [[NSString alloc]initWithData:dataFromBase64String encoding:NSUTF8StringEncoding];</pre>



<p><em>以上是Base64加解密方法。下面我们看看DES的加解密。</em></p>
<h3 id="2、DES加解密"><a href="#2、DES加解密" class="headerlink" title="2、DES加解密"></a>2、DES加解密</h3><p>我们都知道安卓和后台可以使用统一的代码去解决这个问题，这也是java的优势之一吧。这里我会附一段java的代码。主要是为了下面说明java和iOS端实现中需要注意的地方（也是不同点）。<br>为了使说明更方便一些，我们先看一下java的DES加密方法：</p>
<pre>// EDS加密
 public static String Encrypt(String originalStr) {
   String result = null;
   byte[] tmpOriginalStr = null;
   try {
       if (!Tools.isEmpty(originalStr)) {
           tmpOriginalStr = originalStr.getBytes("utf-8");
           SecretKeyFactory keyFactory = SecretKeyFactory.getInstance("DES");
           DESKeySpec dks = new DESKeySpec(KEY);
           SecretKey secretKey = keyFactory.generateSecret(dks);
           IvParameterSpec param = new IvParameterSpec(IV);
           Cipher cipher = Cipher.getInstance("DES/CBC/PKCS5Padding");
           cipher.init(Cipher.ENCRYPT_MODE, secretKey,param);
           byte[] tmpEncypt = cipher.doFinal(tmpOriginalStr);
           if (tmpEncypt != null) {
               result = Base64.encodeToString(tmpEncypt,Base64.NO_WRAP);
            }
         }
      } catch (Exception e) {
            Log.e("Erro",e.getMessage());
      }
     return result;
  }
}
</pre>

<p>我们可以看出Java针对DES加密算法默认使用的是<code>CBC模式</code>，对齐方式采用的是:<code>PKCS5Padding</code>。</p>
<p>而OC中的加密并不是java中的形式实现加密的，接下来我们看一看OC中实现DES加密的代码：</p>
<pre>+(NSString *) encryptUseDES:(NSString *)plainText {
    NSString * ciphertext = nil;
    NSData * textData = [plainText dataUsingEncoding:NSUTF8StringEncoding];
    NSUInteger dataLength = [textData length];
    unsigned char buffer[1024 * 5];
    memset(buffer, 0, sizeof(char));
    size_t numBytesEncrypted = 0;
    CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt, kCCAlgorithmDES,
                                          kCCOptionPKCS7Padding,
                                          [key UTF8String], kCCKeySizeDES,
                                          [iv UTF8String],
                                          [textData bytes], dataLength,
                                          buffer, 1024,
                                          &numBytesEncrypted);
    if (cryptStatus == kCCSuccess) {
        NSData *data = [NSData dataWithBytes:buffer length:(NSUInteger)numBytesEncrypted];
        ciphertext = [data base64EncodedStringWithOptions:0];
    }
    return ciphertext;
}
</pre>

<p>先说一下代码中的<strong>key和iv</strong> 。<code>key</code>：是DES加密的公钥。而<code>iv</code>：是初始化的矢量。两者都是DES加密的关键参数。这个是必须要和Android、后台有个统一的。</p>
<p>我们可以看出OC使用的是<code>kCCOptionPKCS7Padding</code>对齐方式。而java中很明确的指出使用的是<code>PKCS5Padding</code>。接下来我们点进去看看OC中给出的对齐选择有哪些，我直接以代码的形式展示出来：</p>
<p><pre>@constant   kCCOptionPKCS7Padding   Perform PKCS7 padding.<br>@constant   kCCOptionECBMode        Electronic Code Book Mode.<br>                                    Default is CBC.<br>enum {<br>    /<em> options for block ciphers </em>/<br>    kCCOptionPKCS7Padding   = 0x0001,<br>    kCCOptionECBMode        = 0x0002<br>    /<em> stream ciphers currently have no options </em>/<br>};</pre></p>
<p> OC中给出的是<code>kCCOptionECBMode</code> 和<code> kCCOptionPKCS7Padding</code>这两种选择。那么，问题现在出现了。java中的DES加密算法有很多种，例如：<code>ECB，CBC，OFB，CFB</code>等。</p>
<p>java 和 OC的DES加密怎样才能实现一致性呢？（这也是我在项目中遇到的问题）。</p>
<p>查阅很多资料，再加上自己的很多次测试，得出的结果如下：</p>
<p><strong>在JAVA中使用这种方式加密：<code>DES/CBC/PKCS5Padding</code> 对应的Object-C的是 <code>kCCOptionPKCS7Padding</code>.<br>而使用<code>DES/ECB/PKCS5Padding</code> 对应的Object-C的是   <code>kCCOptionPKCS7Padding | kCCOptionECBMod</code><br>觉得似乎OC目前只支持这两种方式的加密。当然结果是已经得到验证的。</strong></p>
<p><strong>注意：md5加密（iOS SDK中自带了CommonCrypto）出现警告⚠️ 。解决方法添加：引入函数定义的头文件</strong> :<code>#import &lt;CommonCrypto/CommonDigest.h&gt;</code></p>
<p>其他链接：</p>
<p>《<a href="http://www.tuicool.com/articles/UJJrAj" target="_blank" rel="external">Objective C与Java之间的DES加解密实现</a>》</p>
<p>《<a href="http://iosdevelopertips.com/core-services/encode-decode-using-base64.html" target="_blank" rel="external">iOS 7: Base64 Encode and Decode NSData and NSString Objects</a>》</p>
<p> 这里附上demo：<a href="https://github.com/Wheat-Qin/Base64-DES" target="_blank" rel="external">https://github.com/Wheat-Qin/Base64-DES</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&lt;em&gt;我们在项目中为了安全方面的考虑，通常情况下会选择一种加密方式对需要安全性的文本进行加密，而Base64加密和DES64加密是常用的加
    
    </summary>
    
    
      <category term="iOS" scheme="https:guohuaden.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>block 和 weak的了解</title>
    <link href="https:guohuaden.com/2016/09/27/block-and-weak/"/>
    <id>https:guohuaden.com/2016/09/27/block-and-weak/</id>
    <published>2016-09-27T01:45:07.000Z</published>
    <updated>2017-03-10T02:40:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>果然还是对最基础的知识了解不透彻，今天看一看iOS中的两个修饰符：<code>__block</code>和<code>__weak</code> 。也是做一下温习吧。</p>
<p><strong>一、先说<code>weak</code>，&lt;弱引用&gt;</strong></p>
<p>我们知道<code>weak</code>的使用，比如声明一个控件属性，就会用到<code>weak</code>。</p>
<p>看代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property(nonatomic,weak)UILabel *label;</div></pre></td></tr></table></figure>
<p>当然这并不是说声明控件就一定使用<code>weak</code>，相反的我在手动创建控件是大多数会使用<code>strong</code>。但如果你比较细心的话，你会发现我们使用xib时，使用的却是<code>weak</code>这一属性。那问题来了，我们使用<code>strong</code> 和 <code>weak</code> 的时机是何时呢？咱们接着往下看。<br>从<code>storyboard</code> 或者 <code>xib</code>上创建控件 </p>
<p>在控件放在view<code>上的时候，已经形成了如下的引用关系,以<code>UILabel</code>为例：<code>UIViewController-&gt;UIView-&gt;subView-&gt; UILabel</code> ，然后你为这个<code>UILabel</code>声明一个<code>weak</code>属性。</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property(nonatomic,weak) IBOOutlet UILabel * label;</div></pre></td></tr></table></figure>
<p>相当于<code>xib</code>对这个<code>label</code>是强引用，你声明的属性对它是弱引用。<br>手动创建控件 </p>
<ul>
<li><strong>a). 将控件声明成<code>strong</code></strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property(nonatomic,strong) UIlabel * label;</div></pre></td></tr></table></figure>
<p>那么你在实现这个控件时只需这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">_label = [[UIlabel alloc]init];</div><div class="line">[self.view addSubview:_label];</div></pre></td></tr></table></figure>
<ul>
<li><strong>b). 将控件声明成weak</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property(nonatomic,weak) UIlabel * label;</div></pre></td></tr></table></figure>
<p>那么你在实现这个控件时需要这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">UIlabel *label = [[UIlabel alloc]init];</div><div class="line">_label = label;</div><div class="line">[self.view addSubview:_btn];</div></pre></td></tr></table></figure>
<p>关于<code>block</code>循环引用的问题</p>
<p>由于<code>block</code>会复制外部的变量，所以如果不注意，就会造成循环引用。对于这种情况，需要将引用的一方变成<code>weak</code>，从而避免循环引用。</p>
<p>看代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">BlocksViewController *blockVC  = [[BlocksViewController alloc]init];</div><div class="line">__weak ViewController *weekSelf = self;</div><div class="line">/**</div><div class="line">*  1、使用弱引用来解决block循环引用问题</div><div class="line">*</div><div class="line">*  2、block能截取自动变量，并且是不能在block块中进行修改的（除非用 __block修饰符）这里的 weekSelf.textField.text 的值是被修改了，并且没有使用 __block修饰符。原因是因为textField是全局变量，如果定义一个局部变量，比如：定义个 “text”是不能被修改的，编译器会报错，</div><div class="line">*/</div><div class="line">//block回调传值</div><div class="line">[blockVC returnValue:^(NSString *content) &#123;</div><div class="line">weekSelf.textField.text = content;</div><div class="line">// text = content;//这里会提示错失__block;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p><strong>二、<code>strong</code>和<code>weak</code>的区别</strong></p>
<ul>
<li><p><strong>strong</strong>：强引用，也是我们通常说的引用，其存亡直接决定了所指向对象的存亡。如果不存在指向一个对象的引用，并且此对象不再显示在列表中，则此对象会被从内存中释放。</p>
</li>
<li><p><strong>weak</strong>：弱引用，不决定对象的存亡。即使一个对象被持有无数个弱引用，只要没有强引用指向它，那么还是会被清除。</p>
</li>
<li><p><strong>strong</strong>和<strong>copy</strong>是用来修饰强引用的属性，weak 用来修饰弱引用的属性；</p>
</li>
<li><p><strong>strong</strong>、<strong>weak</strong> 需要ARC支持才能使用，<strong>copy</strong>不需要ARC支持</p>
</li>
<li><p><strong>strong</strong>与<strong>retain</strong>功能相似；<strong>weak</strong>与<strong>assign</strong>相似，只是当对象消失后weak会自动把指针变为nil;</p>
</li>
</ul>
<p><strong>三、关于<code>__block</code></strong></p>
<p>先看一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@autoreleasepool &#123;</div><div class="line">__block NSInteger value = 0;</div><div class="line">void (^block)(void) = ^&#123;</div><div class="line">value = 1;</div><div class="line">&#125;;</div><div class="line">block();</div><div class="line">NSLog(@&quot;val = %ld&quot;, value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们现在看着可能得不出什么结论，那么，我们再看下面的代码，为了直观，我以图片的形式呈现：</p>
<p><img src="http://obzx0h1re.bkt.clouddn.com/__blocktest.png" alt="block_picture1"></p>
<p><img src="http://obzx0h1re.bkt.clouddn.com/__blocktest1.png" alt="block_picture2"></p>
<p>现在对比就明显了。</p>
<p>下面总结一下：</p>
<ol>
<li><p>a) <code>__block</code>对象在<code>block</code>中是可以被修改、重新赋值的。</p>
</li>
<li><p>b)<code>__block</code>对象在<code>block</code>中不会被<code>block</code>强引用一次，从而不会出现循环引用问题。</p>
</li>
<li><p>c) <code>block</code>可以访问局部变量，但是不能修改。如果修改局部变量，需要加<code>__block</code> ,所以<code>__block</code>是让修改外部变量的值.</p>
</li>
</ol>
<p>对于 block 外的变量引用，<code>block</code> 默认是将其复制到其数据结构中来实现访问的</p>
<p><img src="http://obzx0h1re.bkt.clouddn.com/const-non-local-variables.png" alt="const-non-local-variables"></p>
<p>对于用 <code>__block</code> 修饰的外部变量引用，<code>block</code> 是复制其引用地址来实现访问的</p>
<p><img src="http://obzx0h1re.bkt.clouddn.com/mutable-non-local-variables.png" alt="mutable-non-local-variables"></p>
<p><strong>四、<strong>block 和 </strong>weak修饰符的区别</strong></p>
<ol>
<li><p><code>__block</code>不管是ARC还是MRC模式下都可以使用，可以修饰对象，还可以修饰基本数据类型。</p>
</li>
<li><p><code>__weak</code>只能在ARC模式下使用，也只能修饰对象<code>（NSString）</code>，不能修饰基本数据类型<code>（int）</code>。</p>
</li>
<li><p><code>__block</code>对象可以在<code>block</code>中被重新赋值，<code>__weak</code>不可以。</p>
</li>
</ol>
<hr>
<p> <strong>链接：</strong></p>
<p><a href="http://blog.devtang.com/2013/07/28/a-look-inside-blocks/" target="_blank" rel="external">谈Objective-C block的实现</a></p>
<p><a href="http://rypress.com/tutorials/objective-c/blocks" target="_blank" rel="external">Blocks are Objective-C`s</a></p>
<p><a href="http://www.cnblogs.com/luoxiaofu/p/5445327.html" target="_blank" rel="external">iOS开发-由浅至深学习block</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;果然还是对最基础的知识了解不透彻，今天看一看iOS中的两个修饰符：&lt;code&gt;__block&lt;/code&gt;和&lt;code&gt;__weak&lt;/code&gt; 。也是做一下温习吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、先说&lt;code&gt;weak&lt;/code&gt;，&amp;lt;弱引用&amp;gt;&lt;/st
    
    </summary>
    
    
      <category term="iOS" scheme="https:guohuaden.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS模糊效果(毛玻璃效果)的实现</title>
    <link href="https:guohuaden.com/2016/09/23/BlurEffect/"/>
    <id>https:guohuaden.com/2016/09/23/BlurEffect/</id>
    <published>2016-09-23T02:42:42.000Z</published>
    <updated>2017-03-10T06:57:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>　前一段时间项目中用到毛玻璃效果，那时对<code>UIBlurEffect</code>类和 <code>UIVisualEffectView</code>这两个类做了一部分了解。但当时并没有去特别的深入研究，直到项目做完后，才静下心来好好研究了一番。记录一下。</p>
<p>　　iOS8之后，Apple新添加<code>UIBlurEffect</code>类、<code>UIVibrancyEffect</code>类 和 <code>UIVisualEffectView</code>类这三种类，用途就是对背景色进行模糊化，也就是我们称的 “毛玻璃效果”。接下来就对具体的使用做一下分析吧。</p>
<p>　　其实细看下来，Apple对这种特效封装的很好，所以我们使用起来的并不需要什么步骤。不得不佩服Apple的强大啊。</p>
<p>1、关于<code>UIBlurEffect</code>类</p>
<p>我们首先看UIBlurEffect类，Apple文档中只给出了一个方法：</p>
<p>`</p>
<ul>
<li>(UIBlurEffect *)effectWithStyle:(UIBlurEffectStyle)style;<br>`<br>我们实现也是这样：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *   模糊效果的三种风格</div><div class="line"> *</div><div class="line"> *  @param UIBlurEffectStyle</div><div class="line">   UIBlurEffectStyleExtraLight,//额外亮度，（高亮风格）</div><div class="line">   UIBlurEffectStyleLight,//亮风格</div><div class="line">   UIBlurEffectStyleDark//暗风格</div><div class="line"> *</div><div class="line"> */</div><div class="line">//实现模糊效果</div><div class="line">UIBlurEffect *blurEffrct =[UIBlurEffect effectWithStyle:UIBlurEffectStyleLight];</div></pre></td></tr></table></figure>
<p> 2、关于<code>UIVibrancyEffect</code>类</p>
<p>文档中给出的也是一个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (UIVibrancyEffect *)effectForBlurEffect:(UIBlurEffect *)blurEffect;</div></pre></td></tr></table></figure>
<p>官方给出的解释是这样的</p>
<p><pre><br>UIVibrancyEffect amplifies and adjusts the color of content layered behind the view, allowing content placed inside the contentView to become more vivid.</pre></p>
<p>It is intended to be placed over, or as a subview of, a UIVisualEffectView that has been configured with a UIBlurEffect.</p>
<p>This effect only affects content added to the contentView. Because the vibrancy effect is color dependent, subviews added to the contentView need to be tintColorDidChange aware and must be prepared to update themselves accordingly. </p>
<p>UIImageView will need its image to have a rendering mode of UIImageRenderingModeAlwaysTemplate to receive the proper effect.</p>
<p><br>翻译如下：</p>
<p><code>UIVibrancyEffect</code>的作用是放大和调整<code>UIVisualEffectView</code>内容视图的内容的颜色,让<code>UIVisualEffectView</code>的<code>contentView</code>中的内容看起来更加生动。它作为一个子视图被放置在<code>UIVisualEffectView</code>上面，去连接<code>UIBlurEffect</code>。这种效果只会影响添加到<code>UIVisualEffectView</code>的<code>contentView</code>上的内容。因为活力影响是受颜色依赖的…..</p>
<p><font color="#FF8000"><strong>我们可以看出</strong></font>：通常<code>UIVibrancyEffect</code>对象是与<code>UIBlurEffect</code>一起使用，主要用于处理在<code>UIBlurEffect</code>特效上的一些显示效果。</p>
<p>下面看看实现代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//实现模糊效果</div><div class="line">UIBlurEffect *blurEffrct =[UIBlurEffect effectWithStyle:UIBlurEffectStyleLight];   </div><div class="line">UIVibrancyEffect *vibrancyEffect = [UIVibrancyEffect effectForBlurEffect:blurEffrct];  </div><div class="line">UIVisualEffectView *visualEffectView = [[UIVisualEffectView alloc]initWithEffect:vibrancyEffect];</div><div class="line">// visualEffectView.backgroundColor = [ UIColor grayColor ];</div><div class="line">visualEffectView.contentView.frame = CGRectMake(10, 100, 300, 500);</div><div class="line">[self.view addSubview:visualEffectView];</div></pre></td></tr></table></figure>
<p>下面我们往 <figure class="highlight plain"><figcaption><span>的`contentView`上添加个`view`看看效果</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>UILabel *label = [[UILabel alloc]initWithFrame:CGRectMake(10, 300, 280, 90)];<br>label.text = @”曾经撒次考试了hhhhhhhhhhhhhhh”;<br>label.textAlignment = NSTextAlignmentLeft;<br>label.font = [UIFont systemFontOfSize:30];<br>label.tintColor = [UIColor yellowColor];<br>label.numberOfLines = 0;<br>[visualEffectView.contentView addSubview:label];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line"></div><div class="line">上面代码中可以看到， 我改变`Label`中`text`的颜色是使用的：`tintColor` ，这也是特别要注意的地方，文档中也有专门提出，并给出了解释：</div><div class="line">`Because the vibrancy effect is color dependent, subviews added to the contentView need to be tintColorDidChange aware and must be prepared to update themselves accordingly`</div><div class="line">所以我们使用 `label.textColor`去改变颜色是完全不起作用的。</div><div class="line"></div><div class="line">运行效果图如下：(只剪切出效果部分)</div><div class="line">![VisualEffect](http://obzx0h1re.bkt.clouddn.com/VisualEffect.png)</div><div class="line">至于颜色不是设置的`yellowColor`，我想不需要多说了吧，这就是`UIVibrancyEffect`的功能。</div><div class="line"></div><div class="line">**三、`UIVisualEffectView`类**</div><div class="line"></div><div class="line">老规矩先看文档：也是寥寥的四种，其中值得一提的是：`contentView`。这里明确告诉我们：不要直接添加子视图去`UIVisualEffectView`，而是要添加到`contentView`上。</div></pre></td></tr></table></figure></p>
<p>@property (nonatomic, strong, readonly) UIView <em>contentView; // Do not add subviews directly to UIVisualEffectView, use this view instead.<br>@property (nonatomic, copy, nullable) UIVisualEffect </em>effect;</p>
<ul>
<li>(instancetype)initWithEffect:(nullable UIVisualEffect *)effect NS_DESIGNATED_INITIALIZER;</li>
<li>(nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER;<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">这里我就给出一个比较完整的代码（我们看一看`UIBlurEffect`类 和 `UIVisualEffectView`类 的效果）：</div></pre></td></tr></table></figure>
</li>
</ul>
<p>self.view.backgroundColor = [UIColor colorWithPatternImage:[UIImage imageNamed:@”6.jpg”]];<br>/**</p>
<ul>
<li>模糊效果的三种风格<br>*</li>
<li>@param UIBlurEffectStyle<br>UIBlurEffectStyleExtraLight,//额外亮度，（高亮风格）<br>UIBlurEffectStyleLight,//亮风格<br>UIBlurEffectStyleDark//暗风格<br><em>
</em>/<br>//实现模糊效果<br>UIBlurEffect <em>blurEffrct =[UIBlurEffect effectWithStyle:UIBlurEffectStyleLight];<br>//毛玻璃视图<br>UIVisualEffectView </em>visualEffectView = [[UIVisualEffectView alloc]initWithEffect:blurEffrct];<br>visualEffectView.frame = CGRectMake(60, 100, 300, 500);<br>visualEffectView.alpha = 0.9;<br>[self.view addSubview:visualEffectView];<br>```</li>
</ul>
<p>看看效果图是不是你想要的：<br><img src="http://obzx0h1re.bkt.clouddn.com/BlurEffect.png" alt="BlurEffect"><br>关于iOS8之前的实现，可以去github上看看一些封装库。有很多不错的三方库不错，这里就不列出了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　前一段时间项目中用到毛玻璃效果，那时对&lt;code&gt;UIBlurEffect&lt;/code&gt;类和 &lt;code&gt;UIVisualEffectView&lt;/code&gt;这两个类做了一部分了解。但当时并没有去特别的深入研究，直到项目做完后，才静下心来好好研究了一番。记录一下。&lt;/p&gt;

    
    </summary>
    
    
      <category term="iOS" scheme="https:guohuaden.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS之项目总结－：项目中遇到的各种的问题和解决方法</title>
    <link href="https:guohuaden.com/2016/08/16/project-summary-one/"/>
    <id>https:guohuaden.com/2016/08/16/project-summary-one/</id>
    <published>2016-08-16T10:28:00.000Z</published>
    <updated>2017-01-14T18:00:46.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p> 一到公司报道那时，便着手独立的去完成了一个项目，其中的辛酸泪也是不足为外人道也。这次算是一个新型的app，仍然是独立开发，但心境和想法却是完全的不同。下面说一次以前做开发时常常忽略的知识，也算是一种复习了吧。下面言归正传：</p>
<h3 id="1、自带键盘的next用法"><a href="#1、自带键盘的next用法" class="headerlink" title="1、自带键盘的next用法"></a>1、自带键盘的next用法</h3><p>这算是比较常用的了吧，只要我们想到登录和注册界面，就应该自然而然的想到 - 键盘的next用法（当然不排除相当多的软件并没有实现这个功能）。</p>
<p>想法也就是：用户在输入用户名后，点击next跳转到下一个输入框。其实也不用想的如此复杂，在登录界面，我们完全可以用一个 if 语句做判断，去实现键盘的响应和注销响应。</p>
<p>代码如下： <pre>- (BOOL)textFieldShouldReturn:(UITextField <em> )textField {<br>  UITextField </em> passTextFiled = (UITextField *)[self.view viewWithTag:201];<br>  if (textField.tag == 200) {<br>          [passTextFiled becomeFirstResponder];<br>   }else{<br>           [passTextFiled resignFirstResponder];<br>    }<br>   return YES;<br>}</pre></p>
<p>这样就简单的在变成响应和注销响应之间实现了输入框的切换。</p>
<p>但还是存在一个问题，如果我实现注册界面的跳转输入框，并且在输入框很多的情况下，显然如果我仍是这样判断，会显得啰嗦和冗余。</p>
<p>我曾想过使用计数的方式，记录每一次的点击next后的tag，但实践中失败了，因为当我不通过next而是直接用手去触摸选择输入框时，则无法计数。</p>
<p> 这里先留个空白，等把手里的项目完成时再研究这个问题</p>
<h3 id="2、UITextField的纠错和首字母大小写问题"><a href="#2、UITextField的纠错和首字母大小写问题" class="headerlink" title="2、UITextField的纠错和首字母大小写问题"></a>2、UITextField的纠错和首字母大小写问题</h3><p>这个问题只是简单的属性问题，在开发时如果忘记，建议多点进去看看，（如：command + UITextField）   </p>
<pre>
 //输入框中是否有个叉号，在什么时候显示，用于一次性删除输入框中的内容    
self.clearButtonMode = UITextFieldViewModeWhileEditing;    
//是否纠错,本人感觉纠错是一个很反感的东西，但UITextField默认是 YES,这里我改成了NO      
self.autocorrectionType = UITextAutocorrectionTypeNo;       
 //再次编辑就清空      
self.clearsOnBeginEditing = YES;       
//设置自动缩小显示的最小字体大小      
self.minimumFontSize = 15;        
//设置键盘的样式，本人感觉这个设置对用户体验有影响。比如说我想打电话，Type为UIKeyboardTypeNumberPad,而不是其他     
self.keyboardType = UIKeyboardTypeNamePhonePad;</pre>

<h3 id="3、iOS中图片的几种拉伸方法的使用"><a href="#3、iOS中图片的几种拉伸方法的使用" class="headerlink" title="3、iOS中图片的几种拉伸方法的使用"></a>3、iOS中图片的几种拉伸方法的使用</h3><p>以下是Apple SDK给出的3种方法:</p>
<pre>UIImage *image = [UIImage imageNamed:@"picture"];        
//iOS5之前     
// 左端盖宽度        
NSInteger leftCapWidth = image.size.width * 0.5f;       
NSInteger topCapHeight = image.size.height * 0.8f;        

image = [image stretchableImageWithLeftCapWidth:leftCapWidth topCapHeight:topCapHeight];        

//iOS5之后       
UIEdgeInsets insets = UIEdgeInsetsMake(image.size.height * 0.8f,image.size.width * 0.5f, 40, 40);       

image = [image resizableImageWithCapInsets:insets];      
//iOS6之后        
UIEdgeInsets insets = UIEdgeInsetsMake(image.size.height * 0.8f,image.size.width * 0.5f, 40, 40);       
image = [image resizableImageWithCapInsets:insets resizingMode:UIImageResizingModeStretch]; </pre>  

<p>下面是使用的解释：<br><img src="http://obzx0h1re.bkt.clouddn.com/pictureStretch.png" alt="pictureStretch"></p>
<pre>
/**   
 *  - (UIImage *)stretchableImageWithLeftCapWidth:(NSInteger)leftCapWidth topCapHeight:(NSInteger)topCapHeight;    
 *  
 *  leftCapWidth代表左端盖宽度，topCapHeight代表顶端盖高度。系统会自动计算出右端盖宽度(rightCapWidth)和底端盖高度(bottomCapHeight)    

 * 算法如下：    
 * width为图片宽度  rightCapWidth = width - leftCapWidth - 1;       
 * height为图片高度 bottomCapHeight = height - topCapHeight - 1    
 *    
 *经过计算，你会发现中间的可拉伸区域只有1x1    
 *   

* stretchWidth为中间可拉伸区域的宽度        stretchWidth = width - leftCapWidth - rightCapWidth = 1;       
* stretchHeight为中间可拉伸区域的高度        stretchHeight = height - topCapHeight - bottomCapHeight = 1;    
*    
* 因此，使用这个方法只会拉伸图片中间1x1的区域，并不会影响到边缘和角落。    
*/

/**   
 * - (UIImage * )resizableImageWithCapInsets:(UIEdgeInsets)capInsets    
 *  这个方法只接收一个UIEdgeInsets类型的参数，可以通过设置UIEdgeInsets的left、right、top、bottom来分别指定左端盖宽度、右端盖宽度、顶端盖高度、底端盖高度    
 * */       

/**    
 *- (UIImage * )resizableImageWithCapInsets:(UIEdgeInsets)capInsets resizingMode:(UIImageResizingMode)resizingMode  

对比iOS5.0中的方法，只多了一个<code>UIImageResizingMode</code>参数，用来指定拉伸的模式：
    UIImageResizingModeStretch：拉伸模式，通过拉伸
    UIEdgeInsets:指定的矩形区域来填充图片    
    UIImageResizingModeTile：平铺模式，通过重复显示
    UIEdgeInsets指定的矩形区域来填充图片   
**/</pre>

<p>图片拉伸的以上内容参考文章 《<a href="http://blog.csdn.net/q199109106q/article/details/8615661" target="_blank" rel="external">iOS图片拉伸技巧</a>》讲的很好，建议大家多看看。</p>
<h3 id="4、iOS中唤起自带浏览器（safari）的方法"><a href="#4、iOS中唤起自带浏览器（safari）的方法" class="headerlink" title="4、iOS中唤起自带浏览器（safari）的方法"></a>4、iOS中唤起自带浏览器（safari）的方法</h3><p>也是一个简单的一句代码 ，这种也就是知道了就知道了，不知道就是抓耳挠腮吧 </p>
<pre>NSURL *url = [NSURL URLWithString:urlStr]; 

[[UIApplication sharedApplication] openURL:url]; </pre>

<h3 id="5、iOS中唤起电话界面"><a href="#5、iOS中唤起电话界面" class="headerlink" title="5、iOS中唤起电话界面"></a>5、iOS中唤起电话界面</h3><p>app内部唤起电话界面的实现，是找了很多资料才有的一个结论（安全，并且拨打完之后可以返回app）</p>
<p>实现的方法是使用UIWebView 加载电话，目前这种方法是合法的，App Store也允许通过的。  </p>
<pre>NSURL *phoneURL = [NSURL URLWithString:[NSString stringWithFormat:@"tel:%@",newPhoneString]];    
 if (_phoneCallWebView) { 
   [_phoneCallWebView loadRequest:[NSURLRequest requestWithURL:phoneURL]];  

 }</pre>

<p>但如果使用下面的这种方法，则可能不允许通过审核  </p>
<pre>[[UIApplication sharedApplication] openURL:phoneURL];</pre>

<h3 id="6、iOS-调用地图的方法"><a href="#6、iOS-调用地图的方法" class="headerlink" title="6、iOS 调用地图的方法"></a>6、iOS 调用地图的方法</h3><p>app内部调用第三方app，这里有一个详细的文章《<a href="http://blog.csdn.net/a416863220/article/details/51220739" target="_blank" rel="external">IOS实现应用内打开第三方地图app进行导航</a>》</p>
<ul>
<li>app内部调用地图，需要先检测用户手机上是否已经安装地图app。</li>
</ul>
<p>我们常用的地图app有：高德、百度；国外有：谷歌（Google Map ）。当然还有苹果自带的地图，随着iOS10的发布，苹果地图这块也有很大的完善和进步。</p>
<p>我使用Xcode模拟器实现时，会提示:</p>
<pre>1、canOpenURL: failed for URL: "iosamap://" error: "(null)" 。</pre>

<p><strong>原因是</strong>：模拟器上没有高德地图。</p>
<pre>
2、canOpenURL: failed for URL:"comgooglemaps://" error: "This app is not allowed to query for scheme comgooglemaps"。</pre>

<p><strong>原因是</strong>：<code>LSApplicationQueriesSchemes</code>我自己马虎设成了字典类型。</p>
<p>首先iOS9以后，我们在app内部要跳转到其他软件时，需要在 <code>Info.plist</code> 中添加白名单。</p>
<p>方法为：在<code>Info.plist</code>中添加 <code>key : LSApplicationQueriesSchemes </code> 类型为：<code>Array</code>。</p>
<p>将高德、百度、谷歌的值填进去分别是：<code>iosamap</code>、<code>baidumap</code>、 <code>comgooglemaps</code></p>
<p>图片：<br><img src="http://obzx0h1re.bkt.clouddn.com/LSApplicationQueriesSchemes.png" alt="LSApplicationQueriesSchemes"></p>
<p>至于下面代码中的<code>URLScheme</code> 和<code>appName </code> 是在<code>Info.plist</code> 的<code>URL types</code>中添加  <code>URL Scheme</code>(URL Schemes是一个数组，允许应用定义多个URL schemes)和<code>URL identifier</code>（建议采用反转域名的方法保证该名字的唯一性，比如 <code>com.yourApp.www</code>）</p>
<p>图片如下：</p>
<p><img src="http://obzx0h1re.bkt.clouddn.com/URLTypes.png" alt="URLTypes"></p>
<p>下面是具体的代码：</p>
 <pre>__block NSString *urlScheme = urlScheme;   

 __block NSString *appName = appName;    

__block CLLocationCoordinate2D coordinate = self.coordinate;        

UIAlertController *alert = [UIAlertController alertControllerWithTitle:@"选择地图" message:nil preferredStyle:UIAlertControllerStyleActionSheet];          

//apple自带的地图不需要判断        

UIAlertAction * action = [UIAlertAction actionWithTitle:@"苹果地图" style:UIAlertActionStyleDefault handler:^(UIAlertAction *action) {      

       MKMapItem *currentLocation = [MKMapItem mapItemForCurrentLocation]; 

     MKMapItem *toLocation = [[MKMapItem alloc] initWithPlacemark:[[MKPlacemark alloc] initWithCoordinate:coordinate addressDictionary:nil]];                      

     [MKMapItem openMapsWithItems:@[currentLocation, toLocation]                           launchOptions:@{

MKLaunchOptionsDirectionsModeKey:     MKLaunchOptionsDirectionsModeDriving,MKLaunchOptionsShowsTrafficKey: [NSNumber numberWithBool:YES]}];        

}];        

 [alert addAction:action];        

 //判断百度地图   

 if ( [[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@"baidumap://"]])      

{        UIAlertAction * action = [UIAlertAction actionWithTitle:@"百度地图" style:UIAlertActionStyleDefault handler:^(UIAlertAction *action) {                       

 NSString *urlString = [[NSString stringWithFormat:@"baidumap://map/direction?origin=&destination=latlng:%f,%f|name=目的地&mode=driving&coord_type=gcj02",coordinate.latitude, coordinate.longitude] stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];

  [[UIApplication sharedApplication] openURL:[NSURL URLWithString:urlString]];         

 }];        

[alert addAction:action];      

}     

 //判断高德地图     

 if ( [[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@"iosamap://"]])      

 {        

UIAlertAction * action = [UIAlertAction actionWithTitle:@"高德地图" style:UIAlertActionStyleDefault handler:^(UIAlertAction *action) {                        

NSString *urlString = [[NSString stringWithFormat:@"iosamap://navi?sourceApplication=%@&backScheme=%@&lat=%f&lon=%f&dev=0&style=2",appName,urlScheme,coordinate.latitude, coordinate.longitude] stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];  

        [[UIApplication sharedApplication] openURL:[NSURL URLWithString:urlString]];                    }];       

 [alert addAction:action];    

}        

 //判断谷歌地图   

 if ( [[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@"comgooglemaps://"]])    {       

 UIAlertAction * action = [UIAlertAction actionWithTitle:@"谷歌地图" style:UIAlertActionStyleDefault handler:^(UIAlertAction *action) {                       

 NSString *urlString = [[NSString stringWithFormat:@"comgooglemaps://?x-source=%@&x-success=%@&saddr=&daddr=%f,%f&directionsmode=driving",appName,urlScheme,coordinate.latitude, coordinate.longitude] stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];                       
 [[UIApplication sharedApplication] openURL:[NSURL URLWithString:urlString]];          

}];                

[alert addAction:action];    

}        

UIAlertAction *action = [UIAlertAction actionWithTitle:@"取消" style:UIAlertActionStyleCancel handler:nil];    [alert addAction:action];        

[self presentViewController:alert animated:YES completion:^{          

}];    

}</pre>

]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h3&gt;&lt;p&gt; 一到公司报道那时，便着手独立的去完成了一个项目，其中的辛酸泪也是不足为外人道也。这次算是一个新型的app，仍然是独立开发，但心境和
    
    </summary>
    
    
      <category term="iOS" scheme="https:guohuaden.com/tags/iOS/"/>
    
  </entry>
  
</feed>
