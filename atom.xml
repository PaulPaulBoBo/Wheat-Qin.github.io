<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wheat</title>
  <subtitle>晨钟一叩，万境皆空</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https:guohuaden.com/"/>
  <updated>2017-03-10T01:31:56.000Z</updated>
  <id>https:guohuaden.com/</id>
  
  <author>
    <name>青卷三部</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>服务器返回的json数据中含有null的处理方法</title>
    <link href="https:guohuaden.com/2017/03/06/json-dataNull/"/>
    <id>https:guohuaden.com/2017/03/06/json-dataNull/</id>
    <published>2017-03-06T05:33:53.000Z</published>
    <updated>2017-03-10T01:31:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>因为有遇到过类似情况，所以就想到了一些解决方法，并且实践了一下，这里简单的做个记录。</p>
<p><strong>注：</strong>有看到不少的评价，有说后台责任，也有说怪移动端没有做容错处理。我这里就事论事的说下，移动端从服务器得到的数据中确实是不应该包含null的，因为这本身就是不合理的。（当然，我的就事论事是站在iOS立场上说的，这个无可厚非）。</p>
<p>下面👇说一下想到的几种方法：</p>
<p><strong>一、 对于所有使用到的json中的对象做判断（当然这是最笨的方法）</strong></p>
<pre><code>NSString *msg ;
if ([str isKindOfClass: [NSNull class]]){
    NSLog(@&quot;str 为空！&quot;);
}
//或者使用[str isEqual:[NSNull null]]
</code></pre><p>为什么首先说这种方法呢，大抵是因为这个方法的工作量比较大吧。但有时候你是完全不能避免这种情况的，尤其是在老旧的项目中，当你看到项目中所有的解析都是KVO模式时，你就知道一个个去判断是多么让人纠结的事情了。</p>
<hr>
<p><strong>二、使用JSONModel等第三方json解析库</strong>  </p>
<p>JSONModel有专门针对对象为null的处理，使其返回”<null>“。iOS移动端赋值为nil。</null></p>
<hr>
<p><strong>三、有一个专门针对数据为null的处理库，<code>NullSafe</code></strong></p>
<p>这个库是专门处理对象为null的。只有一个<code>.m</code>文件。使用也简单，因为你只需要添加到项目中就可以了，不再需要引入头文件等其他任意操作。</p>
<p>这里放一个我测试是使用的简单demo</p>
<p><a href="https://github.com/Wheat-Qin/Data_null_test" target="_blank" rel="external">github:data_nullDemo</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为有遇到过类似情况，所以就想到了一些解决方法，并且实践了一下，这里简单的做个记录。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;有看到不少的评价，有说后台责任，也有说怪移动端没有做容错处理。我这里就事论事的说下，移动端从服务器得到的数据中确实是不应该包含null的
    
    </summary>
    
    
      <category term="iOS" scheme="https:guohuaden.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>WebView 打不开问题 (转码问题)</title>
    <link href="https:guohuaden.com/2017/02/27/WebView-ErrorOpen/"/>
    <id>https:guohuaden.com/2017/02/27/WebView-ErrorOpen/</id>
    <published>2017-02-27T01:56:54.000Z</published>
    <updated>2017-03-08T02:23:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>无意中遇到一个问题，项目中使用<code>UIWebView</code>打不开<code>web</code>界面，检查过<code>URL</code>和代码，发现并没有问题。随考虑到一点：<strong>URL中包含汉字</strong>。</p>
<p>处理如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">NSString *URLString = [NSString stringWithFormat:@&quot;%@id=%@&amp;email=%@&quot;,ProviderOrder,self.orderID,emailStr];</div><div class="line">//方法是用来进行转码的，即将汉字转码</div><div class="line">NSString *encodedString1 = [URLString stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLQueryAllowedCharacterSet]];</div><div class="line">//该方法用来进行转码的，即将汉字转码（在Xcode7中，iOS9）</div><div class="line">//NSString *encodedString = [URLString stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];</div><div class="line">NSURL *url =[NSURL URLWithString:[NSString stringWithFormat:@&quot;%@&quot;,encodedString1]];</div><div class="line">self.webView = [[UIWebView alloc]initWithFrame:self.view.bounds];</div><div class="line">self.webView.delegate = self;</div><div class="line">NSURLRequest *request = [NSURLRequest requestWithURL:url ];</div><div class="line">[self.webView loadRequest:request];</div><div class="line">[self.view addSubview:self.webView];</div></pre></td></tr></table></figure>
<p>上面为什么推荐使用<br><code>(NSString *)stringByAddingPercentEncodingWithAllowedCharacters:(NSCharacterSet *)allowedCharacters</code>,<br>这里是文档中给出的解释：</p>
<p><strong>其一：</strong></p>
<pre>
Use -stringByAddingPercentEncodingWithAllowedCharacters: instead, 
which always uses the recommended UTF-8 encoding, 
and which encodes for a specific URL component or subcomponent since each URL component or subcomponent has different rules for what characters are valid.
</pre>

<p>翻译如下：</p>
<p>使用<code>-stringByAddingPercentEncodingWithAllowedCharacters：</code>改为，<br>它总是使用推荐的<code>UTF-8</code>编码，<br>并且其对特定的URL组件或子组件进行编码，因为每个URL组件或子组件对于什么字符是有效的具有不同的规则。</p>
<p><strong>其二：</strong></p>
<pre>
Returns a new string made from the receiver by replacing all characters not in the allowedCharacters set with percent encoded characters. 
UTF-8 encoding is used to determine the correct percent encoded characters. 
Entire URL strings cannot be percent-encoded. 
This method is intended to percent-encode an URL component or subcomponent string, NOT the entire URL string. 
Any characters in allowedCharacters outside of the 7-bit ASCII range are ignored.
</pre>

<p>翻译如下：</p>
<p>通过替换不在allowedCharacters中的所有字符，使用百分比编码字符返回从接收器创建的新字符串。 UTF-8编码用于确定正确的百分比编码字符。 整个URL字符串不能进行百分号编码。 此方法旨在对URL组件或子组件字符串（而不是整个URL字符串）进行百分比编码。 将忽略7位ASCII范围之外的allowedCharacters中的任何字符。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无意中遇到一个问题，项目中使用&lt;code&gt;UIWebView&lt;/code&gt;打不开&lt;code&gt;web&lt;/code&gt;界面，检查过&lt;code&gt;URL&lt;/code&gt;和代码，发现并没有问题。随考虑到一点：&lt;strong&gt;URL中包含汉字&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;处理如下：&lt;
    
    </summary>
    
    
      <category term="iOS" scheme="https:guohuaden.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>对于Xcode中 Build Active Architecture Only 的认识</title>
    <link href="https:guohuaden.com/2017/02/16/Build-Active-Architecture-Only-Query/"/>
    <id>https:guohuaden.com/2017/02/16/Build-Active-Architecture-Only-Query/</id>
    <published>2017-02-16T07:11:12.000Z</published>
    <updated>2017-02-16T08:57:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前在给项目适配64位时，看到Xcode中有这个设置，因为关系到适配问题，又比较好奇，就了解了一番。发现这个设置也有不小的作用。</p>
<p><img src="http://obzx0h1re.bkt.clouddn.com/Build%20Active%20Architecture%20Only2.png" alt="Build Active Architecture Only2"></p>
<font color="#9ACD32"><code>Build Active Architecture Only</code>：指定是否只对当前连接设备所支持的指令集编译</font>

<p>系统默认是：Debug设置为<code>Yes</code>，Release设置为<code>No</code>。</p>
<p><strong>原因</strong>是：</p>
<p>当直接把<code>Build Active Architecture Only</code> 设置为<code>Yes</code>时，可以使Debug的时候编译速度更快，因为它只编译当前的Architecture版本。</p>
<p>而如果设置为<code>No</code>，则编译的事所有的版本。</p>
<p><strong>注</strong>：<font color="#FF7F50">    其中提到的版本是Architecture的支持版本：<code>arm64</code>、<code>armv7</code>、<code>armv7s</code>、<code>i386</code>、<code>x86_64</code>等。</font></p>
<p>其中</p>
<font color="#808000"><br><strong><code>i386</code>是针对intel通用微处理器32位处理器</strong><br><br><strong><code>x86_64</code>是针对x86架构的64位处理器</strong><br><br><strong>模拟器32位处理器测试需要<code>i386</code>架构</strong><br><br><strong>模拟器64位处理器测试需要<code>x86_64</code>架构</strong><br><br><strong>真机32位处理器需要<code>armv7</code>,或者<code>armv7s</code>架构</strong><br><br><strong>真机64位处理器需要<code>arm64</code>架构</strong><br><br></font>

<p>所以我们一般默认Debug设置为<code>Yes</code>，Release设置为<code>No</code>。编译出的版本是向下兼容的，连接的设备的指令集匹配是由高到低（<code>arm64</code> &gt; <code>armv7s</code> &gt; <code>armv7</code>）依次匹配的。比如你设置此值为yes，用iphone4编译出来的是<code>armv7</code>版本的，iphone5也可以运行，但是<code>armv6</code>的设备就不能运行。  所以，一般Debug的时候可以选择设置为<code>Yes</code>，Release的时候要改为<code>No</code>，以便于适配不同的版本。<br><img src="http://obzx0h1re.bkt.clouddn.com/Build%20Active%20Architecture%20Only%20Picture.png" alt="    
Build Active Architecture Only Picture"></p>
<p><strong>但也有直接将<code>Build Active Architecture Only</code>设置为<code>No</code>的情况</strong><br><img src="http://obzx0h1re.bkt.clouddn.com/Build%20Active%20Architecture%20Only1.png" alt="Build Active Architecture Only1"></p>
<p>这样做的原因是因为使用默认设置运行项目时出现错误：<font color="#FF6347"><strong><code>Module ‘Alamofire’ has no member ‘request’</code></strong></font><br>解决方法就是直接都设置为<code>No</code>。</p>
<p><font color="#008000"><strong>问题</strong>：</font><br><img src="http://obzx0h1re.bkt.clouddn.com/Module%20%27Alamofire%27%20has%20no%20member%20%27request%27.png" alt="Module &#39;Alamofire&#39; has no member &#39;request&#39;"></p>
<p><font color="#008000"><strong>方法</strong>：</font><br><img src="http://obzx0h1re.bkt.clouddn.com/Module%20%27Alamofire%27%20has%20no%20member%20%27request%27-answer.png" alt="Module &#39;Alamofire&#39; has no member &#39;request&#39;-answer"></p>
<p>一些有益非浅的链接：</p>
<p><a href="http://blog.csdn.net/lizhongfu2013/article/details/42387311" target="_blank" rel="external">iOS开发～制作同时支持armv7,armv7s,arm64,i386,x86_64的静态库.a</a></p>
<p><a href="http://www.cnblogs.com/hikoming/p/3708659.html" target="_blank" rel="external">Xcode的Architectures、Valid Architectures和Build Active Architecture Only属性(原创)</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前在给项目适配64位时，看到Xcode中有这个设置，因为关系到适配问题，又比较好奇，就了解了一番。发现这个设置也有不小的作用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://obzx0h1re.bkt.clouddn.com/Build%20Active%20Archi
    
    </summary>
    
    
      <category term="Xcode" scheme="https:guohuaden.com/tags/Xcode/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊WKWebView</title>
    <link href="https:guohuaden.com/2017/02/11/WKWebView/"/>
    <id>https:guohuaden.com/2017/02/11/WKWebView/</id>
    <published>2017-02-11T02:33:52.000Z</published>
    <updated>2017-02-14T00:57:40.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>由于之前一直在用<code>UIWebView</code>,所以对于<code>WKWebView</code>只是停留在知道，了解的状态，并未深入的去研究。前天一个项目要求支持iOS8以上，要加入一个web界面。在习惯性使用<code>UIWebView</code>写到一半的时候，突然想使用<code>WKWebView</code>去实现，所以专门花费了些时间去研究了一下<code>WKWebView</code>，很是喜欢。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>接下来纪录一下使用<code>WKWebView</code>的过程细节。但关于<code>WKWebView</code>与<code>js</code>互交的部分保留意见，因为并没有深入去研究这一点。</p>
<h3 id="1、引入WebKit库"><a href="#1、引入WebKit库" class="headerlink" title="1、引入WebKit库"></a>1、引入WebKit库</h3><p>Apple方面为使用<code>WKWebView</code>专门添加了<code>WebKit</code>库，在使用<code>WKWebView</code>时候必须引入<code>WebKit</code>库才可以。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#import &lt;WebKit/WebKit.h&gt;</div></pre></td></tr></table></figure></p>
<h3 id="2、初始化WKWebView"><a href="#2、初始化WKWebView" class="headerlink" title="2、初始化WKWebView"></a>2、初始化WKWebView</h3><p>在文档中可以看出，<code>WKWebView</code>的初始化方法有两种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (instancetype)initWithFrame:(CGRect)frame;</div><div class="line">- (instancetype)initWithFrame:(CGRect)frame configuration:(WKWebViewConfiguration *)configuration NS_DESIGNATED_INITIALIZER</div></pre></td></tr></table></figure>
<ul>
<li>我们大多使用第一种方式，这也是文档中默认的一种方式。这里不再多说。</li>
<li>关于第二种方式，其实就是在初始化<code>WKWebView</code>时，给<code>webView</code>做一个配置，我这里给出一段简单的配置代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc]init];</div><div class="line">config.preferences = [WKPreferences new];</div><div class="line">config.preferences.minimumFontSize = 20.f;</div><div class="line">config.preferences.javaScriptEnabled = YES; //The default value is YES</div><div class="line">config.preferences.javaScriptCanOpenWindowsAutomatically = NO;//The default value is NO in iOS and YES in OS X.</div><div class="line">//config.preferences.javaEnabled = NO ; //The default value is NO .不在iphone中使用的方法</div><div class="line">config.userContentController = [WKUserContentController new];  </div><div class="line">self.webView = [[WKWebView alloc]initWithFrame:self.view.bounds configuration:config];</div></pre></td></tr></table></figure>
<p><strong>注：</strong>其实第一种方式，虽然我们并没有指定初始化的配置，但Apple也为我们指定了一个默认的配置。</p>
<h3 id="3、加载网页"><a href="#3、加载网页" class="headerlink" title="3、加载网页"></a>3、加载网页</h3><p>方法有几种，我们常用的是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSURLRequest *request = [[NSURLRequest alloc]initWithURL:[NSURL URLWithString:@&quot;https://www.baidu.com&quot;]];</div><div class="line">[self.webView loadRequest:request];</div></pre></td></tr></table></figure>
<p>剩下的几种为：</p>
<pre><code>[self.webView loadHTMLString:(nonnull NSString *) baseURL:(nullable NSURL *)];

[self.webView loadFileURL:(nonnull NSURL *) allowingReadAccessToURL:(nonnull NSURL *)];

[self.webView loadData:(nonnull NSData *) MIMEType:(nonnull NSString *) characterEncodingName:(nonnull NSString *) baseURL:(nonnull NSURL *)];
</code></pre><h3 id="4、加载js代码"><a href="#4、加载js代码" class="headerlink" title="4、加载js代码"></a>4、加载js代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 图片缩放的js代码</div><div class="line">NSString *js = @&quot;var count = document.images.length;for (var i = 0; i &lt; count; i++) &#123;var image = document.images[i];image.style.width=500;image.style.height=600;&#125;;window.alert(&apos;找到&apos; + count + &apos;张图&apos;);&quot;;</div><div class="line">// 根据JS字符串初始化WKUserScript对象</div><div class="line">WKUserScript *script = [[WKUserScript alloc] initWithSource:js injectionTime:WKUserScriptInjectionTimeAtDocumentEnd forMainFrameOnly:YES];</div><div class="line">// 根据生成的WKUserScript对象，初始化WKWebViewConfiguration</div><div class="line">WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init];</div><div class="line">[config.userContentController addUserScript:script];</div><div class="line">_webView = [[WKWebView alloc] initWithFrame:self.view.bounds configuration:config];</div><div class="line">[_webView loadHTMLString:@&quot;&lt;head&gt;&lt;/head&gt;&lt;img src=&apos;http://og3hqoz3g.bkt.clouddn.com/%E5%B9%B8%E7%A6%8F%E9%82%AE%E5%B1%80.jpg&apos; /&gt;&quot;baseURL:nil];</div><div class="line">[self.view addSubview:_webView];</div></pre></td></tr></table></figure>
<h3 id="5、代理"><a href="#5、代理" class="headerlink" title="5、代理"></a>5、代理</h3><p><code>WKWebView</code>的代理有两个：<code>WKNavigationDelegate</code> 和 <code>WKUIDelegate</code></p>
<ul>
<li><strong>5.1、 WKNavigationDelegate（加载界面时调用的协议方法）</strong></li>
</ul>
<p>过程：</p>
<ol>
<li>在请求发送之前，决定是否跳转</li>
<li>页面开始加载时调用</li>
<li>在收到响应后，决定是否跳转</li>
<li>内容开始加载时调用</li>
<li>接收到服务器跳转请求之后调用（不一定调用该方法）</li>
<li>页面加载完成时调用</li>
<li>请求失败时调用</li>
</ol>
<p>协议方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">//页面开始加载时调用</div><div class="line">- (void)webView:(WKWebView *)webView didStartProvisionalNavigation:(null_unspecified WKNavigation *)navigation</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;页面开始加载时调用。   2&quot;);</div><div class="line">&#125;</div><div class="line">//内容返回时调用，得到请求内容时调用(内容开始加载) -&gt; view的过渡动画可在此方法中加载</div><div class="line">- (void)webView:(WKWebView *)webView didCommitNavigation:( WKNavigation *)navigation</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;内容返回时调用，得到请求内容时调用。 4&quot;);</div><div class="line">&#125;</div><div class="line">//页面加载完成时调用</div><div class="line">- (void)webView:(WKWebView *)webView didFinishNavigation:( WKNavigation *)navigation</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;页面加载完成时调用。 5&quot;);</div><div class="line">&#125;</div><div class="line">//请求失败时调用</div><div class="line">- (void)webView:(WKWebView *)webView didFailProvisionalNavigation:(WKNavigation *)navigation withError:(NSError *)error</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;error1:%@&quot;,error);</div><div class="line">&#125;</div><div class="line">-(void)webView:(WKWebView *)webView didFailNavigation:(WKNavigation *)navigation withError:(NSError *)error</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;error2:%@&quot;,error);</div><div class="line">&#125;</div><div class="line">//在请求发送之前，决定是否跳转 -&gt; 该方法如果不实现，系统默认跳转。如果实现该方法，则需要设置允许跳转，不设置则报错。</div><div class="line">//该方法执行在加载界面之前</div><div class="line">//Terminating app due to uncaught exception &apos;NSInternalInconsistencyException&apos;, reason: &apos;Completion handler passed to -[ViewController webView:decidePolicyForNavigationAction:decisionHandler:] was not called&apos;</div><div class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler</div><div class="line">&#123;</div><div class="line">    //允许跳转</div><div class="line">    decisionHandler(WKNavigationActionPolicyAllow);</div><div class="line">    </div><div class="line">    //不允许跳转</div><div class="line">//    decisionHandler(WKNavigationActionPolicyCancel);</div><div class="line">    NSLog(@&quot;在请求发送之前，决定是否跳转。  1&quot;);</div><div class="line">&#125;</div><div class="line">//在收到响应后，决定是否跳转（同上）</div><div class="line">//该方法执行在内容返回之前</div><div class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler</div><div class="line">&#123;</div><div class="line">    //允许跳转</div><div class="line">    decisionHandler(WKNavigationResponsePolicyAllow);</div><div class="line">    //不允许跳转</div><div class="line">//    decisionHandler(WKNavigationResponsePolicyCancel);</div><div class="line">    NSLog(@&quot;在收到响应后，决定是否跳转。 3&quot;);</div><div class="line">    </div><div class="line">&#125;</div><div class="line">//接收到服务器跳转请求之后调用</div><div class="line">- (void)webView:(WKWebView *)webView didReceiveServerRedirectForProvisionalNavigation:(null_unspecified WKNavigation *)navigation</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;接收到服务器跳转请求之后调用&quot;);</div><div class="line">&#125;</div><div class="line">-(void)webViewWebContentProcessDidTerminate:(WKWebView *)webView</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;webViewWebContentProcessDidTerminate&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>5.2、WKUIDelegate</strong></li>
</ul>
<p>这方面包括：创建新的WebView、界面弹出提示框<br><strong><em>创建新的WebView</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 创建一个新的WebView</div><div class="line">- (WKWebView *)webView:(WKWebView *)webView createWebViewWithConfiguration:(WKWebViewConfiguration *)configuration forNavigationAction:(WKNavigationAction *)navigationAction windowFeatures:(WKWindowFeatures *)windowFeatures;</div></pre></td></tr></table></figure>
<p><strong><em>界面弹出提示框</em></strong></p>
<p>系统提供了三种弹出提示框的方法：警告框、确认框、输入框</p>
<p>直接查看代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">//警告框</div><div class="line">/**</div><div class="line"> webView界面中有弹出警告框时调用</div><div class="line"> @param webView             web视图调用委托方法</div><div class="line"> @param message             警告框提示内容</div><div class="line"> @param frame               主窗口</div><div class="line"> @param completionHandler   警告框消失调用</div><div class="line"> */</div><div class="line">- (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler</div><div class="line">&#123;</div><div class="line">    completionHandler();</div><div class="line">    NSLog(@&quot;警告框&quot;);</div><div class="line">&#125;</div><div class="line">//输入框</div><div class="line">/**</div><div class="line"> web界面中弹出输入框时调用</div><div class="line"> @param webView             web视图调用委托方法</div><div class="line"> @param prompt              输入消息的显示</div><div class="line"> @param defaultText         初始化时显示的输入文本</div><div class="line"> @param frame               主窗口</div><div class="line"> @param completionHandler   输入结束后调用</div><div class="line"> */</div><div class="line">-(void)webView:(WKWebView *)webView runJavaScriptTextInputPanelWithPrompt:(NSString *)prompt defaultText:(NSString *)defaultText initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(NSString * _Nullable))completionHandler</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;输入框&quot;);</div><div class="line">    completionHandler(@&quot;http&quot;);</div><div class="line">&#125;</div><div class="line">//确认框</div><div class="line">/**</div><div class="line"> 显示一个JavaScript确认面板</div><div class="line"> @param webView             web视图调用委托方法</div><div class="line"> @param message             显示的信息</div><div class="line"> @param frame               主窗口</div><div class="line"> @param completionHandler   确认后完成处理程序调用</div><div class="line"> */</div><div class="line">-(void)webView:(WKWebView *)webView runJavaScriptConfirmPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(BOOL))completionHandler</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;确认框&quot;);</div><div class="line">    completionHandler(YES);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>以上就是WKWebView基本使用方法，其他的不做扩展和补充。也许以后再深入研究时，会有不一样的看法，到时再做推翻或补充。</em></p>
<p>以下是个人的一点看法：</p>
<ol>
<li><code>WKWebView</code>是在iOS8之后出现的新的网页加载控件，将来也必将取代<code>UIWebView</code>，这是毋庸置疑的事情。</li>
<li>关于项目优化方面：其实很多人建议在项目中添加<code>WKWebView</code>去替代<code>UIWebView</code>。以未来的发展趋势来看，这点无可厚非。</li>
</ol>
<p>我下面想说的是站在老项目并且其中内嵌网页比较多的立场的，iOS8以上使用<code>WKWebView</code>，iOS8以下使用<code>UIWebView</code>。这是目前解决方案的好办法。但维护和优化都需要成本，时间也是成本的一部分。</p>
<p>这里附上demo一份：<a href="https://github.com/Wheat-Qin/WKWebView_test" target="_blank" rel="external">WKWebView代码</a></p>
<p>这里给出几个讲解<code>WKWebView</code>的🔗,对我帮助很大：</p>
<ol>
<li><a href="http://www.brighttj.com/ios/ios-wkwebview-new-features-and-use.html" target="_blank" rel="external">WKWebView的新特性与使用</a></li>
<li><a href="http://www.jianshu.com/p/6ba2507445e4" target="_blank" rel="external">使用WKWebView替换UIWebView</a> </li>
<li><a href="http://www.cnblogs.com/junhuawang/p/5759224.html" target="_blank" rel="external">UIWebView、WKWebView使用详解及性能分析</a></li>
<li><a href="http://www.jianshu.com/p/7bb5f15f1daa" target="_blank" rel="external">WKWebView学习笔记</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;由于之前一直在用&lt;code&gt;UIWebView&lt;/code&gt;,所以对于&lt;code&gt;WKWebView&lt;/code&gt;只是停留在知道，了解的状态
    
    </summary>
    
    
      <category term="iOS" scheme="https:guohuaden.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>关于app支持64bit</title>
    <link href="https:guohuaden.com/2017/01/15/support-64bit/"/>
    <id>https:guohuaden.com/2017/01/15/support-64bit/</id>
    <published>2017-01-15T07:18:34.000Z</published>
    <updated>2017-01-16T02:13:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于iOS应用，其实苹果很早就就发布消息：2015年的2月开始，提交App Store的应用必须支持64-bit。而Apple在iPhone 5s 就已经搭配64位双核苹果A7处理器。还是在15年6月，苹果App Store中所有应用更新都必须支持64bit。</p>
<p>但这对于企业级应用来说，并不能限制应用去支持64bit，因为企业级应用不必提交App Store审核。但Apple又有了新的对策：在iOS 10.1测试版中加入了一项提示，如果用户下载的是一个32位应用，系统会提示<code>“XXX”可能使iPhone变慢，应用开发者需要更新此应用以改进其兼容性。</code></p>
<p><img src="http://obzx0h1re.bkt.clouddn.com/64Bit-Prompt.jpg" alt="提示效果图"><br>现在看来Apple这种方式，可算是最有效的方式了，因为这样会直接导致用户对一个应用的不同态度。甚至是不止降低用户量。如果是企业级用户，可以直接引起用户的强烈不满。</p>
<p>不管怎么说，作为一个iOS开发者，既然Apple已经提出，还是要去支持64-bit。</p>
<p>具体做法：<br><img src="http://obzx0h1re.bkt.clouddn.com/64Bit-Work.png" alt="方法如图"></p>
<p>关于Xcode <code>“Build Setting”</code>中的<code>Architectures</code>参数问题：</p>
<ul>
<li><p><code>Architectures</code>：你想支持的指令集。（支持指令集是通过编译生成对应的二进制数据包实现的，如果支持的指令集数目有多个，就会编译出包含多个指令集代码的数据包，造成最终编译的包很大。）</p>
</li>
<li><p><code>Valid architectures</code>：即将编译的指令集。（<code>Valid architectures</code> 和 <code>Architecture</code>两个集合的交集为最终编译生成的版本）</p>
</li>
<li><p><code>Build Active Architecture Only</code>：是否只编译当前设备适用的指令集（如果这个参数设为YES，使用iPhone 6调试，那么最终生成的一个支持ARM64指令集的Binary。一般在DEBUG模式下设为YES，RELEASE设为NO）</p>
</li>
</ul>
<p>对于支持64-bit,我们可以设置<code>Architectures</code>为 <code>Standard architectures</code>，它包括 <code>armv7、armv7s 和 arm64</code>。</p>
<p>而是对于代码中的改变其实也就分为：<strong>数据类型和方法调用</strong> 两个部分。</p>
<p>比如：<code>int -&gt; NSInteger</code></p>
<p>以及得到数组个数的方法：<code>[dataArray count] -&gt; dataArray.count</code></p>
<p>这是关于数据类型改变的总结：<br><img src="http://obzx0h1re.bkt.clouddn.com/64bit-Summary.png" alt="64bit-Summary"><br>上图所说：</p>
<ul>
<li>避免将长整型long赋值给整型int (64-bit上会导致数据丢失)</li>
<li>避免将指针类型pointer赋值给整型int (64-bit导致地址数据丢失)。</li>
<li>留意数值计算，避免指针和长整型在运算上的截断问题(掩码计算,无符号整数和有符号整数同时使用等)。</li>
<li>留意对齐方法带来的变化。</li>
<li>32-bit到64-bit之间数据转化(通过网络传递的用户数据，可能同时存在于32-bit和64-bit的环境下)。</li>
<li>重写汇编代码，让你的代码使用新的64-bit操作码和运行时。</li>
<li>不要在可变参数方法和不可变参数方法之前进行强制转化。</li>
</ul>
<p>具体可以看：《<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/CocoaTouch64BitGuide/Major64-BitChanges/Major64-BitChanges.html" target="_blank" rel="external">64-Bit Transition Guide for Cocoa Touch</a>》</p>
<p>关于iOS应用支持64位的一些详情，可以看看这篇不错的文章：<br>《<a href="http://www.codeceo.com/article/ios-64-bit.html" target="_blank" rel="external">iOS应用如何实现64位的支持</a>》</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于iOS应用，其实苹果很早就就发布消息：2015年的2月开始，提交App Store的应用必须支持64-bit。而Apple在iPhone 5s 就已经搭配64位双核苹果A7处理器。还是在15年6月，苹果App Store中所有应用更新都必须支持64bit。&lt;/p&gt;
&lt;p
    
    </summary>
    
    
      <category term="iOS" scheme="https:guohuaden.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS之项目总结二：关于项目中一些功能的改进建议（从一个维护者的角度）</title>
    <link href="https:guohuaden.com/2017/01/11/project-summary-two/"/>
    <id>https:guohuaden.com/2017/01/11/project-summary-two/</id>
    <published>2017-01-11T15:38:00.000Z</published>
    <updated>2017-01-14T02:11:44.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>最近一直在维护老的项目，遇到的问题也千奇百怪，需要修补的，需要优化的，需要特殊处理的，感觉总是那么的无语。也许这时候也应该感叹一句：路漫漫其修远兮，吾将上下而求索吧。<br>这篇文章就只是讲讲老项目中遇到的种种不敢苟同的代码写法，以及遇到一些问题时的处理方法。</p>
<h3 id="1、关于按钮事件的重复点击问题"><a href="#1、关于按钮事件的重复点击问题" class="headerlink" title="1、关于按钮事件的重复点击问题"></a>1、关于按钮事件的重复点击问题</h3><p>我们开发中大概都经历过这样的事情，我的一个<code>button</code>被重复的快速点击，（我们开发者应该更清楚的知道这意味着什么）。那我们再深入的想一下（给这样的事件安排一个特定的环境）：例如当网络较差的情况下，再例如当<code>button</code>的执行事件较为耗时时。这时就会出现很多的问题：有时是界面出现问题（当<code>button</code>执行事件中出现调节界面<code>frame</code>的时候）；有时则会出现卡顿，更甚至会出现崩溃现象。对于这种问题，我们要提前考虑到，做好防范处理：即点击按钮事件时,添加防止重复点击功能。</p>
<p><strong>思路是</strong>：防止按钮重复点击<br>比较推荐的解决方法代码：</p>
<pre> - (void)btnClicked:(id)sender {
    //在这里做按钮的想做的事情。
}
- (void)buttonClicked:(id)sender {
   //先将未到时间执行前的任务取消。
    [[self class] cancelPreviousPerformRequestsWithTarget:self selector:@selector(btnClicked:)object:sender];
    [self performSelector:@selector(btnClicked:)withObject:sender afterDelay:0.2f];
}</pre>

<p><strong>原理是</strong> ：我们每次点击按钮时，先执行取消之前的按钮点击执行事件，然后再去执行一个延迟执行方法（方法中执行的是按钮执行的事件）。</p>
<p>还有一种方法也是可以实现的：具体的看《<a href="http://www.cnblogs.com/LQCQ-Silent/p/6082086.html" target="_blank" rel="external">iOS之防止用户重复点击Button（按钮）问题</a> 》</p>
<h3 id="2、很多界面共用一个界面时：使用枚举做类型判断"><a href="#2、很多界面共用一个界面时：使用枚举做类型判断" class="headerlink" title="2、很多界面共用一个界面时：使用枚举做类型判断"></a>2、很多界面共用一个界面时：使用枚举做类型判断</h3><p>老的项目中会出现很多这样的现象：很多界面重复使用一个界面，这样就自然而然的需要在不同的界面跳转到复用的界面时去做判断。而奇怪的地方在于：判断的依据是<code>self.title</code>。那么就会出现这样一种现象：在跳转界面后会有一大段<code>if</code>去判断字符串是否等于<code>self.title</code> 。</p>
<p><strong>如果我们做一些改变：使用枚举来做界面类型的判断，使用<code>switch case</code>语句做判断执行代码。这样会不会更优美，简洁一些。</strong></p>
<h3 id="3、关于老项目中iOS10以上的情况下，导航栏中按钮不显示问题"><a href="#3、关于老项目中iOS10以上的情况下，导航栏中按钮不显示问题" class="headerlink" title="3、关于老项目中iOS10以上的情况下，导航栏中按钮不显示问题"></a>3、关于老项目中iOS10以上的情况下，导航栏中按钮不显示问题</h3><p>如果你的<code>viewController</code>都继承于基类，那么在基类中添加这样一段代码（这也是目前我发现的最省事的方法）：</p>
<pre>- (void)viewWillAppear:(BOOL)animated { 
    [super viewWillAppear:animated];
    [self.navigationController setNavigationBarHidden:YES animated:NO];
    [self.navigationController setNavigationBarHidden:NO animated:NO];
}
- (void)viewWillDisappear:(BOOL)animated {
    [super viewWillDisappear:animated];
    [self.navigationController setNavigationBarHidden:YES animated:NO];
    [self.navigationController setNavigationBarHidden:NO animated:NO];
}</pre>



<h3 id="4、事件方法要每个界面区分开"><a href="#4、事件方法要每个界面区分开" class="headerlink" title="4、事件方法要每个界面区分开"></a>4、事件方法要每个界面区分开</h3><p>老项目中会有这种情况：在本界面 command点击一个<code>button</code>执行事件方法或者手势事件方法时，会莫名其妙的跳转到另外一个界面。<br>我们在开发时最好给不同界面<code>button</code>的<code>clicked</code>事件命名是区分开来，例如：界面名 + <code>ButtonClicked</code></p>
<h3 id="5、对象为空现象"><a href="#5、对象为空现象" class="headerlink" title="5、对象为空现象"></a>5、对象为空现象</h3><p>在开发中如果存在<code>image</code>为空，或者必须显示的<code>String</code>为空现象，<br>记得在代码中作判断，图片可以直接设置默认图片，字符串也可以设置默认字符串<br>这一点可以学一下SDWebImage库中对于网络请求图片不存在的处理方法：</p>
<p><pre>//给一张默认图片，先使用默认图片，当图片加载完成后再替换<br>[self.image1 sd_setImageWithURL:imagePath1 placeholderImage:[UIImage imageNamed:@”default”]];</pre>例如：</p>
<p><pre><br>UIImage *image = [UIImage imageNamed:@”image”];</pre></p>
<p>UIImage *defaultImage = [UIImage imageNamed:@”defaultImage”];</p>
<p>UIImageView *imageView = [[UIImageView alloc]initWithImage:image==nil ?  image:defaultImage];<br>字符串当然也是类似，其实看似有些费事甚至有的显得多余的写法，会使以后的维护变得更加的如意。</p>
<h3 id="6、一个界面多网络请求问题，而且需要多个请求都完成后，对界面有一些操作。"><a href="#6、一个界面多网络请求问题，而且需要多个请求都完成后，对界面有一些操作。" class="headerlink" title="6、一个界面多网络请求问题，而且需要多个请求都完成后，对界面有一些操作。"></a>6、一个界面多网络请求问题，而且需要多个请求都完成后，对界面有一些操作。</h3><p>这是一个老的话题了，我之所以重新提及这个话题，原因是我从一些文章中发现了一个从来没使用过的方法，这个下面会提到，现在就让我们列举出来比较常用的方法。就以一个界面两个网络请求为例 A和B.</p>
<p><strong>（1）两个请求互套)(也是最笨的方法)</strong><br>     具体是这样的，我在A请求成功后，再请求B。当然如果请求多的话，这个肯定是作废的。</p>
<p><strong>（2）使用GCD中的通知</strong></p>
<p><pre>dispatch_group_t serviceGroup = dispatch_group_create();<br>// 开始第一个网络请求<br>servicedispatch_group_enter(serviceGroup);<br>[self.configService startWithCompletion:^(ConfigResponse <em>results, NSError </em>error) {<br> //请求成功后的操作<br>    configError = error;<br>    dispatch_group_leave(serviceGroup);//完成后离开分组<br>}];<br>// 开始第二个请求<br>dispatch_group_enter(serviceGroup);<br>[self.preferenceService startWithCompletion:^(PreferenceResponse <em>results, NSError </em>error) {<br> //请求成功后的操作<br>    preferenceError = error;<br>    dispatch_group_leave(serviceGroup);//完成后离开分组<br>}];<br>dispatch_group_notify(serviceGroup,dispatch_get_main_queue(),^{<br> // Assess any errors<br>     NSError *overallError = nil;<br>    if (configError || preferenceError)  {<br> // 判断时候请求有失败<br>        overallError = configError ?: preferenceError;<br>     }<br>// 最后完成后执行的block<br>    completion(overallError);<br>});<br></pre></p>
<p><strong>（3）利用GCD中的信号量</strong></p>
<p>在GCD中有三个函数是<code>semaphore</code>的操作，分别是：　　<br><code>dispatch_semaphore_create</code> 创建一个semaphore　　<br><code>dispatch_semaphore_signal</code> 发送一个信号　<br><code>dispatch_semaphore_wait</code> 等待信号　　<br>简单的介绍一下这三个函数，第一个函数有一个整形的参数，我们可以理解为信号的总量，<code>dispatch_semaphore_signal</code>是发送一个信号，自然会让信号总量加1，<code>dispatch_semaphore_wait</code>等待信号，当信号总量少于0的时候就会一直等待，否则就可以正常的执行，并让信号总量-1，根据这样的原理，我们便可以快速的创建一个并发控制来同步任务和有限资源访问控制。</p>
<p>利用这样的机制，当信号量达到我们网络请求的数量时，请求结束。</p>
<p><strong>（4）这个也是我上面说的无意中看到的一个方法，仅拿出来作为参考</strong></p>
<p><pre>dispatch_async(concurrent_queue, ^{<br>     NSLog(@”—并发任务1—“);<br>});<br>dispatch_async(concurrent_queue, ^{<br>     NSLog(@”—并发任务2—“);<br>});<br>dispatch_barrier_async(concurrent_queue, ^{<br>    dispatch_async(dispatch_get_main_queue(), ^{<br>        NSLog(@”—所有并发任务结束后回到主线程刷新—“);<br>    });<br>}); </pre></p>
<p>以上就是关于一界面多请求的不同解决方案。</p>
<h3 id="7、代码规范问题"><a href="#7、代码规范问题" class="headerlink" title="7、代码规范问题"></a>7、代码规范问题</h3><ul>
<li>为什么这个普通的话题放到最后呢，大概是因为我觉得这个很重要的问题吧，毕竟技术水平不高，还是可以提升的。但代码不规范的话，养成习惯后很难改的，我见过太多项目中使用【拼音命名、不注意驼峰命名法、define预处理指令满天飞等等的代码】这些出现在项目中就像时时刻刻在提醒你，看这样的项目是一种煎熬。</li>
<li>其实代码规范不仅仅是公司对开发者的要求,也是开发者对自己的一个要求。因为如果统一每个人的写作规范，是一件耗时，耗材的事情。小一些的公司是做不来，中型的公司大多是不想做。而大型的公司总是花费近几个月的时间去培养员工的代码规范，这就是财大气粗吧。而且开发者本身对于技术的提升、追求等，都无形中要求自己注意代码规范问题。</li>
<li>对于这部分，建议看看《Effective Objective-C 2.0》这本书，其中起到的。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h3&gt;&lt;p&gt;最近一直在维护老的项目，遇到的问题也千奇百怪，需要修补的，需要优化的，需要特殊处理的，感觉总是那么的无语。也许这时候也应该感叹一句：
    
    </summary>
    
    
      <category term="iOS" scheme="https:guohuaden.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>SVN提交错误：&quot;XXX&quot; is scheduled for addition, but is missing</title>
    <link href="https:guohuaden.com/2016/12/15/SVN-error/"/>
    <id>https:guohuaden.com/2016/12/15/SVN-error/</id>
    <published>2016-12-15T03:18:00.000Z</published>
    <updated>2017-01-15T07:14:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>最近在维护老项目，所以出现了很多以前没遇到过的问题。也算见识一番吧。<br>目前所在的公司使用SVN作为版本控制器，所以接下来这个问题也是就关于SVN的。</p>
<h3 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h3><p>今天使用SVN提交项目时，出现了这样的提示：<pre><code>“XXX” is scheduled for addition, but is missing。（无关紧要的东西用XXX代替）。 </code></pre><br>看报错说明是这样的：<code>“XXX”已经被列为添加状态，但我们提交时却缺少”XXX”这个。</code></p>
<h3 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h3><p>之前用SVN提交过的文件/文件夹，被标记为”addition”状态，等待被加入到仓库。虽然你把这个文件删除了，SVN提交的时候还是会尝试提交这个文件，所以就会提示：<code>“but is missing”。</code><br>当然删除这个东西，就是因为它多余，不然也不会多此一举。现在出现这种错误，我们不可能再去添加上去，所以解决方法只能从SVN上着手了，首先想到的就是更新SVN配置文件。<br>我的”XXX”是这样的：<pre><code> /Users/guohua/Desktop/项目/项目名字XXX/idealservice/idealservice/Classes/External/SDWebImage/FLAnimatedImage  </code></pre>缺少的文件夹是：<code>FLAnimatedImage  。</code><br>思路是对的，那就看解决方法吧：<br><code>命令行：svn revert  将”XXX”  revert（恢复） 到它的上级目录</code><br>具体这样：<pre><code><br>svn revert  /Users/guohua/Desktop/项目/项目名字XXX/idealservice/idealservice/Classes/External/SDWebImage –depth infinity </code></pre></p>
<p>如果你SVN提示缺少<code>XXX.png</code><br>可以直接复原到这个图片位置：<pre><code>svn revert  /Users/guohua/Desktop/项目/项目名字XXX/…/XXX.png  </code></pre></p>
<p>下面我们去提交，就没有这种报错提示了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h3&gt;&lt;p&gt;最近在维护老项目，所以出现了很多以前没遇到过的问题。也算见识一番吧。&lt;br&gt;目前所在的公司使用SVN作为版本控制器，所以接下来这个问
    
    </summary>
    
    
      <category term="SVN" scheme="https:guohuaden.com/tags/SVN/"/>
    
  </entry>
  
  <entry>
    <title>iOS之使用模拟器错误 (Code Sign Error:resource fork, Finder information, or similar detritus not allowed)</title>
    <link href="https:guohuaden.com/2016/11/14/Xcode-error-Code%20Sign%20Error/"/>
    <id>https:guohuaden.com/2016/11/14/Xcode-error-Code Sign Error/</id>
    <published>2016-11-14T12:01:31.000Z</published>
    <updated>2017-02-08T02:14:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>很奇怪的问题，使用真机测试没有问题。但使用模拟器测试的时候就会报这样的错误，错误类型为：<code>Code Sign Error</code></p>
<p>错误提示是这样：<code>resource fork, Finder information, or similar detritus not allowed。</code></p>
<p>找了很多资料，说的都是一半一半，有的看了仍是无从下手。最后看到的处理方式是这样的：</p>
<p>首先关闭<code>Xcode</code>，打开终端：</p>
<p>进入<code>DerivedData</code>目录</p>
<p><code>cd ~/Library/Developer/Xcode/DerivedData/ </code></p>
<p>然后再终端输入：<code>xattr -rc .</code> </p>
<p><code>xattr -rc .</code> </p>
<p>再次运行项目，就没有这样报错了。（也算是对症下药吧）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很奇怪的问题，使用真机测试没有问题。但使用模拟器测试的时候就会报这样的错误，错误类型为：&lt;code&gt;Code Sign Error&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;错误提示是这样：&lt;code&gt;resource fork, Finder information, or simil
    
    </summary>
    
    
      <category term="Xcode" scheme="https:guohuaden.com/tags/Xcode/"/>
    
  </entry>
  
  <entry>
    <title>Base64加密和DES加密、以及JAVA和iOS中DES加密统一性问题</title>
    <link href="https:guohuaden.com/2016/10/06/DES-encryption/"/>
    <id>https:guohuaden.com/2016/10/06/DES-encryption/</id>
    <published>2016-10-06T14:14:00.000Z</published>
    <updated>2017-01-14T13:07:16.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><em>我们在项目中为了安全方面的考虑，通常情况下会选择一种加密方式对需要安全性的文本进行加密，而Base64加密和DES64加密是常用的加密算法。我记得我在前一个项目中使用的就是这两种加密算法的结合：Base64 ＋ DES加密。当然这需要移动端和后台服务器做一个统一。</em></p>
<h3 id="1、Base64加解密"><a href="#1、Base64加解密" class="headerlink" title="1、Base64加解密"></a>1、Base64加解密</h3><p>值得一提的是：apple提供了基础的Base64加解密算法。这样我们就可以直接使用方法去实现Base64加解密。先看一下apple都提供了哪些方法：<br><pre>@interface NSData (NSDataBase64Encoding)<br>-(nullable instancetype)initWithBase64EncodedString:(NSString <em> )base64String options:(NSDataBase64DecodingOptions)options NS_AVAILABLE(10_9, 7_0);<br>-(NSString </em> )base64EncodedStringWithOptions:(NSDataBase64EncodingOptions)options NS_AVAILABLE(10_9, 7_0);<br>-(nullable instancetype)initWithBase64EncodedData:(NSData <em> )base64Data options:(NSDataBase64DecodingOptions)options NS_AVAILABLE(10_9, 7_0);<br>-(NSData </em> )base64EncodedDataWithOptions:(NSDataBase64EncodingOptions)options NS_AVAILABLE(10_9, 7_0);<br>@end</pre> </p>
<p>我们先创建一个NSData，再去一条一条的分析以上的方法</p>
<pre>NSData *data = [@"Base64 encoding string" dataUsingEncoding:NSUTF8StringEncoding];</pre>

<ul>
<li><p>（1）创建一个Data（从一个Base64编码字符串使用给出的设置创建一个Data）</p>
<pre>NSData *dataFromBase64String = [[NSData alloc]initWithBase64EncodedString:base64String options:0];</pre>
</li>
<li><p>(2)创建一个Base64编码字符串（从接受者内容创建）</p>
<pre>NSString *base64String = [data base64EncodedStringWithOptions:0];</pre>
</li>
<li><p>(3)创建一个Data（从一个Base64、UTF-8编码的Data创建）</p>
<pre>NSData *base64AndUTFData = [base64Data initWithBase64EncodedData:base64Data options:0];</pre>
</li>
<li><p>(4)创建一个Base64、UTF-8编码的Data（从接受者内容创建）</p>
<pre>NSData *base64Data = [data base64EncodedDataWithOptions:0];</pre>


</li>
</ul>
<p><strong>当然，我们最后也可以将Data转化成String类型。</strong></p>
<pre>NSString *base64Decoded = [[NSString alloc]initWithData:dataFromBase64String encoding:NSUTF8StringEncoding];</pre>



<p><em>以上是Base64加解密方法。下面我们看看DES的加解密。</em></p>
<h3 id="2、DES加解密"><a href="#2、DES加解密" class="headerlink" title="2、DES加解密"></a>2、DES加解密</h3><p>我们都知道安卓和后台可以使用统一的代码去解决这个问题，这也是java的优势之一吧。这里我会附一段java的代码。主要是为了下面说明java和iOS端实现中需要注意的地方（也是不同点）。<br>为了使说明更方便一些，我们先看一下java的DES加密方法：</p>
<pre>// EDS加密
 public static String Encrypt(String originalStr) {
   String result = null;
   byte[] tmpOriginalStr = null;
   try {
       if (!Tools.isEmpty(originalStr)) {
           tmpOriginalStr = originalStr.getBytes("utf-8");
           SecretKeyFactory keyFactory = SecretKeyFactory.getInstance("DES");
           DESKeySpec dks = new DESKeySpec(KEY);
           SecretKey secretKey = keyFactory.generateSecret(dks);
           IvParameterSpec param = new IvParameterSpec(IV);
           Cipher cipher = Cipher.getInstance("DES/CBC/PKCS5Padding");
           cipher.init(Cipher.ENCRYPT_MODE, secretKey,param);
           byte[] tmpEncypt = cipher.doFinal(tmpOriginalStr);
           if (tmpEncypt != null) {
               result = Base64.encodeToString(tmpEncypt,Base64.NO_WRAP);
            }
         }
      } catch (Exception e) {
            Log.e("Erro",e.getMessage());
      }
     return result;
  }
}
</pre>

<p>我们可以看出Java针对DES加密算法默认使用的是<code>CBC模式</code>，对齐方式采用的是:<code>PKCS5Padding</code>。</p>
<p>而OC中的加密并不是java中的形式实现加密的，接下来我们看一看OC中实现DES加密的代码：</p>
<pre>+(NSString *) encryptUseDES:(NSString *)plainText {
    NSString * ciphertext = nil;
    NSData * textData = [plainText dataUsingEncoding:NSUTF8StringEncoding];
    NSUInteger dataLength = [textData length];
    unsigned char buffer[1024 * 5];
    memset(buffer, 0, sizeof(char));
    size_t numBytesEncrypted = 0;
    CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt, kCCAlgorithmDES,
                                          kCCOptionPKCS7Padding,
                                          [key UTF8String], kCCKeySizeDES,
                                          [iv UTF8String],
                                          [textData bytes], dataLength,
                                          buffer, 1024,
                                          &numBytesEncrypted);
    if (cryptStatus == kCCSuccess) {
        NSData *data = [NSData dataWithBytes:buffer length:(NSUInteger)numBytesEncrypted];
        ciphertext = [data base64EncodedStringWithOptions:0];
    }
    return ciphertext;
}
</pre>

<p>先说一下代码中的<strong>key和iv</strong> 。<code>key</code>：是DES加密的公钥。而<code>iv</code>：是初始化的矢量。两者都是DES加密的关键参数。这个是必须要和Android、后台有个统一的。</p>
<p>我们可以看出OC使用的是<code>kCCOptionPKCS7Padding</code>对齐方式。而java中很明确的指出使用的是<code>PKCS5Padding</code>。接下来我们点进去看看OC中给出的对齐选择有哪些，我直接以代码的形式展示出来：</p>
<p><pre>@constant   kCCOptionPKCS7Padding   Perform PKCS7 padding.<br>@constant   kCCOptionECBMode        Electronic Code Book Mode.<br>                                    Default is CBC.<br>enum {<br>    /<em> options for block ciphers </em>/<br>    kCCOptionPKCS7Padding   = 0x0001,<br>    kCCOptionECBMode        = 0x0002<br>    /<em> stream ciphers currently have no options </em>/<br>};</pre></p>
<p> OC中给出的是<code>kCCOptionECBMode</code> 和<code> kCCOptionPKCS7Padding</code>这两种选择。那么，问题现在出现了。java中的DES加密算法有很多种，例如：<code>ECB，CBC，OFB，CFB</code>等。</p>
<p>java 和 OC的DES加密怎样才能实现一致性呢？（这也是我在项目中遇到的问题）。</p>
<p>查阅很多资料，再加上自己的很多次测试，得出的结果如下：</p>
<p><strong>在JAVA中使用这种方式加密：<code>DES/CBC/PKCS5Padding</code> 对应的Object-C的是 <code>kCCOptionPKCS7Padding</code>.<br>而使用<code>DES/ECB/PKCS5Padding</code> 对应的Object-C的是   <code>kCCOptionPKCS7Padding | kCCOptionECBMod</code><br>觉得似乎OC目前只支持这两种方式的加密。当然结果是已经得到验证的。</strong></p>
<p><strong>注意：md5加密（iOS SDK中自带了CommonCrypto）出现警告⚠️ 。解决方法添加：引入函数定义的头文件</strong> :<code>#import &lt;CommonCrypto/CommonDigest.h&gt;</code></p>
<p>其他链接：</p>
<p>《<a href="http://www.tuicool.com/articles/UJJrAj" target="_blank" rel="external">Objective C与Java之间的DES加解密实现</a>》</p>
<p>《<a href="http://iosdevelopertips.com/core-services/encode-decode-using-base64.html" target="_blank" rel="external">iOS 7: Base64 Encode and Decode NSData and NSString Objects</a>》</p>
<p> 这里附上demo：<a href="https://github.com/Wheat-Qin/Base64-DES" target="_blank" rel="external">https://github.com/Wheat-Qin/Base64-DES</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&lt;em&gt;我们在项目中为了安全方面的考虑，通常情况下会选择一种加密方式对需要安全性的文本进行加密，而Base64加密和DES64加密是常用的加
    
    </summary>
    
    
      <category term="iOS" scheme="https:guohuaden.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS之项目总结－：项目中遇到的各种的问题和解决方法</title>
    <link href="https:guohuaden.com/2016/08/16/project-summary-one/"/>
    <id>https:guohuaden.com/2016/08/16/project-summary-one/</id>
    <published>2016-08-16T10:28:00.000Z</published>
    <updated>2017-01-14T18:00:46.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p> 一到公司报道那时，便着手独立的去完成了一个项目，其中的辛酸泪也是不足为外人道也。这次算是一个新型的app，仍然是独立开发，但心境和想法却是完全的不同。下面说一次以前做开发时常常忽略的知识，也算是一种复习了吧。下面言归正传：</p>
<h3 id="1、自带键盘的next用法"><a href="#1、自带键盘的next用法" class="headerlink" title="1、自带键盘的next用法"></a>1、自带键盘的next用法</h3><p>这算是比较常用的了吧，只要我们想到登录和注册界面，就应该自然而然的想到 - 键盘的next用法（当然不排除相当多的软件并没有实现这个功能）。</p>
<p>想法也就是：用户在输入用户名后，点击next跳转到下一个输入框。其实也不用想的如此复杂，在登录界面，我们完全可以用一个 if 语句做判断，去实现键盘的响应和注销响应。</p>
<p>代码如下： <pre>- (BOOL)textFieldShouldReturn:(UITextField <em> )textField {<br>  UITextField </em> passTextFiled = (UITextField *)[self.view viewWithTag:201];<br>  if (textField.tag == 200) {<br>          [passTextFiled becomeFirstResponder];<br>   }else{<br>           [passTextFiled resignFirstResponder];<br>    }<br>   return YES;<br>}</pre></p>
<p>这样就简单的在变成响应和注销响应之间实现了输入框的切换。</p>
<p>但还是存在一个问题，如果我实现注册界面的跳转输入框，并且在输入框很多的情况下，显然如果我仍是这样判断，会显得啰嗦和冗余。</p>
<p>我曾想过使用计数的方式，记录每一次的点击next后的tag，但实践中失败了，因为当我不通过next而是直接用手去触摸选择输入框时，则无法计数。</p>
<p> 这里先留个空白，等把手里的项目完成时再研究这个问题</p>
<h3 id="2、UITextField的纠错和首字母大小写问题"><a href="#2、UITextField的纠错和首字母大小写问题" class="headerlink" title="2、UITextField的纠错和首字母大小写问题"></a>2、UITextField的纠错和首字母大小写问题</h3><p>这个问题只是简单的属性问题，在开发时如果忘记，建议多点进去看看，（如：command + UITextField）   </p>
<pre>
 //输入框中是否有个叉号，在什么时候显示，用于一次性删除输入框中的内容    
self.clearButtonMode = UITextFieldViewModeWhileEditing;    
//是否纠错,本人感觉纠错是一个很反感的东西，但UITextField默认是 YES,这里我改成了NO      
self.autocorrectionType = UITextAutocorrectionTypeNo;       
 //再次编辑就清空      
self.clearsOnBeginEditing = YES;       
//设置自动缩小显示的最小字体大小      
self.minimumFontSize = 15;        
//设置键盘的样式，本人感觉这个设置对用户体验有影响。比如说我想打电话，Type为UIKeyboardTypeNumberPad,而不是其他     
self.keyboardType = UIKeyboardTypeNamePhonePad;</pre>

<h3 id="3、iOS中图片的几种拉伸方法的使用"><a href="#3、iOS中图片的几种拉伸方法的使用" class="headerlink" title="3、iOS中图片的几种拉伸方法的使用"></a>3、iOS中图片的几种拉伸方法的使用</h3><p>以下是Apple SDK给出的3种方法:</p>
<pre>UIImage *image = [UIImage imageNamed:@"picture"];        
//iOS5之前     
// 左端盖宽度        
NSInteger leftCapWidth = image.size.width * 0.5f;       
NSInteger topCapHeight = image.size.height * 0.8f;        

image = [image stretchableImageWithLeftCapWidth:leftCapWidth topCapHeight:topCapHeight];        

//iOS5之后       
UIEdgeInsets insets = UIEdgeInsetsMake(image.size.height * 0.8f,image.size.width * 0.5f, 40, 40);       

image = [image resizableImageWithCapInsets:insets];      
//iOS6之后        
UIEdgeInsets insets = UIEdgeInsetsMake(image.size.height * 0.8f,image.size.width * 0.5f, 40, 40);       
image = [image resizableImageWithCapInsets:insets resizingMode:UIImageResizingModeStretch]; </pre>  

<p>下面是使用的解释：<br><img src="http://obzx0h1re.bkt.clouddn.com/pictureStretch.png" alt="pictureStretch"></p>
<pre>
/**   
 *  - (UIImage *)stretchableImageWithLeftCapWidth:(NSInteger)leftCapWidth topCapHeight:(NSInteger)topCapHeight;    
 *  
 *  leftCapWidth代表左端盖宽度，topCapHeight代表顶端盖高度。系统会自动计算出右端盖宽度(rightCapWidth)和底端盖高度(bottomCapHeight)    

 * 算法如下：    
 * width为图片宽度  rightCapWidth = width - leftCapWidth - 1;       
 * height为图片高度 bottomCapHeight = height - topCapHeight - 1    
 *    
 *经过计算，你会发现中间的可拉伸区域只有1x1    
 *   

* stretchWidth为中间可拉伸区域的宽度        stretchWidth = width - leftCapWidth - rightCapWidth = 1;       
* stretchHeight为中间可拉伸区域的高度        stretchHeight = height - topCapHeight - bottomCapHeight = 1;    
*    
* 因此，使用这个方法只会拉伸图片中间1x1的区域，并不会影响到边缘和角落。    
*/

/**   
 * - (UIImage * )resizableImageWithCapInsets:(UIEdgeInsets)capInsets    
 *  这个方法只接收一个UIEdgeInsets类型的参数，可以通过设置UIEdgeInsets的left、right、top、bottom来分别指定左端盖宽度、右端盖宽度、顶端盖高度、底端盖高度    
 * */       

/**    
 *- (UIImage * )resizableImageWithCapInsets:(UIEdgeInsets)capInsets resizingMode:(UIImageResizingMode)resizingMode  

对比iOS5.0中的方法，只多了一个<code>UIImageResizingMode</code>参数，用来指定拉伸的模式：
    UIImageResizingModeStretch：拉伸模式，通过拉伸
    UIEdgeInsets:指定的矩形区域来填充图片    
    UIImageResizingModeTile：平铺模式，通过重复显示
    UIEdgeInsets指定的矩形区域来填充图片   
**/</pre>

<p>图片拉伸的以上内容参考文章 《<a href="http://blog.csdn.net/q199109106q/article/details/8615661" target="_blank" rel="external">iOS图片拉伸技巧</a>》讲的很好，建议大家多看看。</p>
<h3 id="4、iOS中唤起自带浏览器（safari）的方法"><a href="#4、iOS中唤起自带浏览器（safari）的方法" class="headerlink" title="4、iOS中唤起自带浏览器（safari）的方法"></a>4、iOS中唤起自带浏览器（safari）的方法</h3><p>也是一个简单的一句代码 ，这种也就是知道了就知道了，不知道就是抓耳挠腮吧 </p>
<pre>NSURL *url = [NSURL URLWithString:urlStr]; 

[[UIApplication sharedApplication] openURL:url]; </pre>

<h3 id="5、iOS中唤起电话界面"><a href="#5、iOS中唤起电话界面" class="headerlink" title="5、iOS中唤起电话界面"></a>5、iOS中唤起电话界面</h3><p>app内部唤起电话界面的实现，是找了很多资料才有的一个结论（安全，并且拨打完之后可以返回app）</p>
<p>实现的方法是使用UIWebView 加载电话，目前这种方法是合法的，App Store也允许通过的。  </p>
<pre>NSURL *phoneURL = [NSURL URLWithString:[NSString stringWithFormat:@"tel:%@",newPhoneString]];    
 if (_phoneCallWebView) { 
   [_phoneCallWebView loadRequest:[NSURLRequest requestWithURL:phoneURL]];  

 }</pre>

<p>但如果使用下面的这种方法，则可能不允许通过审核  </p>
<pre>[[UIApplication sharedApplication] openURL:phoneURL];</pre>

<h3 id="6、iOS-调用地图的方法"><a href="#6、iOS-调用地图的方法" class="headerlink" title="6、iOS 调用地图的方法"></a>6、iOS 调用地图的方法</h3><p>app内部调用第三方app，这里有一个详细的文章《<a href="http://blog.csdn.net/a416863220/article/details/51220739" target="_blank" rel="external">IOS实现应用内打开第三方地图app进行导航</a>》</p>
<ul>
<li>app内部调用地图，需要先检测用户手机上是否已经安装地图app。</li>
</ul>
<p>我们常用的地图app有：高德、百度；国外有：谷歌（Google Map ）。当然还有苹果自带的地图，随着iOS10的发布，苹果地图这块也有很大的完善和进步。</p>
<p>我使用Xcode模拟器实现时，会提示:</p>
<pre>1、canOpenURL: failed for URL: "iosamap://" error: "(null)" 。</pre>

<p><strong>原因是</strong>：模拟器上没有高德地图。</p>
<pre>
2、canOpenURL: failed for URL:"comgooglemaps://" error: "This app is not allowed to query for scheme comgooglemaps"。</pre>

<p><strong>原因是</strong>：<code>LSApplicationQueriesSchemes</code>我自己马虎设成了字典类型。</p>
<p>首先iOS9以后，我们在app内部要跳转到其他软件时，需要在 <code>Info.plist</code> 中添加白名单。</p>
<p>方法为：在<code>Info.plist</code>中添加 <code>key : LSApplicationQueriesSchemes </code> 类型为：<code>Array</code>。</p>
<p>将高德、百度、谷歌的值填进去分别是：<code>iosamap</code>、<code>baidumap</code>、 <code>comgooglemaps</code></p>
<p>图片：<br><img src="http://obzx0h1re.bkt.clouddn.com/LSApplicationQueriesSchemes.png" alt="LSApplicationQueriesSchemes"></p>
<p>至于下面代码中的<code>URLScheme</code> 和<code>appName </code> 是在<code>Info.plist</code> 的<code>URL types</code>中添加  <code>URL Scheme</code>(URL Schemes是一个数组，允许应用定义多个URL schemes)和<code>URL identifier</code>（建议采用反转域名的方法保证该名字的唯一性，比如 <code>com.yourApp.www</code>）</p>
<p>图片如下：</p>
<p><img src="http://obzx0h1re.bkt.clouddn.com/URLTypes.png" alt="URLTypes"></p>
<p>下面是具体的代码：</p>
 <pre>__block NSString *urlScheme = urlScheme;   

 __block NSString *appName = appName;    

__block CLLocationCoordinate2D coordinate = self.coordinate;        

UIAlertController *alert = [UIAlertController alertControllerWithTitle:@"选择地图" message:nil preferredStyle:UIAlertControllerStyleActionSheet];          

//apple自带的地图不需要判断        

UIAlertAction * action = [UIAlertAction actionWithTitle:@"苹果地图" style:UIAlertActionStyleDefault handler:^(UIAlertAction *action) {      

       MKMapItem *currentLocation = [MKMapItem mapItemForCurrentLocation]; 

     MKMapItem *toLocation = [[MKMapItem alloc] initWithPlacemark:[[MKPlacemark alloc] initWithCoordinate:coordinate addressDictionary:nil]];                      

     [MKMapItem openMapsWithItems:@[currentLocation, toLocation]                           launchOptions:@{

MKLaunchOptionsDirectionsModeKey:     MKLaunchOptionsDirectionsModeDriving,MKLaunchOptionsShowsTrafficKey: [NSNumber numberWithBool:YES]}];        

}];        

 [alert addAction:action];        

 //判断百度地图   

 if ( [[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@"baidumap://"]])      

{        UIAlertAction * action = [UIAlertAction actionWithTitle:@"百度地图" style:UIAlertActionStyleDefault handler:^(UIAlertAction *action) {                       

 NSString *urlString = [[NSString stringWithFormat:@"baidumap://map/direction?origin=&destination=latlng:%f,%f|name=目的地&mode=driving&coord_type=gcj02",coordinate.latitude, coordinate.longitude] stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];

  [[UIApplication sharedApplication] openURL:[NSURL URLWithString:urlString]];         

 }];        

[alert addAction:action];      

}     

 //判断高德地图     

 if ( [[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@"iosamap://"]])      

 {        

UIAlertAction * action = [UIAlertAction actionWithTitle:@"高德地图" style:UIAlertActionStyleDefault handler:^(UIAlertAction *action) {                        

NSString *urlString = [[NSString stringWithFormat:@"iosamap://navi?sourceApplication=%@&backScheme=%@&lat=%f&lon=%f&dev=0&style=2",appName,urlScheme,coordinate.latitude, coordinate.longitude] stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];  

        [[UIApplication sharedApplication] openURL:[NSURL URLWithString:urlString]];                    }];       

 [alert addAction:action];    

}        

 //判断谷歌地图   

 if ( [[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@"comgooglemaps://"]])    {       

 UIAlertAction * action = [UIAlertAction actionWithTitle:@"谷歌地图" style:UIAlertActionStyleDefault handler:^(UIAlertAction *action) {                       

 NSString *urlString = [[NSString stringWithFormat:@"comgooglemaps://?x-source=%@&x-success=%@&saddr=&daddr=%f,%f&directionsmode=driving",appName,urlScheme,coordinate.latitude, coordinate.longitude] stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];                       
 [[UIApplication sharedApplication] openURL:[NSURL URLWithString:urlString]];          

}];                

[alert addAction:action];    

}        

UIAlertAction *action = [UIAlertAction actionWithTitle:@"取消" style:UIAlertActionStyleCancel handler:nil];    [alert addAction:action];        

[self presentViewController:alert animated:YES completion:^{          

}];    

}</pre>

]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h3&gt;&lt;p&gt; 一到公司报道那时，便着手独立的去完成了一个项目，其中的辛酸泪也是不足为外人道也。这次算是一个新型的app，仍然是独立开发，但心境和
    
    </summary>
    
    
      <category term="iOS" scheme="https:guohuaden.com/tags/iOS/"/>
    
  </entry>
  
</feed>
