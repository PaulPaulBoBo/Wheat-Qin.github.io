<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>喂、三二一</title>
  
  <subtitle>低调、踏实、前行。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://guohuaden.com/"/>
  <updated>2018-10-24T09:59:11.264Z</updated>
  <id>http://guohuaden.com/</id>
  
  <author>
    <name>Wheat</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>读 SDWebImage 五 （SDWebImageDownloaderOperation）</title>
    <link href="http://guohuaden.com/2018/10/24/Read-SDWebImage-SDWebImageDownloaderOperation/"/>
    <id>http://guohuaden.com/2018/10/24/Read-SDWebImage-SDWebImageDownloaderOperation/</id>
    <published>2018-10-24T09:58:01.000Z</published>
    <updated>2018-10-24T09:59:11.264Z</updated>
    
    <content type="html"><![CDATA[<p><code>SDWebImage</code> 的图片下载是由 <code>SDWebImageDownloader</code> 类实现的，该类是一个异步下载管理器。主要工作是下载相关配置项的管理，包括下载队列的先后顺序、最大下载任务数量控制、下载队列中的任务创建、取消、暂停等任务管理，以及其他的 <code>HTTPS</code> 和 <code>HTTP Header</code> 的设置。</p><p>而真正实现图片下载的是 <code>SDWebImageDownloaderOperation</code> 类。该类的 <code>Operation</code> 操作依赖系统提供的 <code>NSURLConnection</code> 类来实现图片的下载。在 <code>SDWebImageDownloader</code> 类中，将图片的下载操作封装成了自定义的一个类 <code>SDWebImageDownloaderOperation</code> ，然后添加到了操作队列中。当操作队列调用这个操作时，会调用操作对象的 <code>- (void)start</code> 方法，在重写的这个方法中，生成了任务对象<code>dataTask</code>，并调用<code>resume</code>开始执行任务。<br>因为S<code>DWebImageDownloaderOperation</code>类遵守了<code>dataTask</code>对象的协议，所以<code>dataTask</code>执行的结果会通过代理方法进行回调。在代理方法中，获取并保存了服务器返回的数据，并在任务执行结束后，对数据进行解码、缩放和解压。处理完成后就进行回调。</p><p><strong>梳理</strong>：<br> <code>SDWebImageDownloaderOperation</code>是一个自定义、并行的 <code>NSOperation</code> 子类。这个子类主要实现的功能有：<br>由于只自定义的并行 <code>NSOperation</code>,所以需要管理 <code>executing</code> , <code>finished</code> 等各种属性的处理，并且手动触发KVO。<br>在 <code>- (void)start</code> 方法里面实现主要逻辑，在重写的这个方法中生成了任务对象<code>dataTask</code>，并调用<code>resume</code>开始执行任务。<br>在 <code>NSURLSessionTaskDelegate</code> 和 <code>NSURLSessionDataDelegate</code> 中处理数据的加载，以及进度Block的处理。<br>如果 <code>unownedSession</code> 属性因为某种原因是nil，则手动初始化一个做网络请求。<br>在代理方法中对认证、数据拼装、完成回调Block做处理。<br>通过发送 <code>SDWebImageDownloadStopNotification,SDWebImageDownloadFinishNotification,SDWebImageDownloadReceiveResponseNotification, SDWebImageDownloadStartNotification来通知Operation</code> 的状态。</p><h3 id="h文件"><a href="#h文件" class="headerlink" title=".h文件"></a>.h文件</h3><p>四个通知，<code>SDWebImageDownloaderOperation</code> 在四种情况下会发送通知：</p><ol><li>开始下载</li><li>接收到数据</li><li>停止下载</li><li>结束下载</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * _Nonnull <span class="keyword">const</span> SDWebImageDownloadStartNotification;</span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * _Nonnull <span class="keyword">const</span> SDWebImageDownloadReceiveResponseNotification;</span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * _Nonnull <span class="keyword">const</span> SDWebImageDownloadStopNotification;</span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * _Nonnull <span class="keyword">const</span> SDWebImageDownloadFinishNotification;</span><br></pre></td></tr></table></figure><h3 id="SDWebImageDownloaderOperationInterface协议"><a href="#SDWebImageDownloaderOperationInterface协议" class="headerlink" title="SDWebImageDownloaderOperationInterface协议"></a><code>SDWebImageDownloaderOperationInterface</code>协议</h3><p>如果想要实现一个自定义的下载操作，就必须继承自 <code>NSOperation</code> ,同时实现 <code>SDWebImageDownloaderOperationInterface</code> 这个协议。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">SDWebImageDownloaderOperationInterface</span>&lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用NSURLRequest,NSURLSession和SDWebImageDownloaderOptions初始化</span></span><br><span class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)initWithRequest:(<span class="keyword">nullable</span> <span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                              inSession:(<span class="keyword">nullable</span> <span class="built_in">NSURLSession</span> *)session</span><br><span class="line">                                options:(SDWebImageDownloaderOptions)options;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以为每一个NSOperation自由的添加相应对象</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)addHandlersForProgress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                            completed:(<span class="keyword">nullable</span> SDWebImageDownloaderCompletedBlock)completedBlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否需要解压图片</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)shouldDecompressImages;</span><br><span class="line"><span class="comment">//设置是否需要解压图片</span></span><br><span class="line">- (<span class="keyword">void</span>)setShouldDecompressImages:(<span class="built_in">BOOL</span>)value;</span><br><span class="line"></span><br><span class="line"><span class="comment">//证书</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLCredential</span> *)credential;</span><br><span class="line"><span class="comment">//设置证书</span></span><br><span class="line">- (<span class="keyword">void</span>)setCredential:(<span class="keyword">nullable</span> <span class="built_in">NSURLCredential</span> *)value;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取消token</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)cancel:(<span class="keyword">nullable</span> <span class="keyword">id</span>)token;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="属性声明-和-方法"><a href="#属性声明-和-方法" class="headerlink" title="属性声明 和 方法"></a>属性声明 和 方法</h3><p><code>SDWebImageDownloaderOperation</code> 遵守 <code>SDWebImageDownloaderOperationInterface</code>, <code>SDWebImageOperation</code>, <code>NSURLSessionTaskDelegate</code>, <code>NSURLSessionDataDelegate</code> 等协议</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 操作任务使用的请求。（外部只读）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">NSURLRequest</span> *request;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 操作任务（外部只读）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">NSURLSessionTask</span> *dataTask;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//是否需要解压图片</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> shouldDecompressImages;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  用于确定URL连接是否应查询凭据存储以验证连接。</span></span><br><span class="line"><span class="comment"> *  @deprecated Not used for a couple of versions</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> shouldUseCredentialStorage __deprecated_msg(<span class="string">"Property deprecated. Does nothing. Kept only for backwards compatibility"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The credential used for authentication challenges 在 `-URLSession:task:didReceiveChallenge:completionHandler:`中用于身份验证挑战的凭证.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果存在请求URL的用户名或密码，则会覆盖此任何共享凭据。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="built_in">NSURLCredential</span> *credential;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SDWebImageDownloaderOptions选项 （外部只读）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) SDWebImageDownloaderOptions options;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 预期的数据大小。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSInteger</span> expectedSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 操作任务返回的响应。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">NSURLResponse</span> *response;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  I初始化`SDWebImageDownloaderOperation` 对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @see SDWebImageDownloaderOperation</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param request       URL请求</span></span><br><span class="line"><span class="comment"> *  @param session       将运行此操作的URL会话</span></span><br><span class="line"><span class="comment"> *  @param options       下载的选项</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return 初始化实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)initWithRequest:(<span class="keyword">nullable</span> <span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                              inSession:(<span class="keyword">nullable</span> <span class="built_in">NSURLSession</span> *)session</span><br><span class="line">                                options:(SDWebImageDownloaderOptions)options <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  添加处理程序以进行和完成。 返回可以传递给-cancel的tokent：取消这组回调。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param progressBlock  当新的数据块到达时执行的块。</span></span><br><span class="line"><span class="comment"> *                        @note 在后台队列上执行进度块</span></span><br><span class="line"><span class="comment"> *  @param completedBlock 当下载完成时执行的代码块</span></span><br><span class="line"><span class="comment"> *                        @note 已完成的代码块在主队列上执行以获得成功。如果发现错误，则代码块可能会在后台队列上执行</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return 用于取消这组处理程序的token</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)addHandlersForProgress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                            completed:(<span class="keyword">nullable</span> SDWebImageDownloaderCompletedBlock)completedBlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  取消一组回调. 一旦所有的回调被取消，该操作取消</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param token代表一组要取消的回调</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return 如果操作已停止，则为YES，因为这是要取消的最后一个token。 否则为NO。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)cancel:(<span class="keyword">nullable</span> <span class="keyword">id</span>)token;</span><br></pre></td></tr></table></figure><h3 id="m文件"><a href="#m文件" class="headerlink" title=".m文件"></a>.m文件</h3><p>信号量实现锁机制，这种锁性能要比NSLock高</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define LOCK(<span class="name">lock</span>) dispatch_semaphore_wait(<span class="name">lock</span>, DISPATCH_TIME_FOREVER)<span class="comment">;</span></span><br><span class="line">#define UNLOCK(<span class="name">lock</span>) dispatch_semaphore_signal(<span class="name">lock</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>静态全局变量</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开始下载的通知</span></span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> SDWebImageDownloadStartNotification = <span class="string">@"SDWebImageDownloadStartNotification"</span>;</span><br><span class="line"><span class="comment">//接受数据的通知</span></span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> SDWebImageDownloadReceiveResponseNotification = <span class="string">@"SDWebImageDownloadReceiveResponseNotification"</span>;</span><br><span class="line"><span class="comment">//停止下载的通知</span></span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> SDWebImageDownloadStopNotification = <span class="string">@"SDWebImageDownloadStopNotification"</span>;</span><br><span class="line"><span class="comment">//结束下载的通知</span></span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> SDWebImageDownloadFinishNotification = <span class="string">@"SDWebImageDownloadFinishNotification"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态全局变量作为下载进度block字典存储的key</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> kProgressCallbackKey = <span class="string">@"progress"</span>;</span><br><span class="line"><span class="comment">//静态全局变量作为结束下载block字典存储的key</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> kCompletedCallbackKey = <span class="string">@"completed"</span>;</span><br></pre></td></tr></table></figure><h4 id="属性声明"><a href="#属性声明" class="headerlink" title="属性声明"></a>属性声明</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//回调Block列表</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSMutableArray</span>&lt;SDCallbacksDictionary *&gt; *callbackBlocks;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义并行Operation需要管理的两个属性。默认是readonly的，我们这里通过声明改为可修改的。方便我们在后面操作。默认情况下_executing和finished都是NO</span></span><br><span class="line"><span class="comment">//是否正在执行</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>, <span class="keyword">getter</span> = isExecuting) <span class="built_in">BOOL</span> executing;</span><br><span class="line"><span class="comment">//是否结束</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>, <span class="keyword">getter</span> = isFinished) <span class="built_in">BOOL</span> finished;</span><br><span class="line"><span class="comment">//图片数据</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">NSMutableData</span> *imageData;</span><br><span class="line"><span class="comment">//缓存数据</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">NSData</span> *cachedData; <span class="comment">// for `SDWebImageDownloaderIgnoreCachedResponse`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过SDWebImageDownloader传过来。所以这里是weak。因为他是通过SDWebImageDownloader管理的。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">NSURLSession</span> *unownedSession;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果unownedSession是nil，我们需要手动创建一个并且管理他的生命周期和代理方法</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">NSURLSession</span> *ownedSession;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dataTask对象</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>, <span class="keyword">nullable</span>) <span class="built_in">NSURLSessionTask</span> *dataTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个锁，以保持对`callbackBlocks`线程安全的访问</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) dispatch_semaphore_t callbacksLock; <span class="comment">// a lock to keep the access to `callbackBlocks` thread-safe</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一个并行queue。用于控制数据的处理</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">dispatch_queue_t</span> coderQueue; <span class="comment">// the queue to do image decoding</span></span><br><span class="line"><span class="meta">#if SD_UIKIT</span></span><br><span class="line"><span class="comment">//如果用户设置了后台继续加载选线。则通过backgroundTask来继续下载图片</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">UIBackgroundTaskIdentifier</span> backgroundTaskId;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//图片解码器，有意思的是如果图片没有完全下载完成时也可以解码展示部分图片</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="keyword">id</span>&lt;SDWebImageProgressiveCoder&gt; progressiveCoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h4 id="方法实现"><a href="#方法实现" class="headerlink" title="方法实现"></a>方法实现</h4><p>编译器自动添加get和set方法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">synthesize</span> executing = _executing;</span><br><span class="line">@<span class="keyword">synthesize</span> finished = _finished;</span><br></pre></td></tr></table></figure><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithRequest:<span class="literal">nil</span> inSession:<span class="literal">nil</span> options:<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)initWithRequest:(<span class="keyword">nullable</span> <span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                              inSession:(<span class="keyword">nullable</span> <span class="built_in">NSURLSession</span> *)session</span><br><span class="line">                                options:(SDWebImageDownloaderOptions)options &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) &#123;</span><br><span class="line">        _request = [request <span class="keyword">copy</span>];</span><br><span class="line">        _shouldDecompressImages = <span class="literal">YES</span>;</span><br><span class="line">        _options = options;</span><br><span class="line">        _callbackBlocks = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">        <span class="comment">//默认情况下_executing和finished都是NO</span></span><br><span class="line">        _executing = <span class="literal">NO</span>;</span><br><span class="line">        _finished = <span class="literal">NO</span>;</span><br><span class="line">        _expectedSize = <span class="number">0</span>;</span><br><span class="line">        _unownedSession = session;</span><br><span class="line">        _callbacksLock = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">        _coderQueue = dispatch_queue_create(<span class="string">"com.hackemist.SDWebImageDownloaderOperationCoderQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给Operation添加进度和回调Block</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 给Operation添加进度和回调Block</span></span><br><span class="line"><span class="comment"> @param progressBlock 进度Block</span></span><br><span class="line"><span class="comment"> @param completedBlock 回调Block</span></span><br><span class="line"><span class="comment"> @return 回调字典</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)addHandlersForProgress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                            completed:(<span class="keyword">nullable</span> SDWebImageDownloaderCompletedBlock)completedBlock &#123;</span><br><span class="line">    <span class="comment">//初始化一个回调Block列表                      </span></span><br><span class="line">    SDCallbacksDictionary *callbacks = [<span class="built_in">NSMutableDictionary</span> new];</span><br><span class="line">    <span class="comment">//如果progressBlock 和 completedBlock 存在，就把Operation对应的回调和进度Block添加到回调Block列表中</span></span><br><span class="line">    <span class="keyword">if</span> (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock <span class="keyword">copy</span>];</span><br><span class="line">    <span class="keyword">if</span> (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock <span class="keyword">copy</span>];</span><br><span class="line">    LOCK(<span class="keyword">self</span>.callbacksLock);</span><br><span class="line">    [<span class="keyword">self</span>.callbackBlocks addObject:callbacks];</span><br><span class="line">    UNLOCK(<span class="keyword">self</span>.callbacksLock);</span><br><span class="line">    <span class="keyword">return</span> callbacks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过key获取回调列表组</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSArray</span>&lt;<span class="keyword">id</span>&gt; *)callbacksForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    LOCK(<span class="keyword">self</span>.callbacksLock);</span><br><span class="line">    <span class="built_in">NSMutableArray</span>&lt;<span class="keyword">id</span>&gt; *callbacks = [[<span class="keyword">self</span>.callbackBlocks valueForKey:key] mutableCopy];</span><br><span class="line">    UNLOCK(<span class="keyword">self</span>.callbacksLock);</span><br><span class="line">    <span class="comment">// 我们需要删除[NSNull null]，因为每个回调可能并不总是有进度Block</span></span><br><span class="line">    [callbacks removeObjectIdenticalTo:[<span class="built_in">NSNull</span> null]];</span><br><span class="line">    <span class="keyword">return</span> [callbacks <span class="keyword">copy</span>]; <span class="comment">// strip mutability here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过token判断是否需要取消Opration</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)cancel:(<span class="keyword">nullable</span> <span class="keyword">id</span>)token &#123;</span><br><span class="line">    <span class="built_in">BOOL</span> shouldCancel = <span class="literal">NO</span>;</span><br><span class="line">    LOCK(<span class="keyword">self</span>.callbacksLock);</span><br><span class="line">    <span class="comment">//通过token移除对象</span></span><br><span class="line">    [<span class="keyword">self</span>.callbackBlocks removeObjectIdenticalTo:token];</span><br><span class="line">    <span class="comment">//如果self.callbackBlocks的count为0，则shouldCancel = YES</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.callbackBlocks.count == <span class="number">0</span>) &#123;</span><br><span class="line">        shouldCancel = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    UNLOCK(<span class="keyword">self</span>.callbacksLock);</span><br><span class="line">    <span class="comment">//如果shouldCancel = YES，则执行取消操作</span></span><br><span class="line">    <span class="keyword">if</span> (shouldCancel) &#123;</span><br><span class="line">        [<span class="keyword">self</span> cancel];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shouldCancel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="下载、取消、复位、完成等操作"><a href="#下载、取消、复位、完成等操作" class="headerlink" title="下载、取消、复位、完成等操作"></a>下载、取消、复位、完成等操作</h5><p>并行的Operation需要重写这个方法，在这个方法里面做具体的处理</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)start &#123;</span><br><span class="line">    <span class="comment">//加同步锁</span></span><br><span class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">//如果已经被设置为取消状态，就直接重新复位：将Operation从回调Block列表中移除，dataTask设置为nil，并将NSURLSession注销并取消（invalidateAndCancel）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.isCancelled) &#123;</span><br><span class="line">            <span class="keyword">self</span>.finished = <span class="literal">YES</span>;</span><br><span class="line">            [<span class="keyword">self</span> reset];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#if SD_UIKIT</span></span><br><span class="line">        <span class="comment">//查看是否能获取到UIApplication类</span></span><br><span class="line">        Class <span class="built_in">UIApplicationClass</span> = <span class="built_in">NSClassFromString</span>(<span class="string">@"UIApplication"</span>);</span><br><span class="line">        <span class="built_in">BOOL</span> hasApplication = <span class="built_in">UIApplicationClass</span> &amp;&amp; [<span class="built_in">UIApplicationClass</span> respondsToSelector:<span class="keyword">@selector</span>(sharedApplication)];</span><br><span class="line">        <span class="comment">//如果有UIApplication类并设置了Background模式，则设置一个backgroundTask</span></span><br><span class="line">        <span class="keyword">if</span> (hasApplication &amp;&amp; [<span class="keyword">self</span> shouldContinueWhenAppEntersBackground]) &#123;</span><br><span class="line">        <span class="comment">//开始后台下载</span></span><br><span class="line">            __<span class="keyword">weak</span> __typeof__ (<span class="keyword">self</span>) wself = <span class="keyword">self</span>;</span><br><span class="line">            <span class="built_in">UIApplication</span> * app = [<span class="built_in">UIApplicationClass</span> performSelector:<span class="keyword">@selector</span>(sharedApplication)];</span><br><span class="line">            <span class="keyword">self</span>.backgroundTaskId = [app beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class="line">            <span class="comment">//后台下载任务结束，做清理工作（取消任务）</span></span><br><span class="line">                __<span class="keyword">strong</span> __<span class="keyword">typeof</span> (wself) sself = wself;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (sself) &#123;</span><br><span class="line">                    [sself cancel];</span><br><span class="line"></span><br><span class="line">                    [app endBackgroundTask:sself.backgroundTaskId];</span><br><span class="line">                    sself.backgroundTaskId = <span class="built_in">UIBackgroundTaskInvalid</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">        <span class="comment">//获取传入的网络会话对象</span></span><br><span class="line">        <span class="built_in">NSURLSession</span> *session = <span class="keyword">self</span>.unownedSession;</span><br><span class="line">        <span class="comment">//如果SDWebImageDownloader传入的session是nil，则手动初始化一个session对象</span></span><br><span class="line">        <span class="keyword">if</span> (!session) &#123;</span><br><span class="line">            <span class="built_in">NSURLSessionConfiguration</span> *sessionConfig = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line">            <span class="comment">//请求超时时间 15秒</span></span><br><span class="line">            sessionConfig.timeoutIntervalForRequest = <span class="number">15</span>;</span><br><span class="line">            session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:sessionConfig</span><br><span class="line">                                                    delegate:<span class="keyword">self</span></span><br><span class="line">                                               delegateQueue:<span class="literal">nil</span>];</span><br><span class="line">            <span class="keyword">self</span>.ownedSession = session;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果设置了忽略从NSURLCache中获取缓存的选项</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.options &amp; SDWebImageDownloaderIgnoreCachedResponse) &#123;</span><br><span class="line">            <span class="comment">// 获取缓存的数据以供日后检查，不存在就初始化一个URLCache对象</span></span><br><span class="line">            <span class="built_in">NSURLCache</span> *URLCache = session.configuration.URLCache;</span><br><span class="line">            <span class="keyword">if</span> (!URLCache) &#123;</span><br><span class="line">                URLCache = [<span class="built_in">NSURLCache</span> sharedURLCache];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">NSCachedURLResponse</span> *cachedResponse;</span><br><span class="line">            <span class="comment">// NSURLCache的 `cachedResponseForRequest:` 不是线程安全的，所以这里加了同步锁。 详情看（ https://developer.apple.com/documentation/foundation/nsurlcache#2317483）</span></span><br><span class="line">            <span class="keyword">@synchronized</span> (URLCache) &#123;</span><br><span class="line">                cachedResponse = [URLCache cachedResponseForRequest:<span class="keyword">self</span>.request];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cachedResponse) &#123;</span><br><span class="line">                <span class="keyword">self</span>.cachedData = cachedResponse.data;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//生成NSURLSessionTask类对象</span></span><br><span class="line">        <span class="keyword">self</span>.dataTask = [session dataTaskWithRequest:<span class="keyword">self</span>.request];</span><br><span class="line">        <span class="comment">//设置为正在执行状态</span></span><br><span class="line">        <span class="keyword">self</span>.executing = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果NSURLSessionTask类对象存在</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.dataTask) &#123;</span><br><span class="line"><span class="meta">#pragma clang diagnostic push</span></span><br><span class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Wunguarded-availability"</span></span></span><br><span class="line">        <span class="comment">//因为NSURLSessionTask的priority这个属性是iOS8.0以后才有的，所以要判断一下</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.dataTask respondsToSelector:<span class="keyword">@selector</span>(setPriority:)]) &#123;</span><br><span class="line">        <span class="comment">//根据设置的选项设置优先级</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.options &amp; SDWebImageDownloaderHighPriority) &#123;</span><br><span class="line">                <span class="keyword">self</span>.dataTask.priority = <span class="built_in">NSURLSessionTaskPriorityHigh</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">self</span>.options &amp; SDWebImageDownloaderLowPriority) &#123;</span><br><span class="line">                <span class="keyword">self</span>.dataTask.priority = <span class="built_in">NSURLSessionTaskPriorityLow</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#pragma clang diagnostic pop</span></span><br><span class="line">        <span class="comment">//发送请求，开始执行任务</span></span><br><span class="line">        [<span class="keyword">self</span>.dataTask resume];</span><br><span class="line">        <span class="comment">//获取到进度回调代码块并调用</span></span><br><span class="line">        <span class="keyword">for</span> (SDWebImageDownloaderProgressBlock progressBlock <span class="keyword">in</span> [<span class="keyword">self</span> callbacksForKey:kProgressCallbackKey]) &#123;</span><br><span class="line">            progressBlock(<span class="number">0</span>, <span class="built_in">NSURLResponseUnknownLength</span>, <span class="keyword">self</span>.request.URL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//异步主队列发送下载开始通知</span></span><br><span class="line">        __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadStartNotification object:weakSelf];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果没有获取到NSURLSessionTask类对象，就回调错误并返回</span></span><br><span class="line">        [<span class="keyword">self</span> callCompletionBlocksWithError:[<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:<span class="built_in">NSURLErrorUnknown</span> userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span> : <span class="string">@"Task can't be initialized"</span>&#125;]];</span><br><span class="line">        [<span class="keyword">self</span> done];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#if SD_UIKIT</span></span><br><span class="line">    <span class="comment">//如果是后台任务，就关闭后台任务</span></span><br><span class="line">    Class <span class="built_in">UIApplicationClass</span> = <span class="built_in">NSClassFromString</span>(<span class="string">@"UIApplication"</span>);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">UIApplicationClass</span> || ![<span class="built_in">UIApplicationClass</span> respondsToSelector:<span class="keyword">@selector</span>(sharedApplication)]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.backgroundTaskId != <span class="built_in">UIBackgroundTaskInvalid</span>) &#123;</span><br><span class="line">        <span class="built_in">UIApplication</span> * app = [<span class="built_in">UIApplication</span> performSelector:<span class="keyword">@selector</span>(sharedApplication)];</span><br><span class="line">        [app endBackgroundTask:<span class="keyword">self</span>.backgroundTaskId];</span><br><span class="line">        <span class="keyword">self</span>.backgroundTaskId = <span class="built_in">UIBackgroundTaskInvalid</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取消Operation操作。</span></span><br><span class="line">- (<span class="keyword">void</span>)cancel &#123;</span><br><span class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span> cancelInternal];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">- (<span class="keyword">void</span>)cancelInternal &#123;</span><br><span class="line">    <span class="comment">//如果已经结束，返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.isFinished) <span class="keyword">return</span>;</span><br><span class="line">    [<span class="keyword">super</span> cancel];</span><br><span class="line">    <span class="comment">//如果存在NSURLSessionTask类对象，就取消，并且异步主队列发送下载开始通知</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.dataTask) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.dataTask cancel];</span><br><span class="line">        __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadStopNotification object:weakSelf];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// As we cancelled the task, its callback won't be called and thus won't</span></span><br><span class="line">        <span class="comment">// maintain the isFinished and isExecuting flags.</span></span><br><span class="line">        <span class="comment">//更新执行状态和结束状态</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.isExecuting) <span class="keyword">self</span>.executing = <span class="literal">NO</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>.isFinished) <span class="keyword">self</span>.finished = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//复位</span></span><br><span class="line">    [<span class="keyword">self</span> reset];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//完成Operation操作</span></span><br><span class="line">- (<span class="keyword">void</span>)done &#123;</span><br><span class="line">    <span class="comment">//更新执行状态和结束状态</span></span><br><span class="line">    <span class="keyword">self</span>.finished = <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">self</span>.executing = <span class="literal">NO</span>;</span><br><span class="line">     <span class="comment">//复位</span></span><br><span class="line">    [<span class="keyword">self</span> reset];</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//复位</span></span><br><span class="line">- (<span class="keyword">void</span>)reset &#123;</span><br><span class="line">    <span class="comment">//删除回调block列表中所有的对象</span></span><br><span class="line">    LOCK(<span class="keyword">self</span>.callbacksLock);</span><br><span class="line">    [<span class="keyword">self</span>.callbackBlocks removeAllObjects];</span><br><span class="line">    UNLOCK(<span class="keyword">self</span>.callbacksLock);</span><br><span class="line">    <span class="comment">//NSURLSessionTask类对象置为nil</span></span><br><span class="line">    <span class="keyword">self</span>.dataTask = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注销网络会话对象</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.ownedSession) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.ownedSession invalidateAndCancel];</span><br><span class="line">        <span class="keyword">self</span>.ownedSession = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置结束状态</span></span><br><span class="line">- (<span class="keyword">void</span>)setFinished:(<span class="built_in">BOOL</span>)finished &#123;</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"isFinished"</span>];</span><br><span class="line">    _finished = finished;</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"isFinished"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置执行状态</span></span><br><span class="line">- (<span class="keyword">void</span>)setExecuting:(<span class="built_in">BOOL</span>)executing &#123;</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"isExecuting"</span>];</span><br><span class="line">    _executing = executing;</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"isExecuting"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断Operation是否是并发</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isConcurrent &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="NSURLSessionDataDelegate"><a href="#NSURLSessionDataDelegate" class="headerlink" title="NSURLSessionDataDelegate"></a>NSURLSessionDataDelegate</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//收到服务端响应，再一次请求中只会执行一次</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">          dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line"> completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionResponseDisposition</span> disposition))completionHandler &#123;</span><br><span class="line">    <span class="built_in">NSURLSessionResponseDisposition</span> disposition = <span class="built_in">NSURLSessionResponseAllow</span>;</span><br><span class="line">    <span class="comment">//获取要下载图片的长度</span></span><br><span class="line">    <span class="built_in">NSInteger</span> expected = (<span class="built_in">NSInteger</span>)response.expectedContentLength;</span><br><span class="line">    expected = expected &gt; <span class="number">0</span> ? expected : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//设置当前expectedSize</span></span><br><span class="line">    <span class="keyword">self</span>.expectedSize = expected;</span><br><span class="line">    <span class="comment">//设置当前response</span></span><br><span class="line">    <span class="keyword">self</span>.response = response;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据状态代码判断氢气的状态</span></span><br><span class="line">    <span class="built_in">NSInteger</span> statusCode = [response respondsToSelector:<span class="keyword">@selector</span>(statusCode)] ? ((<span class="built_in">NSHTTPURLResponse</span> *)response).statusCode : <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">BOOL</span> valid = statusCode &lt; <span class="number">400</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//'304 Not Modified'是一个特殊的。 如果没有缓存数据，则应将其视为已取消。</span></span><br><span class="line">    <span class="comment">//当服务器响应304并且URLCache命中时，URLSession当前行为将返回200状态代码。 但这不是标准行为，我们只是添加一个检查</span></span><br><span class="line">    <span class="keyword">if</span> (statusCode == <span class="number">304</span> &amp;&amp; !<span class="keyword">self</span>.cachedData) &#123;</span><br><span class="line">        valid = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果状态代码是有效的</span></span><br><span class="line">    <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">        <span class="comment">//遍历进度回调块并触发进度block回调</span></span><br><span class="line">        <span class="keyword">for</span> (SDWebImageDownloaderProgressBlock progressBlock <span class="keyword">in</span> [<span class="keyword">self</span> callbacksForKey:kProgressCallbackKey]) &#123;</span><br><span class="line">            progressBlock(<span class="number">0</span>, expected, <span class="keyword">self</span>.request.URL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 状态代码无效并标记为已取消。 不要调用`[self.dataTask cancel]` which may mass up URLSession life cycle</span></span><br><span class="line">        disposition = <span class="built_in">NSURLSessionResponseCancel</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//异步主队列发送接受数据通知</span></span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadReceiveResponseNotification object:weakSelf];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//表示允许继续加载</span></span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每次收到数据都会触发， 可能多次调用</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask didReceiveData:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//向可变数据中添加接收到的数据</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.imageData) &#123;</span><br><span class="line">        <span class="keyword">self</span>.imageData = [[<span class="built_in">NSMutableData</span> alloc] initWithCapacity:<span class="keyword">self</span>.expectedSize];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.imageData appendData:data];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果设置了SDWebImageDownloaderProgressiveDownload选项下载（即展示已经下载的部分,并expectedSize返回的图片size大于0）</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span>.options &amp; SDWebImageDownloaderProgressiveDownload) &amp;&amp; <span class="keyword">self</span>.expectedSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 获得图片数据</span></span><br><span class="line">        __block <span class="built_in">NSData</span> *imageData = [<span class="keyword">self</span>.imageData <span class="keyword">copy</span>];</span><br><span class="line">        <span class="comment">// 获得下载的总字节数</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">NSInteger</span> totalSize = imageData.length;</span><br><span class="line">        <span class="comment">// 获得结束的状态</span></span><br><span class="line">        <span class="built_in">BOOL</span> finished = (totalSize &gt;= <span class="keyword">self</span>.expectedSize);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果图片解码器不存在</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>.progressiveCoder) &#123;</span><br><span class="line">            <span class="comment">// 因为增量解码需要保留解码后的上下文，我们将为每个下载操作分配一个具有相同类的新实例，以避免冲突</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">id</span>&lt;SDWebImageCoder&gt;coder <span class="keyword">in</span> [SDWebImageCodersManager sharedInstance].coders) &#123;</span><br><span class="line">                <span class="keyword">if</span> ([coder conformsToProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">SDWebImageProgressiveCoder</span>)] &amp;&amp;</span></span><br><span class="line">                    [((<span class="keyword">id</span>&lt;SDWebImageProgressiveCoder&gt;)coder) canIncrementallyDecodeFromData:imageData]) &#123;</span><br><span class="line">                    <span class="keyword">self</span>.progressiveCoder = [[[coder <span class="keyword">class</span>] alloc] init];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 逐步解码编码器队列中的图像，自定义串行队列异步执行</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.coderQueue, ^&#123;</span><br><span class="line">           <span class="comment">//解码生成图片（增量解码图像数据到图像）</span></span><br><span class="line">            <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span>.progressiveCoder incrementallyDecodedImageWithData:imageData finished:finished];</span><br><span class="line">             <span class="comment">//如果图片存在，通过URL获取key，再对image进行缩放操作</span></span><br><span class="line">            <span class="keyword">if</span> (image) &#123;</span><br><span class="line">                <span class="built_in">NSString</span> *key = [[SDWebImageManager sharedManager] cacheKeyForURL:<span class="keyword">self</span>.request.URL];</span><br><span class="line">                <span class="comment">//image进行缩放操作</span></span><br><span class="line">                image = [<span class="keyword">self</span> scaledImageForKey:key image:image];</span><br><span class="line">                <span class="comment">//如果需要压缩图片，就执行压缩操作</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.shouldDecompressImages) &#123;</span><br><span class="line">                    image = [[SDWebImageCodersManager sharedInstance] decompressedImageWithImage:image data:&amp;imageData options:@&#123;SDWebImageCoderScaleDownLargeImagesKey: @(<span class="literal">NO</span>)&#125;];</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//当`finished`=YES时，不再保留逐行解码图片。 因为它们用于视图渲染但不从下载器选项中获取全部功能。 并且一些编码器实现可能在逐行解码和正常解码之间不一致。</span></span><br><span class="line">                <span class="comment">//进行完成回调</span></span><br><span class="line">                [<span class="keyword">self</span> callCompletionBlocksWithImage:image imageData:<span class="literal">nil</span> error:<span class="literal">nil</span> finished:<span class="literal">NO</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回调进度</span></span><br><span class="line">    <span class="keyword">for</span> (SDWebImageDownloaderProgressBlock progressBlock <span class="keyword">in</span> [<span class="keyword">self</span> callbacksForKey:kProgressCallbackKey]) &#123;</span><br><span class="line">        progressBlock(<span class="keyword">self</span>.imageData.length, <span class="keyword">self</span>.expectedSize, <span class="keyword">self</span>.request.URL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当NSURLSessionDataTask弯成接受所有预期数据后会调用这个代理方法，询问代理对象是否将响应存储在缓存中</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">          dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line"> willCacheResponse:(<span class="built_in">NSCachedURLResponse</span> *)proposedResponse</span><br><span class="line"> completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSCachedURLResponse</span> *cachedResponse))completionHandler &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取缓存响应</span></span><br><span class="line">    <span class="built_in">NSCachedURLResponse</span> *cachedResponse = proposedResponse;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果设置了缓存选项（SDWebImageDownloaderUseNSURLCache），就回调缓存响应，否则就回调nil，不缓存</span></span><br><span class="line">    <span class="keyword">if</span> (!(<span class="keyword">self</span>.options &amp; SDWebImageDownloaderUseNSURLCache)) &#123;</span><br><span class="line">        <span class="comment">// Prevents caching of responses</span></span><br><span class="line">        cachedResponse = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用完成代码块并传参</span></span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        completionHandler(cachedResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="NSURLSessionTaskDelegate-代理实现"><a href="#NSURLSessionTaskDelegate-代理实现" class="headerlink" title="NSURLSessionTaskDelegate 代理实现"></a>NSURLSessionTaskDelegate 代理实现</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当NSURLSessionTask已经完成传输数据时会调用这个代理方法</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session task:(<span class="built_in">NSURLSessionTask</span> *)task didCompleteWithError:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line">    <span class="comment">//同步锁</span></span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">//将保存任务对象的属性置为nil</span></span><br><span class="line">        <span class="keyword">self</span>.dataTask = <span class="literal">nil</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//主队列异步发送下载停止通知，如果没有错误，发送下载结束通知</span></span><br><span class="line">        __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadStopNotification object:weakSelf];</span><br><span class="line">            <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">                [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadFinishNotification object:weakSelf];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果出错就回调错误，并调用完成方法</span></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        [<span class="keyword">self</span> callCompletionBlocksWithError:error];</span><br><span class="line">        [<span class="keyword">self</span> done];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果有完成回调的代码块</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> callbacksForKey:kCompletedCallbackKey].count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 如果您指定使用`NSURLCache`，那么您在此处获得的响应就是您所需要的。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">             <span class="comment">//如果有下载的imageData</span></span><br><span class="line">            __block <span class="built_in">NSData</span> *imageData = [<span class="keyword">self</span>.imageData <span class="keyword">copy</span>];</span><br><span class="line">            <span class="keyword">if</span> (imageData) &#123;</span><br><span class="line">                <span class="comment">/**  if you specified to only use cached data via `SDWebImageDownloaderIgnoreCachedResponse`,</span></span><br><span class="line"><span class="comment">                 *  then we should check if the cached data is equal to image data</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                 如果设置了忽略缓存响应选项（SDWebImageDownloaderIgnoreCachedResponse），并且缓存数据和下载的图片数据相同</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.options &amp; SDWebImageDownloaderIgnoreCachedResponse &amp;&amp; [<span class="keyword">self</span>.cachedData isEqualToData:imageData]) &#123;</span><br><span class="line">                    <span class="comment">//回调完成block nil，并调用完成方法</span></span><br><span class="line">                    [<span class="keyword">self</span> callCompletionBlocksWithImage:<span class="literal">nil</span> imageData:<span class="literal">nil</span> error:<span class="literal">nil</span> finished:<span class="literal">YES</span>];</span><br><span class="line">                    [<span class="keyword">self</span> done];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 在自定义串行异步执行</span></span><br><span class="line">                    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.coderQueue, ^&#123;</span><br><span class="line">                      <span class="comment">//对下载图片数据进行解码，通过imageData获取图片</span></span><br><span class="line">                        <span class="built_in">UIImage</span> *image = [[SDWebImageCodersManager sharedInstance] decodedImageWithData:imageData];</span><br><span class="line">                        <span class="comment">//获取图片url对应的key</span></span><br><span class="line">                        <span class="built_in">NSString</span> *key = [[SDWebImageManager sharedManager] cacheKeyForURL:<span class="keyword">self</span>.request.URL];</span><br><span class="line">                        <span class="comment">//图片缩放操作</span></span><br><span class="line">                        image = [<span class="keyword">self</span> scaledImageForKey:key image:image];</span><br><span class="line">                        <span class="comment">//生成变量图片是否应该解码，</span></span><br><span class="line">                        <span class="built_in">BOOL</span> shouldDecode = <span class="literal">YES</span>;</span><br><span class="line">                        <span class="comment">// 如果是gif动态图片（图片组）就不需要解码</span></span><br><span class="line">                        <span class="keyword">if</span> (image.images) &#123;</span><br><span class="line">                            shouldDecode = <span class="literal">NO</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#ifdef SD_WEBP              </span></span><br><span class="line">                            <span class="comment">//如果是webp个事的也不需要解码</span></span><br><span class="line">                            SDImageFormat imageFormat = [<span class="built_in">NSData</span> sd_imageFormatForImageData:imageData];</span><br><span class="line">                            <span class="keyword">if</span> (imageFormat == SDImageFormatWebP) &#123;</span><br><span class="line">                                shouldDecode = <span class="literal">NO</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//如果需要解码，执行解码操作</span></span><br><span class="line">                        <span class="keyword">if</span> (shouldDecode) &#123;</span><br><span class="line">                            <span class="comment">//是否需要解压图片，需要就执行解压操作</span></span><br><span class="line">                            <span class="keyword">if</span> (<span class="keyword">self</span>.shouldDecompressImages) &#123;</span><br><span class="line">                                <span class="comment">//是否需要缩小图片</span></span><br><span class="line">                                <span class="built_in">BOOL</span> shouldScaleDown = <span class="keyword">self</span>.options &amp; SDWebImageDownloaderScaleDownLargeImages;</span><br><span class="line">                                <span class="comment">//解压操作</span></span><br><span class="line">                                image = [[SDWebImageCodersManager sharedInstance] decompressedImageWithImage:image data:&amp;imageData options:@&#123;SDWebImageCoderScaleDownLargeImagesKey: @(shouldScaleDown)&#125;];</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//获取处理好的图片尺寸</span></span><br><span class="line">                        <span class="built_in">CGSize</span> imageSize = image.size;</span><br><span class="line">                        <span class="comment">//如果图片的宽或者长为0，就回调错误，否则回调完成block</span></span><br><span class="line">                        <span class="keyword">if</span> (imageSize.width == <span class="number">0</span> || imageSize.height == <span class="number">0</span>) &#123;</span><br><span class="line">                            [<span class="keyword">self</span> callCompletionBlocksWithError:[<span class="built_in">NSError</span> errorWithDomain:SDWebImageErrorDomain code:<span class="number">0</span> userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span> : <span class="string">@"Downloaded image has 0 pixels"</span>&#125;]];</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">//回调完成</span></span><br><span class="line">                            [<span class="keyword">self</span> callCompletionBlocksWithImage:image imageData:imageData error:<span class="literal">nil</span> finished:<span class="literal">YES</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//调用完成方法</span></span><br><span class="line">                        [<span class="keyword">self</span> done];</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果没有下载的图片数据，就回调错误，并执行完成方法</span></span><br><span class="line">                [<span class="keyword">self</span> callCompletionBlocksWithError:[<span class="built_in">NSError</span> errorWithDomain:SDWebImageErrorDomain code:<span class="number">0</span> userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span> : <span class="string">@"Image data is nil"</span>&#125;]];</span><br><span class="line">                [<span class="keyword">self</span> done];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果没有完成回调代码块，直接执行完成方法</span></span><br><span class="line">            [<span class="keyword">self</span> done];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当task接受到身份验证时，会回调这个代理方法</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session task:(<span class="built_in">NSURLSessionTask</span> *)task didReceiveChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition, <span class="built_in">NSURLCredential</span> *credential))completionHandler &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置临时变量保存数据</span></span><br><span class="line">    <span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</span><br><span class="line">    __block <span class="built_in">NSURLCredential</span> *credential = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//若验证方式为NSURLAuthenticationMethodServerTrust</span></span><br><span class="line">    <span class="keyword">if</span> ([challenge.protectionSpace.authenticationMethod isEqualToString:<span class="built_in">NSURLAuthenticationMethodServerTrust</span>]) &#123;</span><br><span class="line">        <span class="comment">//如果没有设置允许不可信的SSL证书，就设置蓄力方式为默认的NSURLSessionAuthChallengePerformDefaultHandling，否则就设置验证模式为指定证书验证，并生成证书</span></span><br><span class="line">        <span class="keyword">if</span> (!(<span class="keyword">self</span>.options &amp; SDWebImageDownloaderAllowInvalidSSLCertificates)) &#123;</span><br><span class="line">            disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            credential = [<span class="built_in">NSURLCredential</span> credentialForTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">            disposition = <span class="built_in">NSURLSessionAuthChallengeUseCredential</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//若验证方式不是NSURLAuthenticationMethodServerTrust</span></span><br><span class="line">        <span class="keyword">if</span> (challenge.previousFailureCount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//判断是否有证书，如果有就设置证书，验证模式为通过指定证书验证，否则就设置验证模式为不需要验证证书</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.credential) &#123;</span><br><span class="line">                credential = <span class="keyword">self</span>.credential;</span><br><span class="line">                disposition = <span class="built_in">NSURLSessionAuthChallengeUseCredential</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                disposition = <span class="built_in">NSURLSessionAuthChallengeCancelAuthenticationChallenge</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果认证的失败次数设置超过0次，就设置验证模式为不需要验证证书</span></span><br><span class="line">            disposition = <span class="built_in">NSURLSessionAuthChallengeCancelAuthenticationChallenge</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用完成代码并传参</span></span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition, credential);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Helper-methods"><a href="#Helper-methods" class="headerlink" title="Helper methods"></a>Helper methods</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//缩放操作</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)scaledImageForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key image:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image &#123;</span><br><span class="line">    <span class="keyword">return</span> SDScaledImageForKey(key, image);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否允许app后台继续下载图片</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)shouldContinueWhenAppEntersBackground &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.options &amp; SDWebImageDownloaderContinueInBackground;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误完成回调方法</span></span><br><span class="line">- (<span class="keyword">void</span>)callCompletionBlocksWithError:(<span class="keyword">nullable</span> <span class="built_in">NSError</span> *)error &#123;</span><br><span class="line">    [<span class="keyword">self</span> callCompletionBlocksWithImage:<span class="literal">nil</span> imageData:<span class="literal">nil</span> error:error finished:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//完成回调方法</span></span><br><span class="line">- (<span class="keyword">void</span>)callCompletionBlocksWithImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image</span><br><span class="line">                            imageData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)imageData</span><br><span class="line">                                error:(<span class="keyword">nullable</span> <span class="built_in">NSError</span> *)error</span><br><span class="line">                             finished:(<span class="built_in">BOOL</span>)finished &#123;</span><br><span class="line">    <span class="built_in">NSArray</span>&lt;<span class="keyword">id</span>&gt; *completionBlocks = [<span class="keyword">self</span> callbacksForKey:kCompletedCallbackKey];</span><br><span class="line">    dispatch_main_async_safe(^&#123;</span><br><span class="line">        <span class="keyword">for</span> (SDWebImageDownloaderCompletedBlock completedBlock <span class="keyword">in</span> completionBlocks) &#123;</span><br><span class="line">            completedBlock(image, imageData, error, finished);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;SDWebImage&lt;/code&gt; 的图片下载是由 &lt;code&gt;SDWebImageDownloader&lt;/code&gt; 类实现的，该类是一个异步下载管理器。主要工作是下载相关配置项的管理，包括下载队列的先后顺序、最大下载任务数量控制、下载队列中的任务创建、取消、
      
    
    </summary>
    
      <category term="iOS" scheme="http://guohuaden.com/categories/iOS/"/>
    
    
      <category term="SDWebImage" scheme="http://guohuaden.com/tags/SDWebImage/"/>
    
  </entry>
  
  <entry>
    <title>读 SDWebImage 四 (SDWebImageDownloader)</title>
    <link href="http://guohuaden.com/2018/10/04/Read-SDWebImage-SDWebImageDownloader/"/>
    <id>http://guohuaden.com/2018/10/04/Read-SDWebImage-SDWebImageDownloader/</id>
    <published>2018-10-04T11:38:50.000Z</published>
    <updated>2018-10-24T09:55:22.786Z</updated>
    
    <content type="html"><![CDATA[<p><code>SDWebImage</code> 的图片下载是由 <code>SDWebImageDownloader</code> 这个类实现的，该类是一个异步下载管理器。主要工作是下载相关配置项的管理，包括下载队列的先后顺序、最大下载任务数量控制、下载队列中的任务创建、取消、暂停等任务管理，以及其他的 <code>HTTPS</code> 和 <code>HTTP Header</code> 的设置。而真正实现图片下载的是 <code>SDWebImageDownloaderOperation</code>类。该类的 <code>Operation</code> 操作依赖系统提供的NSURLConnection类来实现图片的下载。</p><h3 id="下载选项"><a href="#下载选项" class="headerlink" title="下载选项"></a>下载选项</h3><p>枚举列出不同的下载选项 （选项使用掩码形式，如 <code>1 &lt;&lt; 2</code> 表示将1左移2位，即：00000010，也就是2。）<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, SDWebImageDownloaderOptions) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认模式，将下载放入低优先级队列 和 低优先级任务中</span></span><br><span class="line">    SDWebImageDownloaderLowPriority = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该选项启用渐进式下载，图像在下载过程中逐步显示，就像浏览器一样。（该选项在返回进度Block的同时也返回completedBlock，里面的UIImage就是当前下载时的图片，可以实现将图片一点点显示出来的功能）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SDWebImageDownloaderProgressiveDownload = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认情况下，http请求会阻止使用NSURLCache。 使用此标志，NSURLCache将与默认策略一起使用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SDWebImageDownloaderUseNSURLCache = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果从NSURLCache缓存中读取图片，则使用nil作为image/imageData的参数来调用block代码块。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SDWebImageDownloaderIgnoreCachedResponse = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在iOS 4+ 系统中，允许程序进入后台后继续下载图片，该操作通过向系统申请额外的时间来完成后台下载请求，如果后台任务终止，则操作被取消。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SDWebImageDownloaderContinueInBackground = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过设置NSMutableURLRequest，HTTPShouldHandleCookies =  YES来处理存储在NSHTTPCookieStore中的cookie;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SDWebImageDownloaderHandleCookies = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *允许允许不受信任的SSL证书。用于测试目的。 在生产中谨慎使用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SDWebImageDownloaderAllowInvalidSSLCertificates = <span class="number">1</span> &lt;&lt; <span class="number">6</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将下载放入高队列优先级和高任务优先级中。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SDWebImageDownloaderHighPriority = <span class="number">1</span> &lt;&lt; <span class="number">7</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缩小图像（默认情况下，图片会按照它的原始大小来解码显示。这个属性会根据设备的内存限制调整图片的尺寸到合适的大小。如果`SDWebImageProgressiveDownload`标记被设置了，则这个flag不起作用。）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SDWebImageDownloaderScaleDownLargeImages = <span class="number">1</span> &lt;&lt; <span class="number">8</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="下载操作的执行顺序"><a href="#下载操作的执行顺序" class="headerlink" title="下载操作的执行顺序"></a>下载操作的执行顺序</h3><p>两种执行顺序： 先进先出 和 后进先出<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="type">NS_ENUM</span>(<span class="type">NSInteger</span>, <span class="type">SDWebImageDownloaderExecutionOrder</span>) &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 默认值。 所有下载操作都将以队列样式执行（先进先出）。</span><br><span class="line">     */</span><br><span class="line">    <span class="type">SDWebImageDownloaderFIFOExecutionOrder</span>,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 所有下载操作都将以栈的方式执行（后进先出）。</span><br><span class="line">     */</span><br><span class="line">    <span class="type">SDWebImageDownloaderLIFOExecutionOrder</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="外部定义的系统通知标示"><a href="#外部定义的系统通知标示" class="headerlink" title="外部定义的系统通知标示"></a>外部定义的系统通知标示</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开始下载通知</span></span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * _Nonnull <span class="keyword">const</span> SDWebImageDownloadStartNotification;</span><br><span class="line"><span class="comment">//停止下载通知</span></span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * _Nonnull <span class="keyword">const</span> SDWebImageDownloadStopNotification;</span><br></pre></td></tr></table></figure><h3 id="两个代码块"><a href="#两个代码块" class="headerlink" title="两个代码块"></a>两个代码块</h3><p>每个下载操作的下载进度回调和下载完成回调，这两个回调稍后将保存在下载管理器的URLCallbacks字典中，key为URL，value为一个数组，数组里面又存放一个保存了下载进度回调和完成回调代码块的字典。<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//下载进度代码块</span><br><span class="line">typedef void(^<span class="type">SDWebImageDownloaderProgressBlock</span>)(<span class="type">NSInteger</span> receivedSize, <span class="type">NSInteger</span> expectedSize, <span class="type">NSURL</span> * _Nullable targetURL);</span><br><span class="line">//下载完成回调代码块</span><br><span class="line">typedef void(^<span class="type">SDWebImageDownloaderCompletedBlock</span>)(<span class="type">UIImage</span> * _Nullable image, <span class="type">NSData</span> * _Nullable data, <span class="type">NSError</span> * _Nullable error, <span class="type">BOOL</span> finished);</span><br></pre></td></tr></table></figure></p><h3 id="三个字典"><a href="#三个字典" class="headerlink" title="三个字典"></a>三个字典</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求头字典</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="built_in">NSString</span> *&gt; SDHTTPHeadersDictionary;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSMutableDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="built_in">NSString</span> *&gt; SDHTTPHeadersMutableDictionary;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义请求头，通过Block传值，可以拿到一些参数，然后加工成我们需要的数据，最后返回</span></span><br><span class="line"><span class="keyword">typedef</span> SDHTTPHeadersDictionary * _Nullable (^SDWebImageDownloaderHeadersFilterBlock)(<span class="built_in">NSURL</span> * _Nullable url, SDHTTPHeadersDictionary * _Nullable headers);</span><br></pre></td></tr></table></figure><h3 id="SDWebImageDownloadToken"><a href="#SDWebImageDownloadToken" class="headerlink" title="SDWebImageDownloadToken"></a>SDWebImageDownloadToken</h3><p>作为下载操作的唯一标识，在创建 <code>operation</code> 的时候初始化绑定，当需要去 <code>cancel</code> 操作的时候就需要这个 <code>token</code>。<br><code>SDWebImageDownloadToken</code> 为每一个下载任务的唯一身份标识，<code>SDWebImageDownloader</code> 和我们平时开发中的下载有一些不同，它弱化了下载过程，比较强调的是下载结果，不支持断点下载。</p><h4 id="h文件"><a href="#h文件" class="headerlink" title=".h文件"></a>.h文件</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">SDWebImageDownloadToken </span>: NSObject &lt;SDWebImageOperation&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">下载的URL。 这应该是只读的，你不应该修改</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="variable">@property</span> (nonatomic, strong, nullable) NSURL *url;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 取消token 可以从 “id downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock]” 方法获得，这应该是只读的，你不应该修改。</span></span><br><span class="line"><span class="comment"> @note 使用 `-[SDWebImageDownloadToken cancel]`方法去取消下载token</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="variable">@property</span> (nonatomic, strong, nullable) id downloadOperationCancelToken;</span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure><h4 id="m文件"><a href="#m文件" class="headerlink" title=".m文件"></a>.m文件</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SDWebImageDownloadToken</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下载操作</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>, <span class="keyword">nullable</span>) <span class="built_in">NSOperation</span>&lt;SDWebImageDownloaderOperationInterface&gt; *downloadOperation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SDWebImageDownloadToken</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//取消下载</span></span><br><span class="line">- (<span class="keyword">void</span>)cancel &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.downloadOperation) &#123;</span><br><span class="line">        SDWebImageDownloadToken *cancelToken = <span class="keyword">self</span>.downloadOperationCancelToken;</span><br><span class="line">        <span class="keyword">if</span> (cancelToken) &#123;</span><br><span class="line">            [<span class="keyword">self</span>.downloadOperation cancel:cancelToken];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h2 id="SDWebImageDownloader-h文件"><a href="#SDWebImageDownloader-h文件" class="headerlink" title="SDWebImageDownloader.h文件"></a>SDWebImageDownloader.h文件</h2><h3 id="属性声明"><a href="#属性声明" class="headerlink" title="属性声明"></a>属性声明</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解压缩下载和缓存的图像可以提高性能，但会占用大量内存。</span></span><br><span class="line"><span class="comment"> * 默认是YES. 如果由于过多的内存消耗而遇到崩溃，可以设置为NO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//当图片下载完成以后，解码图片。如果因为过多的内存消耗导致一个奔溃，可以把这个属性设置为NO</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> shouldDecompressImages;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最大兵法下载数目</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSInteger</span> maxConcurrentDownloads;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 显示仍需要下载的当前下载量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> currentDownloadCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  下载操作的超时值（秒为单位），默认15秒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSTimeInterval</span> downloadTimeout;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内部NSURLSession使用的配置</span></span><br><span class="line"><span class="comment"> * 直接变换此对象无效</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @see createNewSessionWithConfiguration:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSURLSessionConfiguration</span> *sessionConfiguration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 改变下载操作的执行顺序 默认值是 `SDWebImageDownloaderFIFOExecutionOrder`.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) SDWebImageDownloaderExecutionOrder executionOrder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  设置要为请求操作设置的默认URL凭据。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">NSURLCredential</span> *urlCredential;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置用户名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">NSString</span> *username;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置密码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">NSString</span> *password;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置过滤器以选择用于下载图像HTTP请求的标头</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 将为每个下载图像请求调用此块，返回的NSDictionary将用作相应HTTP请求中的标头。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//http头部的过滤函数</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) SDWebImageDownloaderHeadersFilterBlock headersFilter;</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下载管理器单例函数</span></span><br><span class="line">+ (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)sharedDownloader;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用指定的会话配置创建下载程序的实例。（初始化方法）</span></span><br><span class="line"><span class="comment"> * @note `timeoutIntervalForRequest` 将被覆盖</span></span><br><span class="line"><span class="comment"> * @return 下载器的新事例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)initWithSessionConfiguration:(<span class="keyword">nullable</span> <span class="built_in">NSURLSessionConfiguration</span> *)sessionConfiguration <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置要附加到每个下载HTTP请求的HTTP标头的值。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param value The value for the header field. 值为 `nil` 移除请求头文件.</span></span><br><span class="line"><span class="comment"> * @param field 设置http请求头部字段.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)value forHTTPHeaderField:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)field;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回指定的HTTP标头字段的值。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return 与标题字段字段关联的值，如果没有相应的标题字段，则为“nil”。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)valueForHTTPHeaderField:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)field;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 将`SDWebImageDownloaderOperation`的子类设置为默认值</span></span><br><span class="line"><span class="comment">  * 每次SDWebImage构造请求时都要使用`NSOperation`</span></span><br><span class="line"><span class="comment">  * 下载图像的操作。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * @param operationClass要设置的`SDWebImageDownloaderOperation`的子类</span></span><br><span class="line"><span class="comment">  *默认。 传递`nil`将恢复为`SDWebImageDownloaderOperation`。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">- (<span class="keyword">void</span>)setOperationClass:(<span class="keyword">nullable</span> Class)operationClass;</span><br><span class="line"></span><br><span class="line">/ **</span><br><span class="line">  * 使用给定的URL创建SDWebImageDownloader异步下载器实例</span><br><span class="line">  *</span><br><span class="line">  * 图像完成下载或发生错误时将通知代理。</span><br><span class="line">  *</span><br><span class="line">  * @see SDWebImageDownloaderDelegate</span><br><span class="line">  *</span><br><span class="line">  * @param url要下载的图像的URL</span><br><span class="line">  * @param options用于此下载的选项</span><br><span class="line">  * @param progressBlock在下载图像时重复调用的块</span><br><span class="line">  * @note在后台队列上执行进度块</span><br><span class="line">  * @param completedBlock下载完成后调用的块。</span><br><span class="line">  * 如果下载成功，则设置image参数，如果出错，</span><br><span class="line">  * 错误参数设置为错误。最后一个参数始终为<span class="literal">YES</span></span><br><span class="line">  * 如果没有使用SDWebImageDownloaderProgressiveDownload。随着</span><br><span class="line">  * SDWebImageDownloaderProgressiveDownload选项，调用此块</span><br><span class="line">  * 重复使用部分图像对象，并将完成的参数设置为<span class="literal">NO</span></span><br><span class="line">  * 之前用完整的图像和完成的参数调用最后一次</span><br><span class="line">  * 设为是。如果出错，则完成的参数始终为<span class="literal">YES</span>。</span><br><span class="line">  *</span><br><span class="line">  * @return可以传递给-cancel的令牌（SDWebImageDownloadToken）：取消此操作</span><br><span class="line">  * /</span><br><span class="line">- (<span class="keyword">nullable</span> SDWebImageDownloadToken *)downloadImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">                                                   options:(SDWebImageDownloaderOptions)options</span><br><span class="line">                                                  progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                                 completed:(<span class="keyword">nullable</span> SDWebImageDownloaderCompletedBlock)completedBlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取消之前使用排队的下载 获取token使用 “-downloadImageWithURL:options:progress:completed:”方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param token 从“-downloadImageWithURL:options:progress:completed:”方法获取的token应该被取消</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)cancel:(<span class="keyword">nullable</span> SDWebImageDownloadToken *)token;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置下载队列挂起状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)setSuspended:(<span class="built_in">BOOL</span>)suspended;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取消队列中的所有下载操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)cancelAllDownloads;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 强制SDWebImageDownloader 创建和使用一个给定配置的初始化NSURLSession（队列中的所有现有下载操作都将被取消；请求超时的时间也被重写）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param sessionConfiguration 使用新的NSURLSession配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)createNewSessionWithConfiguration:(<span class="keyword">nonnull</span> <span class="built_in">NSURLSessionConfiguration</span> *)sessionConfiguration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * //取消operation并且session设置为Invalidates （如果您使用自定义下载程序而不是共享下载程序，则在不使用它时避免内存泄漏时需要调用此方法）</span></span><br><span class="line"><span class="comment"> * @param cancelPendingOperations 是否取消挂起的操作。</span></span><br><span class="line"><span class="comment"> * @note 在共享下载程序上调用此方法无效。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)invalidateSessionAndCancel:(<span class="built_in">BOOL</span>)cancelPendingOperations;</span><br></pre></td></tr></table></figure><h2 id="SDWebImageDownloader-m文件"><a href="#SDWebImageDownloader-m文件" class="headerlink" title="SDWebImageDownloader.m文件"></a>SDWebImageDownloader.m文件</h2><h3 id="属性声明-1"><a href="#属性声明-1" class="headerlink" title="属性声明"></a>属性声明</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SDWebImageDownloader</span> () &lt;<span class="title">NSURLSessionTaskDelegate</span>, <span class="title">NSURLSessionDataDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下载队列</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSOperationQueue</span> *downloadQueue;</span><br><span class="line"><span class="comment">//最新添加的操作</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">NSOperation</span> *lastAddedOperation;</span><br><span class="line"><span class="comment">//操作的类</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) Class operationClass;</span><br><span class="line"><span class="comment">//下载操作的集合</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSMutableDictionary</span>&lt;<span class="built_in">NSURL</span> *, SDWebImageDownloaderOperation *&gt; *URLOperations;</span><br><span class="line"><span class="comment">//HTTP头文件集合</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) SDHTTPHeadersMutableDictionary *HTTPHeaders;</span><br><span class="line"><span class="comment">//操作锁</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) dispatch_semaphore_t operationsLock; <span class="comment">// a lock to keep the access to `URLOperations` thread-safe</span></span><br><span class="line"><span class="comment">//头文件锁</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) dispatch_semaphore_t headersLock; <span class="comment">// a lock to keep the access to `HTTPHeaders` thread-safe</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The session in which data tasks will run</span></span><br><span class="line"><span class="comment">//NSURLSession</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSURLSession</span> *session;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h4 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h4><p><code>SDWebImageDownloader</code> 提供了一个initialize方法 四个初始化方法和一个注销方法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)initialize &#123;</span><br><span class="line">    <span class="comment">//绑定SDNetworkActivityIndicator（如果可用），如果使用它，需要导入"SDNetworkActivityIndicator.h"头文件</span></span><br><span class="line">    <span class="comment">//主要是用来加载图片的时候，状态栏会转小菊花。（该方法是为了给图片下载绑定一个SDNetworkActivityIndicator，只有当这个SDNetworkActivityIndicator文件存在的情况下才会执行，目的就是当下载图片时，状态栏会转小菊花。）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NSClassFromString</span>(<span class="string">@"SDNetworkActivityIndicator"</span>)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//LLVM 3.0 编译器可以用以下代码消除 warning </span></span><br><span class="line"><span class="meta">#pragma clang diagnostic push</span></span><br><span class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Warc-performSelector-leaks"</span></span></span><br><span class="line">        <span class="keyword">id</span> activityIndicator = [<span class="built_in">NSClassFromString</span>(<span class="string">@"SDNetworkActivityIndicator"</span>) performSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"sharedActivityIndicator"</span>)];</span><br><span class="line"><span class="meta">#pragma clang diagnostic pop</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果之前已经添加，先移除观察者</span></span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:activityIndicator name:SDWebImageDownloadStartNotification object:<span class="literal">nil</span>];</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:activityIndicator name:SDWebImageDownloadStopNotification object:<span class="literal">nil</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//添加观察者</span></span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:activityIndicator</span><br><span class="line">                                                 selector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"startActivity"</span>)</span><br><span class="line">                                                     name:SDWebImageDownloadStartNotification object:<span class="literal">nil</span>];</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:activityIndicator</span><br><span class="line">                                                 selector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"stopActivity"</span>)</span><br><span class="line">                                                     name:SDWebImageDownloadStopNotification object:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单例，返回SDWebImageDownloader对象</span></span><br><span class="line">+ (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)sharedDownloader &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> once;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">id</span> instance;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;once, ^&#123;</span><br><span class="line">        instance = [<span class="keyword">self</span> new];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithSessionConfiguration:[<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个请求对象</span></span><br><span class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)initWithSessionConfiguration:(<span class="keyword">nullable</span> <span class="built_in">NSURLSessionConfiguration</span> *)sessionConfiguration &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) &#123;</span><br><span class="line">        _operationClass = [SDWebImageDownloaderOperation <span class="keyword">class</span>];</span><br><span class="line">        _shouldDecompressImages = <span class="literal">YES</span>;</span><br><span class="line">        _executionOrder = SDWebImageDownloaderFIFOExecutionOrder;</span><br><span class="line">        _downloadQueue = [<span class="built_in">NSOperationQueue</span> new];</span><br><span class="line">        _downloadQueue.maxConcurrentOperationCount = <span class="number">6</span>;</span><br><span class="line">        _downloadQueue.name = <span class="string">@"com.hackemist.SDWebImageDownloader"</span>;</span><br><span class="line">        _URLOperations = [<span class="built_in">NSMutableDictionary</span> new];</span><br><span class="line"><span class="meta">#ifdef SD_WEBP</span></span><br><span class="line">        _HTTPHeaders = [@&#123;<span class="string">@"Accept"</span>: <span class="string">@"image/webp,image/*;q=0.8"</span>&#125; mutableCopy];</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">        _HTTPHeaders = [@&#123;<span class="string">@"Accept"</span>: <span class="string">@"image/*;q=0.8"</span>&#125; mutableCopy];</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">        _operationsLock = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">        _headersLock = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">        _downloadTimeout = <span class="number">15.0</span>;</span><br><span class="line"></span><br><span class="line">        [<span class="keyword">self</span> createNewSessionWithConfiguration:sessionConfiguration];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个新的请求对象</span></span><br><span class="line">- (<span class="keyword">void</span>)createNewSessionWithConfiguration:(<span class="built_in">NSURLSessionConfiguration</span> *)sessionConfiguration &#123;</span><br><span class="line">    [<span class="keyword">self</span> cancelAllDownloads];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.session) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.session invalidateAndCancel];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sessionConfiguration.timeoutIntervalForRequest = <span class="keyword">self</span>.downloadTimeout;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Create the session for this task</span></span><br><span class="line"><span class="comment">     *  We send nil as delegate queue so that the session creates a serial operation queue for performing all delegate</span></span><br><span class="line"><span class="comment">     *  method calls and completion handler calls.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">self</span>.session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:sessionConfiguration</span><br><span class="line">                                                 delegate:<span class="keyword">self</span></span><br><span class="line">                                            delegateQueue:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///取消operation并且session设置为Invalidates</span></span><br><span class="line">- (<span class="keyword">void</span>)invalidateSessionAndCancel:(<span class="built_in">BOOL</span>)cancelPendingOperations &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> == [SDWebImageDownloader sharedDownloader]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cancelPendingOperations) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.session invalidateAndCancel];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span>.session finishTasksAndInvalidate];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    [<span class="keyword">self</span>.session invalidateAndCancel];</span><br><span class="line">    <span class="keyword">self</span>.session = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.downloadQueue cancelAllOperations];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Set-和-Get-方法"><a href="#Set-和-Get-方法" class="headerlink" title="Set 和 Get 方法"></a><code>Set</code> 和 <code>Get</code> 方法</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置请求报文头部</span></span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)value forHTTPHeaderField:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)field &#123;</span><br><span class="line">    LOCK(<span class="keyword">self</span>.headersLock);</span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">        <span class="keyword">self</span>.HTTPHeaders[field] = value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span>.HTTPHeaders removeObjectForKey:field];</span><br><span class="line">    &#125;</span><br><span class="line">    UNLOCK(<span class="keyword">self</span>.headersLock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取请求报文头部</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)valueForHTTPHeaderField:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)field &#123;</span><br><span class="line">    <span class="keyword">if</span> (!field) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> allHTTPHeaderFields] objectForKey:field];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全部的请求报文头部</span></span><br><span class="line">- (<span class="keyword">nonnull</span> SDHTTPHeadersDictionary *)allHTTPHeaderFields &#123;</span><br><span class="line">    LOCK(<span class="keyword">self</span>.headersLock);</span><br><span class="line">    SDHTTPHeadersDictionary *allHTTPHeaderFields = [<span class="keyword">self</span>.HTTPHeaders <span class="keyword">copy</span>];</span><br><span class="line">    UNLOCK(<span class="keyword">self</span>.headersLock);</span><br><span class="line">    <span class="keyword">return</span> allHTTPHeaderFields;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置下载队列的最大并发数</span></span><br><span class="line">- (<span class="keyword">void</span>)setMaxConcurrentDownloads:(<span class="built_in">NSInteger</span>)maxConcurrentDownloads &#123;</span><br><span class="line">    _downloadQueue.maxConcurrentOperationCount = maxConcurrentDownloads;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取下载队列的当前operation数</span></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)currentDownloadCount &#123;</span><br><span class="line">    <span class="keyword">return</span> _downloadQueue.operationCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取下载队列的最大并发数</span></span><br><span class="line">- (<span class="built_in">NSInteger</span>)maxConcurrentDownloads &#123;</span><br><span class="line">    <span class="keyword">return</span> _downloadQueue.maxConcurrentOperationCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSURLSessionConfiguration</span> *)sessionConfiguration &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.session.configuration;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置一个`SDWebImageDownloaderOperation`的子类作为`NSOperation`来构建request来下载一张图片</span></span><br><span class="line">- (<span class="keyword">void</span>)setOperationClass:(<span class="keyword">nullable</span> Class)operationClass &#123;</span><br><span class="line">    <span class="keyword">if</span> (operationClass &amp;&amp; [operationClass isSubclassOfClass:[<span class="built_in">NSOperation</span> <span class="keyword">class</span>]] &amp;&amp; [operationClass conformsToProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">SDWebImageDownloaderOperationInterface</span>)]) </span>&#123;</span><br><span class="line">        _operationClass = operationClass;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _operationClass = [SDWebImageDownloaderOperation <span class="keyword">class</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="下载方法"><a href="#下载方法" class="headerlink" title="下载方法"></a>下载方法</h4><p>下载管理器的主要实现为 <code>downloadImageWithURL:options:progress:completed:</code> 方法(调用该方法创建 <code>operation</code> 操作)，这个方法调用 <code>- (void)addProgressCallback:completedBlock:forURL: createCallback:</code> 方法来将请求的信息和一些回调函数存入管理器中，同时在创建回调的 <code>block</code> 中创建新 <code>operation</code> 操作,新的操作由管理器中存储的信息配置后，放入到 <code>downloadQueue</code> 操作队列中，最后返回新创建的操作<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 下载图片</span></span><br><span class="line"><span class="comment"> @param url 图片url</span></span><br><span class="line"><span class="comment"> @param options 下载选项</span></span><br><span class="line"><span class="comment"> @param progressBlock 下载进度blockhui</span></span><br><span class="line"><span class="comment"> @param completedBlock 下载完成block</span></span><br><span class="line"><span class="comment"> @return  返回一个SDWebImageDownloadToken，用于关联一个请求</span></span><br><span class="line"><span class="comment">    调用addProgressCallback方法 return token，addProgressCallback的回调里进行以下操作</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        1.1设置下载时间</span></span><br><span class="line"><span class="comment">        1.2创建request</span></span><br><span class="line"><span class="comment">        1.3创建operation对象 传入 request session options</span></span><br><span class="line"><span class="comment">        1.4设置身份认证</span></span><br><span class="line"><span class="comment">        1.5设置下载优先级</span></span><br><span class="line"><span class="comment">        1.6设置下载顺序</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nullable</span> SDWebImageDownloadToken *)downloadImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">                                                   options:(SDWebImageDownloaderOptions)options</span><br><span class="line">                                                  progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                                 completed:(<span class="keyword">nullable</span> SDWebImageDownloaderCompletedBlock)completedBlock &#123;</span><br><span class="line">    __<span class="keyword">weak</span> SDWebImageDownloader *wself = <span class="keyword">self</span>;</span><br><span class="line">    <span class="comment">// 调用- (void)addProgressCallback:completedBlock:forURL: createCallback:方法来将请求的信息和一些回调函数存入管理器中，同时在创建回调的block中创建新operation操作,新的操作由管理器中存储的信息配置后，放入到downloadQueue操作队列中，最后返回新创建的操作</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^SDWebImageDownloaderOperation *&#123;</span><br><span class="line">        __<span class="keyword">strong</span> __<span class="keyword">typeof</span> (wself) sself = wself;</span><br><span class="line">        <span class="comment">//获取超时时间，如果没有设置，默认为15秒</span></span><br><span class="line">        <span class="built_in">NSTimeInterval</span> timeoutInterval = sself.downloadTimeout;</span><br><span class="line">        <span class="keyword">if</span> (timeoutInterval == <span class="number">0.0</span>) &#123;</span><br><span class="line">            timeoutInterval = <span class="number">15.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为了防止潜在的重复缓存（NSURLCache 和 SDImageCache同时缓存），如果另有说明，我们会禁用图像请求的缓存</span></span><br><span class="line">        <span class="built_in">NSURLRequestCachePolicy</span> cachePolicy = options &amp; SDWebImageDownloaderUseNSURLCache ? <span class="built_in">NSURLRequestUseProtocolCachePolicy</span> : <span class="built_in">NSURLRequestReloadIgnoringLocalCacheData</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建请求对象，并根据options参数设置其属性</span></span><br><span class="line">        <span class="built_in">NSMutableURLRequest</span> *request = [[<span class="built_in">NSMutableURLRequest</span> alloc] initWithURL:url</span><br><span class="line">                                                                    cachePolicy:cachePolicy</span><br><span class="line">                                                                timeoutInterval:timeoutInterval];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用cookies</span></span><br><span class="line">        request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies);</span><br><span class="line">        <span class="comment">//使用管道</span></span><br><span class="line">        request.HTTPShouldUsePipelining = <span class="literal">YES</span>;</span><br><span class="line">        <span class="comment">//添加自定义请求头</span></span><br><span class="line">        <span class="keyword">if</span> (sself.headersFilter) &#123;</span><br><span class="line">            request.allHTTPHeaderFields = sself.headersFilter(url, [sself allHTTPHeaderFields]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            request.allHTTPHeaderFields = [sself allHTTPHeaderFields];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化一个自定义NSOperation对象</span></span><br><span class="line">        SDWebImageDownloaderOperation *operation = [[sself.operationClass alloc] initWithRequest:request inSession:sself.session options:options];</span><br><span class="line">        <span class="comment">//当图片下载完成以后，解码图片。如果因为过多的内存消耗导致一个奔溃，可以把这个属性设置为NO</span></span><br><span class="line">        operation.shouldDecompressImages = sself.shouldDecompressImages;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//指定验证信息（url证书）</span></span><br><span class="line">        <span class="keyword">if</span> (sself.urlCredential) &#123;</span><br><span class="line">            operation.credential = sself.urlCredential;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sself.username &amp;&amp; sself.password) &#123;</span><br><span class="line">            <span class="comment">//基础验证</span></span><br><span class="line">            operation.credential = [<span class="built_in">NSURLCredential</span> credentialWithUser:sself.username password:sself.password persistence:<span class="built_in">NSURLCredentialPersistenceForSession</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//指定优先级</span></span><br><span class="line">        <span class="keyword">if</span> (options &amp; SDWebImageDownloaderHighPriority) &#123;</span><br><span class="line">            operation.queuePriority = <span class="built_in">NSOperationQueuePriorityHigh</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options &amp; SDWebImageDownloaderLowPriority) &#123;</span><br><span class="line">            operation.queuePriority = <span class="built_in">NSOperationQueuePriorityLow</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//指定下载顺序（ 如果是LIFO这种模式，则需要手动指定operation之间的依赖关系）</span></span><br><span class="line">        <span class="keyword">if</span> (sself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</span><br><span class="line">            <span class="comment">// 如果是LIFO，则让前面的operation依赖于最新添加的operation</span></span><br><span class="line">            [sself.lastAddedOperation addDependency:operation];</span><br><span class="line">            sself.lastAddedOperation = operation;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> operation;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取消一个图片的下载操作</span></span><br><span class="line">- (<span class="keyword">void</span>)cancel:(<span class="keyword">nullable</span> SDWebImageDownloadToken *)token &#123;</span><br><span class="line">    <span class="comment">//如果url不存在，则返回</span></span><br><span class="line">    <span class="built_in">NSURL</span> *url = token.url;</span><br><span class="line">    <span class="keyword">if</span> (!url) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取该操作，通过token来确定操作是否取消（移除），如果取消，则在URLOperations中移除url</span></span><br><span class="line">    LOCK(<span class="keyword">self</span>.operationsLock);</span><br><span class="line">    SDWebImageDownloaderOperation *operation = [<span class="keyword">self</span>.URLOperations objectForKey:url];</span><br><span class="line">    <span class="keyword">if</span> (operation) &#123;</span><br><span class="line">        <span class="built_in">BOOL</span> canceled = [operation cancel:token.downloadOperationCancelToken];</span><br><span class="line">        <span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">            [<span class="keyword">self</span>.URLOperations removeObjectForKey:url];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    UNLOCK(<span class="keyword">self</span>.operationsLock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给下载过程添加进度</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    1.生成URLOperations字典 下载url作为key value是具体的下载operation</span></span><br><span class="line"><span class="comment">    2.将操作添加到操作队列中</span></span><br><span class="line"><span class="comment">    3.将进度progressBlock和下载结束completedBlock封装成字典SDCallbacksDictionary，装入数组callbackBlocks，</span></span><br><span class="line"><span class="comment">    4.生成token标识，并返回token</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">nullable</span> SDWebImageDownloadToken *)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                           completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock</span><br><span class="line">                                                   forURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">                                           createCallback:(SDWebImageDownloaderOperation *(^)(<span class="keyword">void</span>))createCallback &#123;</span><br><span class="line">    <span class="comment">// url作为回调字典里的key，因此url不能为空，如果url为空则立即调用已完成代码块（image、imageData都传nil），并直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (url == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (completedBlock != <span class="literal">nil</span>) &#123;</span><br><span class="line">            completedBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">NO</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LOCK(<span class="keyword">self</span>.operationsLock);</span><br><span class="line">    获取url下载的操作</span><br><span class="line">    SDWebImageDownloaderOperation *operation = [<span class="keyword">self</span>.URLOperations objectForKey:url];</span><br><span class="line">    <span class="comment">// 有一种情况是操作可能被标记为已完成，但未从“self.URLOperations”中删除。</span></span><br><span class="line">    <span class="keyword">if</span> (!operation || operation.isFinished) &#123;</span><br><span class="line">    <span class="comment">//创建一个operation，并且添加到URLOperation中</span></span><br><span class="line">        operation = createCallback();</span><br><span class="line">        __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) wself = <span class="keyword">self</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//设置operation操作完成以后的回调</span></span><br><span class="line">        operation.completionBlock = ^&#123;</span><br><span class="line">            __<span class="keyword">strong</span> <span class="keyword">typeof</span>(wself) sself = wself;</span><br><span class="line">            <span class="keyword">if</span> (!sself) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            LOCK(sself.operationsLock);</span><br><span class="line">            <span class="comment">//完成以后从URLOperations中移除该URL的operation操作</span></span><br><span class="line">            [sself.URLOperations removeObjectForKey:url];</span><br><span class="line">            UNLOCK(sself.operationsLock);</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将该url的operation操作添加到URLOperations中</span></span><br><span class="line">        [<span class="keyword">self</span>.URLOperations setObject:operation forKey:url];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//仅在根据Apple的doc完成所有配置后才将操作添加到操作队列。`addOperation：`不同步执行`operation.completionBlock`，所以这不会导致死锁。</span></span><br><span class="line">        <span class="comment">//把operation添加进入NSOperationQueue中，当operation添加到downloadQueue，会触发相应的start方法，开始下载。</span></span><br><span class="line">        [<span class="keyword">self</span>.downloadQueue addOperation:operation];</span><br><span class="line">    &#125;</span><br><span class="line">    UNLOCK(<span class="keyword">self</span>.operationsLock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取downloadOperationCancelToken</span></span><br><span class="line">    <span class="keyword">id</span> downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建一个新的token，给各属性赋值，并返回token</span></span><br><span class="line">    SDWebImageDownloadToken *token = [SDWebImageDownloadToken new];</span><br><span class="line">    token.downloadOperation = operation;</span><br><span class="line">    token.url = url;</span><br><span class="line">    token.downloadOperationCancelToken = downloadOperationCancelToken;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> token;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置下载队列全部暂停/开始</span></span><br><span class="line">- (<span class="keyword">void</span>)setSuspended:(<span class="built_in">BOOL</span>)suspended &#123;</span><br><span class="line">    <span class="keyword">self</span>.downloadQueue.suspended = suspended;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全部取消下载队列中的下载操作</span></span><br><span class="line">- (<span class="keyword">void</span>)cancelAllDownloads &#123;</span><br><span class="line">    [<span class="keyword">self</span>.downloadQueue cancelAllOperations];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark Helper methods</span></span><br><span class="line"><span class="comment">//根据task获取下载操作operation</span></span><br><span class="line">- (SDWebImageDownloaderOperation *)operationWithTask:(<span class="built_in">NSURLSessionTask</span> *)task &#123;</span><br><span class="line">    SDWebImageDownloaderOperation *returnOperation = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">for</span> (SDWebImageDownloaderOperation *operation <span class="keyword">in</span> <span class="keyword">self</span>.downloadQueue.operations) &#123;</span><br><span class="line">        <span class="keyword">if</span> (operation.dataTask.taskIdentifier == task.taskIdentifier) &#123;</span><br><span class="line">            returnOperation = operation;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> returnOperation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="NSURLSessionDataDelegate"><a href="#NSURLSessionDataDelegate" class="headerlink" title="NSURLSessionDataDelegate"></a>NSURLSessionDataDelegate</h4><p>当收到数据的时候，会触发这些代理方法，最后调用SDWebImageDownloaderOperation中的代理方法，来实际处理事情。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="string">URLSession:</span>(NSURLSession *)session</span><br><span class="line"><span class="symbol">          dataTask:</span>(NSURLSessionDataTask *)dataTask</span><br><span class="line"><span class="string">didReceiveResponse:</span>(NSURLResponse *)response</span><br><span class="line"><span class="symbol"> completionHandler:</span>(<span class="keyword">void</span> (^)(NSURLSessionResponseDisposition disposition))completionHandler &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Identify the operation that runs this task and pass it the delegate method</span></span><br><span class="line">    SDWebImageDownloaderOperation *dataOperation = [self <span class="string">operationWithTask:</span>dataTask];</span><br><span class="line">    <span class="keyword">if</span> ([dataOperation <span class="string">respondsToSelector:</span><span class="meta">@selector</span>(<span class="string">URLSession:</span><span class="string">dataTask:</span><span class="string">didReceiveResponse:</span><span class="string">completionHandler:</span>)]) &#123;</span><br><span class="line">        [dataOperation <span class="string">URLSession:</span>session <span class="string">dataTask:</span>dataTask <span class="string">didReceiveResponse:</span>response <span class="string">completionHandler:</span>completionHandler];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">            completionHandler(NSURLSessionResponseAllow);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">URLSession:</span>(NSURLSession *)session <span class="string">dataTask:</span>(NSURLSessionDataTask *)dataTask <span class="string">didReceiveData:</span>(NSData *)data &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Identify the operation that runs this task and pass it the delegate method</span></span><br><span class="line">    SDWebImageDownloaderOperation *dataOperation = [self <span class="string">operationWithTask:</span>dataTask];</span><br><span class="line">    <span class="keyword">if</span> ([dataOperation <span class="string">respondsToSelector:</span><span class="meta">@selector</span>(<span class="string">URLSession:</span><span class="string">dataTask:</span><span class="string">didReceiveData:</span>)]) &#123;</span><br><span class="line">        [dataOperation <span class="string">URLSession:</span>session <span class="string">dataTask:</span>dataTask <span class="string">didReceiveData:</span>data];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">URLSession:</span>(NSURLSession *)session</span><br><span class="line"><span class="symbol">          dataTask:</span>(NSURLSessionDataTask *)dataTask</span><br><span class="line"><span class="symbol"> willCacheResponse:</span>(NSCachedURLResponse *)proposedResponse</span><br><span class="line"><span class="symbol"> completionHandler:</span>(<span class="keyword">void</span> (^)(NSCachedURLResponse *cachedResponse))completionHandler &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Identify the operation that runs this task and pass it the delegate method</span></span><br><span class="line">    SDWebImageDownloaderOperation *dataOperation = [self <span class="string">operationWithTask:</span>dataTask];</span><br><span class="line">    <span class="keyword">if</span> ([dataOperation <span class="string">respondsToSelector:</span><span class="meta">@selector</span>(<span class="string">URLSession:</span><span class="string">dataTask:</span><span class="string">willCacheResponse:</span><span class="string">completionHandler:</span>)]) &#123;</span><br><span class="line">        [dataOperation <span class="string">URLSession:</span>session <span class="string">dataTask:</span>dataTask <span class="string">willCacheResponse:</span>proposedResponse <span class="string">completionHandler:</span>completionHandler];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">            completionHandler(proposedResponse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="NSURLSessionTaskDelegate"><a href="#NSURLSessionTaskDelegate" class="headerlink" title="NSURLSessionTaskDelegate"></a>NSURLSessionTaskDelegate</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="string">URLSession:</span>(NSURLSession *)session <span class="string">task:</span>(NSURLSessionTask *)task <span class="string">didCompleteWithError:</span>(NSError *)error &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Identify the operation that runs this task and pass it the delegate method</span></span><br><span class="line">    SDWebImageDownloaderOperation *dataOperation = [self <span class="string">operationWithTask:</span>task];</span><br><span class="line">    <span class="keyword">if</span> ([dataOperation <span class="string">respondsToSelector:</span><span class="meta">@selector</span>(<span class="string">URLSession:</span><span class="string">task:</span><span class="string">didCompleteWithError:</span>)]) &#123;</span><br><span class="line">        [dataOperation <span class="string">URLSession:</span>session <span class="string">task:</span>task <span class="string">didCompleteWithError:</span>error];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">URLSession:</span>(NSURLSession *)session <span class="string">task:</span>(NSURLSessionTask *)task <span class="string">willPerformHTTPRedirection:</span>(NSHTTPURLResponse *)response <span class="string">newRequest:</span>(NSURLRequest *)request <span class="string">completionHandler:</span>(<span class="keyword">void</span> (^)(NSURLRequest * _Nullable))completionHandler &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Identify the operation that runs this task and pass it the delegate method</span></span><br><span class="line">    SDWebImageDownloaderOperation *dataOperation = [self <span class="string">operationWithTask:</span>task];</span><br><span class="line">    <span class="keyword">if</span> ([dataOperation <span class="string">respondsToSelector:</span><span class="meta">@selector</span>(<span class="string">URLSession:</span><span class="string">task:</span><span class="string">willPerformHTTPRedirection:</span><span class="string">newRequest:</span><span class="string">completionHandler:</span>)]) &#123;</span><br><span class="line">        [dataOperation <span class="string">URLSession:</span>session <span class="string">task:</span>task <span class="string">willPerformHTTPRedirection:</span>response <span class="string">newRequest:</span>request <span class="string">completionHandler:</span>completionHandler];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">            completionHandler(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">URLSession:</span>(NSURLSession *)session <span class="string">task:</span>(NSURLSessionTask *)task <span class="string">didReceiveChallenge:</span>(NSURLAuthenticationChallenge *)challenge <span class="string">completionHandler:</span>(<span class="keyword">void</span> (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Identify the operation that runs this task and pass it the delegate method</span></span><br><span class="line">    SDWebImageDownloaderOperation *dataOperation = [self <span class="string">operationWithTask:</span>task];</span><br><span class="line">    <span class="keyword">if</span> ([dataOperation <span class="string">respondsToSelector:</span><span class="meta">@selector</span>(<span class="string">URLSession:</span><span class="string">task:</span><span class="string">didReceiveChallenge:</span><span class="string">completionHandler:</span>)]) &#123;</span><br><span class="line">        [dataOperation <span class="string">URLSession:</span>session <span class="string">task:</span>task <span class="string">didReceiveChallenge:</span>challenge <span class="string">completionHandler:</span>completionHandler];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">            completionHandler(NSURLSessionAuthChallengePerformDefaultHandling, nil);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;SDWebImage&lt;/code&gt; 的图片下载是由 &lt;code&gt;SDWebImageDownloader&lt;/code&gt; 这个类实现的，该类是一个异步下载管理器。主要工作是下载相关配置项的管理，包括下载队列的先后顺序、最大下载任务数量控制、下载队列中的任务创建、取
      
    
    </summary>
    
      <category term="iOS" scheme="http://guohuaden.com/categories/iOS/"/>
    
    
      <category term="SDWebImage" scheme="http://guohuaden.com/tags/SDWebImage/"/>
    
  </entry>
  
  <entry>
    <title>读 SDWebImage 三 (SDImageCache)</title>
    <link href="http://guohuaden.com/2018/10/02/Read-SDWebImage-SDImageCache/"/>
    <id>http://guohuaden.com/2018/10/02/Read-SDWebImage-SDImageCache/</id>
    <published>2018-10-02T02:38:36.000Z</published>
    <updated>2018-10-24T09:55:07.611Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h3><p><code>SDImageCache</code> 是 <code>SDWebImage</code> 处理图片缓存的类。图片的存储是针对内存和磁盘有一点区别：内存中直接存储图片，磁盘中存中 <code>imagedata</code><br>在 <code>SDWebImageManager</code> 中使用的存储图片、判断图片是否已存储在磁盘/内存等方法均是调用该类中的方法。<code>SDWebImage</code> 设计时做了很好的分工，以至于去分析代码都带有一种享受感。</p><blockquote><p>简单做个思考，如果自己实现一个缓存类，需要做哪些东西：<br>1、初始化、缓存地址。<br>3、查询、删除、存储方法（增删改查功能）<br>4、计算缓存大小<br>5、计算缓存数量…</p></blockquote><p>然后在接下来的分析中看看跟自己的思路的偏差：</p><p>在 <code>SDImageCache</code> 的 <code>.h</code> 文件中引用了 <code>SDWebImageCompat</code> 和 <code>SDImageCacheConfig</code> 头文件。<code>SDWebImageCompat</code> 类在 <code>SDWebImageManager</code> 结尾已经分析过，该类只包含一个方法，用来实现图片缩放的操作。</p><p><code>SDImageCacheConfig</code> 类则是管理缓存配置信息的，这里先单独拉出来看下</p><h3 id="2、SDImageCacheConfig-类"><a href="#2、SDImageCacheConfig-类" class="headerlink" title="2、SDImageCacheConfig 类"></a>2、<code>SDImageCacheConfig</code> 类</h3><p><code>SDImageCacheConfig</code> 类是用于配置缓存信息的，继承自 <code>NSObject</code>。</p><h4 id="2-1、-h文件"><a href="#2-1、-h文件" class="headerlink" title="2.1、.h文件"></a>2.1、.h文件</h4><p>缓存配置过期类型，枚举<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="type">NS_ENUM</span>(<span class="type">NSUInteger</span>, <span class="type">SDImageCacheConfigExpireType</span>) &#123;</span><br><span class="line">    //访问图片时，它将更新此值 （访问日期）</span><br><span class="line">    <span class="type">SDImageCacheConfigExpireTypeAccessDate</span>,</span><br><span class="line">    //图片从磁盘缓存中获取 （修改日期）</span><br><span class="line">    <span class="type">SDImageCacheConfigExpireTypeModificationDate</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>定义配置属性如下<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解压缩下载和缓存的图片可以提高性能，但会占用大量内存。</span></span><br><span class="line"><span class="comment"> * 默认为YES。 如果由于过多的内存消耗而遇到崩溃，请将此项设置为NO。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//是否解压图片，默认YES</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> shouldDecompressImages;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否禁用iCloud备份，默认YES</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> shouldDisableiCloud;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否使用内存缓存，默认YES</span></span><br><span class="line"><span class="comment"> * 禁用内存缓存时，也会禁用弱内存缓存。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> shouldCacheImagesInMemory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 控制图片的弱内存缓存的选项.启用时, SDImageCache 的内存缓存将使用弱映射表在存储到内存的同时存储图像，并同时删除.</span></span><br><span class="line"><span class="comment"> * 但是当触发内存警告时，由于弱映射表没有强烈的图像实例引用，即使内存缓存本身被清除，UIImageViews或其他实时实例强烈保留的一些图像也可以再次恢复，以避免 稍后从磁盘缓存或网络重新查询。 这可能对这种情况有所帮助，例如，当app进入后台并清除内存时，会在重新输入前景后导致单元格闪烁。</span></span><br><span class="line"><span class="comment"> * 默认为YES。 您可以动态更改此选项。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//是否使用弱内存缓存，默认为YES</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> shouldUseWeakMemoryCache;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从磁盘读取缓存时的读取选项</span></span><br><span class="line"><span class="comment"> * 默认为 0. 可以设置为 `NSDataReadingMappedIfSafe` 以提高性能.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//磁盘缓存读取选项，枚举</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSDataReadingOptions</span> diskCacheReadingOptions;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将缓存写入磁盘时的写入选项</span></span><br><span class="line"><span class="comment"> * 默认为 NSDataWritingAtomic. 可以将其设置为 `NSDataWritingWithoutOverwriting` 以防止覆盖现有文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//磁盘缓存写入选项，枚举</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSDataWritingOptions</span> diskCacheWritingOptions;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在缓存中保留图片的最长时间，秒为单位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSInteger</span> maxCacheAge;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存的最大值，字节为单位，默认为0，表示不做限制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> maxCacheSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清理磁盘缓存时将检查清理缓存的属性</span></span><br><span class="line"><span class="comment"> * 默认修改日期</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//缓存配置过期类型，枚举 ，默认修改日期</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) SDImageCacheConfigExpireType diskCacheExpireType;</span><br></pre></td></tr></table></figure></p><h4 id="2-2、-m文件"><a href="#2-2、-m文件" class="headerlink" title="2.2、.m文件"></a>2.2、.m文件</h4><p>静态不可变 <code>NSInteger</code> 类型的 <code>kDefaultCacheMaxCacheAge</code> 表示在缓存中图像保存时间的最大长度，以秒为单位 默认是一周时间（60 ＊ 60 ＊ 24 ＊ 7）。<br><code>_maxCacheAge</code> 属性在 <code>.h</code> 中声明，可以外部修改。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSInteger</span> kDefaultCacheMaxCacheAge = <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">7</span>; <span class="comment">// 1 week</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//属性初始化赋值</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        _shouldDecompressImages = <span class="literal">YES</span>;</span><br><span class="line">        _shouldDisableiCloud = <span class="literal">YES</span>;</span><br><span class="line">        _shouldCacheImagesInMemory = <span class="literal">YES</span>;</span><br><span class="line">        _shouldUseWeakMemoryCache = <span class="literal">YES</span>;</span><br><span class="line">        _diskCacheReadingOptions = <span class="number">0</span>;</span><br><span class="line">        _diskCacheWritingOptions = <span class="built_in">NSDataWritingAtomic</span>;</span><br><span class="line">        _maxCacheAge = kDefaultCacheMaxCacheAge;</span><br><span class="line">        _maxCacheSize = <span class="number">0</span>;</span><br><span class="line">        _diskCacheExpireType = SDImageCacheConfigExpireTypeModificationDate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、SDImageCache类"><a href="#3、SDImageCache类" class="headerlink" title="3、SDImageCache类"></a>3、<code>SDImageCache</code>类</h3><p><code>SDImageCache</code> 维护内存缓存和可选的磁盘缓存。磁盘缓存写入操作是异步执行的，因此不会给UI增加不必要的延迟。</p><h4 id="3-1、-h文件"><a href="#3-1、-h文件" class="headerlink" title="3.1、.h文件"></a>3.1、.h文件</h4><p><strong>缓存类型，枚举</strong></p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="type">NS_ENUM</span>(<span class="type">NSInteger</span>, <span class="type">SDImageCacheType</span>) &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 图像不能用 <span class="type">SDWebImage</span> 缓存，但能从网上下载 （不缓存）。</span><br><span class="line">     */</span><br><span class="line">    <span class="type">SDImageCacheTypeNone</span>,</span><br><span class="line">    /**</span><br><span class="line">     * 图片从磁盘中获取（缓存到磁盘中）</span><br><span class="line">     */</span><br><span class="line">    <span class="type">SDImageCacheTypeDisk</span>,</span><br><span class="line">    /**</span><br><span class="line">     *图片从内存中获取（缓存到内存中）</span><br><span class="line">     */</span><br><span class="line">    <span class="type">SDImageCacheTypeMemory</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>缓存选项，枚举</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, SDImageCacheOptions) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认情况下，当图像缓存在内存中时，我们不查询磁盘数据。 此选项可以强制同时查询磁盘数据。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SDImageCacheQueryDataWhenInMemory = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认情况下，我们同步查询内存缓存，异步查询磁盘缓存。 此选项可以强制同步查询磁盘缓存。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SDImageCacheQueryDiskSync = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认情况下，图像会根据其原始大小进行解码。在iOS上，此选项会将图像缩小到与设备的受限内存兼容的大小。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SDImageCacheScaleDownLargeImages = <span class="number">1</span> &lt;&lt; <span class="number">2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>三个回调代码块</strong></p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//查询完成的block</span><br><span class="line">typedef void(^<span class="type">SDCacheQueryCompletedBlock</span>)(<span class="type">UIImage</span> * _Nullable image, <span class="type">NSData</span> * _Nullable data, <span class="type">SDImageCacheType</span> cacheType);</span><br><span class="line"></span><br><span class="line">//检查完成的block</span><br><span class="line">typedef void(^<span class="type">SDWebImageCheckCacheCompletionBlock</span>)(<span class="type">BOOL</span> isInCache);</span><br><span class="line"></span><br><span class="line">//计算缓存大小的block</span><br><span class="line">typedef void(^<span class="type">SDWebImageCalculateSizeBlock</span>)(<span class="type">NSUInteger</span> fileCount, <span class="type">NSUInteger</span> totalSize);</span><br></pre></td></tr></table></figure><p><strong>SDImageCache的属性 </strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  缓存配置对象，存储所有类型的设置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>, <span class="keyword">readonly</span>) SDImageCacheConfig *config;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置缓存中最大的消耗的内存，这里计算的是内存中的像素个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> maxMemoryCost;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存应持有的对象的的最大数量。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> maxMemoryCountLimit;</span><br></pre></td></tr></table></figure><p><strong>SDImageCache的单例和初始化</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回全局共享缓存实例</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return SDImageCache全局实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)sharedImageCache;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用特定命名空间初始化一个新的缓存存储，里面就是去获取磁盘缓存路径，然后在进行一系列的初始化操作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param ns 用于此缓存存储的命名空间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)initWithNamespace:(<span class="keyword">nonnull</span> <span class="built_in">NSString</span> *)ns;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用特定的命名空间和目录初始化一个新的缓存存储</span></span><br><span class="line"><span class="comment"> * @param ns 用于此缓存存储的命名空间</span></span><br><span class="line"><span class="comment"> * @param directory 用于缓存磁盘映像的目录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)initWithNamespace:(<span class="keyword">nonnull</span> <span class="built_in">NSString</span> *)ns</span><br><span class="line">                       diskCacheDirectory:(<span class="keyword">nonnull</span> <span class="built_in">NSString</span> *)directory <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br></pre></td></tr></table></figure><p><strong>缓存路径</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化磁盘缓存路径</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)makeDiskCachePath:(<span class="keyword">nonnull</span> <span class="built_in">NSString</span>*)fullNamespace;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加只读缓存路径用来搜索由SDImageCache预先缓存的图片</span></span><br><span class="line"><span class="comment"> * 如果想要预先加载的图片和应用程序捆绑在一起，则非常有用。去找图片也可以在这个路径中添加</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param path 此只读缓存路径使用的路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)addReadOnlyCachePath:(<span class="keyword">nonnull</span> <span class="built_in">NSString</span> *)path;</span><br></pre></td></tr></table></figure><p><strong>存储操作</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据key将图片异步缓存到内存和磁盘中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param image           需要缓存的图片</span></span><br><span class="line"><span class="comment"> * @param key             唯一的缓存图片的key,通常是图像的绝对URL</span></span><br><span class="line"><span class="comment"> * @param completionBlock 操作完成后执行的块</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)storeImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image</span><br><span class="line">            forKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key</span><br><span class="line">        completion:(<span class="keyword">nullable</span> SDWebImageNoParamsBlock)completionBlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据key将图片异步缓存到内存和磁盘中</span></span><br><span class="line"><span class="comment"> * （根据toDisk来判断是否要存储到磁盘中，这里的磁盘缓存是可选的）</span></span><br><span class="line"><span class="comment"> * @param image           需要缓存的图片</span></span><br><span class="line"><span class="comment"> * @param key            唯一的缓存图片的key,通常是图像的绝对URL</span></span><br><span class="line"><span class="comment"> * @param toDisk          是否缓存到磁盘中</span></span><br><span class="line"><span class="comment"> * @param completionBlock 操作完成后执行的块</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)storeImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image</span><br><span class="line">            forKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key</span><br><span class="line">            toDisk:(<span class="built_in">BOOL</span>)toDisk</span><br><span class="line">        completion:(<span class="keyword">nullable</span> SDWebImageNoParamsBlock)completionBlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据key将图片异步缓存到内存和磁盘中</span></span><br><span class="line"><span class="comment"> * （这里面的方法会根据imageData如果没有，但是image有的话，就会考虑到图片格式的问题）</span></span><br><span class="line"><span class="comment"> * @param image         需要缓存的图片</span></span><br><span class="line"><span class="comment"> * @param imageData     服务器返回的图像数据，此表示将用于磁盘存储，而不是将给定的图像对象转换为可存储/压缩的图像格式，以节省质量和CPU</span></span><br><span class="line"><span class="comment"> * @param key            唯一的缓存图片的key,通常是图像的绝对URL</span></span><br><span class="line"><span class="comment"> * @param toDisk          是否缓存到磁盘中</span></span><br><span class="line"><span class="comment"> * @param completionBlock 操作完成后执行的块</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)storeImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image</span><br><span class="line">         imageData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)imageData</span><br><span class="line">            forKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key</span><br><span class="line">            toDisk:(<span class="built_in">BOOL</span>)toDisk</span><br><span class="line">        completion:(<span class="keyword">nullable</span> SDWebImageNoParamsBlock)completionBlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据key将图片data同步缓存到内存和磁盘中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param imageData  需要缓存的图片data</span></span><br><span class="line"><span class="comment"> * @param key       唯一的缓存图片的key,通常是图像的绝对URL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)storeImageDataToDisk:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)imageData forKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key;</span><br></pre></td></tr></table></figure><p><strong>查询和检索操作</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  异步检查磁盘缓存中是否存在图片（不加载图片），回调返回结果</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param key             描述url的key</span></span><br><span class="line"><span class="comment"> *  @param completionBlock 检查完成时要执行的块。</span></span><br><span class="line"><span class="comment"> *  @note  将在主队列上始终执行完成块</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)diskImageExistsWithKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key completion:(<span class="keyword">nullable</span> SDWebImageCheckCacheCompletionBlock)completionBlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  同步检查磁盘缓存中是否存在图片（不加载图片），直接返回结果</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param key             描述url的key</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)diskImageDataExistsWithKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  根据key同步查询图片数据data</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param key 用来存储所需图片唯一的key</span></span><br><span class="line"><span class="comment"> *  @return  根据key返回查找的图片，如果未找到，返回nil</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)diskImageDataForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步查询缓存并在完成后调用完成的操作。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param key      用来存储所需图片唯一的key</span></span><br><span class="line"><span class="comment"> * @param doneBlock The completion block. 如果操作被取消，则不会被调用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return       包含缓存操作的NSOperation实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSOperation</span> *)queryCacheOperationForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key done:(<span class="keyword">nullable</span> SDCacheQueryCompletedBlock)doneBlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步查询缓存并在完成后调用完成的操作。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param key      用来存储所需图片唯一的key</span></span><br><span class="line"><span class="comment"> * @param options  用于指定用于此高速缓存查询的选项</span></span><br><span class="line"><span class="comment"> * @param doneBlock The completion block. 如果操作被取消，则不会被调用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return     包含缓存操作的NSOperation实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSOperation</span> *)queryCacheOperationForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key options:(SDImageCacheOptions)options done:(<span class="keyword">nullable</span> SDCacheQueryCompletedBlock)doneBlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步查询内存缓存</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param key     用来存储所需图片唯一的key</span></span><br><span class="line"><span class="comment"> * @return 根据key返回查找的图片，如果未找到，返回nil</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)imageFromMemoryCacheForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步查询磁盘缓存</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param key 用来存储所需图片唯一的key</span></span><br><span class="line"><span class="comment"> * @return 根据key返回查找的图片，如果未找到，返回nil</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)imageFromDiskCacheForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查缓存后，同步查询缓存（磁盘或内存）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param key 用来存储所需图片唯一的key</span></span><br><span class="line"><span class="comment"> * @return 根据key返回查找的图片，如果未找到，返回nil</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)imageFromCacheForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key;</span><br></pre></td></tr></table></figure><p><strong>移除操作</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从内存或者磁盘缓存中异步移除图片</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key            唯一的图片缓存key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> completion      删除图像后应执行的块（可选）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">removeImageForKey:</span>(nullable NSString *)key <span class="string">withCompletion:</span>(nullable SDWebImageNoParamsBlock)completion;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从内存和可选磁盘缓存中异步移除图片</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key            唯一的图片缓存key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromDisk        是否也从磁盘中移除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> completion      删除图像后应执行的块（可选）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">removeImageForKey:</span>(nullable NSString *)key <span class="string">fromDisk:</span>(BOOL)fromDisk <span class="string">withCompletion:</span>(nullable SDWebImageNoParamsBlock)completion;</span><br></pre></td></tr></table></figure><p><strong>缓存清理操作</strong></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清理所有的内存缓存图片</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">clearMemory</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步清除所有磁盘缓存的图片。 非阻塞方法 - 立即返回。</span></span><br><span class="line"><span class="comment"> * @param completion   缓存过期完成后应执行的块（可选）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">clearDiskOnCompletion</span><span class="selector-pseudo">:(nullable</span> <span class="selector-tag">SDWebImageNoParamsBlock</span>)<span class="selector-tag">completion</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步从磁盘中删除所有过期的缓存图片。 非阻塞方法 - 立即返回。</span></span><br><span class="line"><span class="comment"> * @param completionBlock 缓存过期完成后应执行的块（可选）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">deleteOldFilesWithCompletionBlock</span><span class="selector-pseudo">:(nullable</span> <span class="selector-tag">SDWebImageNoParamsBlock</span>)<span class="selector-tag">completionBlock</span>;</span><br></pre></td></tr></table></figure><p><strong>缓存信息</strong></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取磁盘缓存使用的大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="selector-tag">-</span> (NSUInteger)<span class="selector-tag">getSize</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取磁盘缓存中的图片数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="selector-tag">-</span> (NSUInteger)<span class="selector-tag">getDiskCount</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步计算磁盘缓存的大小。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">calculateSizeWithCompletionBlock</span><span class="selector-pseudo">:(nullable</span> <span class="selector-tag">SDWebImageCalculateSizeBlock</span>)<span class="selector-tag">completionBlock</span>;</span><br></pre></td></tr></table></figure><p><strong>缓存路径</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  需要根路径和key来查询文件所在的位置 (需要缓存路径根文件夹）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param key  the key (可以使用cacheKeyForURL从url获取)</span></span><br><span class="line"><span class="comment"> *  @param path 缓存路径根文件夹</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return 缓存路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)cachePathForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key inPath:(<span class="keyword">nonnull</span> <span class="built_in">NSString</span> *)path;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  根据key获取相应文件的默认的缓存路径</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param key the key (可以使用cacheKeyForURL从url获取)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return 默认的缓存路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)defaultCachePathForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key;</span><br></pre></td></tr></table></figure><h4 id="3-2、-m文件"><a href="#3-2、-m文件" class="headerlink" title="3.2、.m文件"></a>3.2、.m文件</h4><p>C语言函数，本质是计算diskImage所要占用的字节数。<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FOUNDATION_STATIC_INLINE NSUInteger SDCacheCostForImage(UIImage *<span class="built_in">image</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SD_MAC</span></span><br><span class="line">    <span class="built_in">return</span> <span class="built_in">image</span>.<span class="built_in">size</span>.<span class="built_in">height</span> * <span class="built_in">image</span>.<span class="built_in">size</span>.<span class="built_in">width</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> SD_UIKIT || SD_WATCH</span></span><br><span class="line">    <span class="built_in">return</span> <span class="built_in">image</span>.<span class="built_in">size</span>.<span class="built_in">height</span> * <span class="built_in">image</span>.<span class="built_in">size</span>.<span class="built_in">width</span> * <span class="built_in">image</span>.scale * <span class="built_in">image</span>.scale;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>私有</strong><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Private</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SDMemoryCache</span> &lt;<span class="title">KeyType</span>, <span class="title">ObjectType</span>&gt; ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nonnull</span>) SDImageCacheConfig *config;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSMapTable</span>&lt;KeyType, ObjectType&gt; *weakCache; <span class="comment">// strong-weak cache</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nonnull</span>) dispatch_semaphore_t weakCacheLock; <span class="comment">// a lock to keep the access to `weakCache` thread-safe</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init <span class="built_in">NS_UNAVAILABLE</span>;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithConfig:(<span class="keyword">nonnull</span> SDImageCacheConfig *)config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SDMemoryCache</span></span></span><br><span class="line"></span><br><span class="line">目前这似乎没有用在macOS上（macOS使用虚拟内存，并且在内存警告时不清除缓存）。 所以我们只在iOS / tvOS平台上覆盖。</span><br><span class="line"><span class="comment">//但是将来可能会有更多的子类选项和功能。</span></span><br><span class="line"><span class="meta">#if SD_UIKIT</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    <span class="comment">//移除内存警告通知</span></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="keyword">self</span> name:<span class="built_in">UIApplicationDidReceiveMemoryWarningNotification</span> object:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithConfig:(SDImageCacheConfig *)config &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用存储二级缓存的强弱映射表。 按照NSCache不复制密钥的文档</span></span><br><span class="line">        <span class="comment">// 当内存警告，缓存被清除时，这很有用。 但是，图像实例可以由其他实例保留，例如imageViews和alive。</span></span><br><span class="line">        <span class="comment">// 在这种情况下，我们可以同步弱缓存，而不需要从磁盘缓存加载</span></span><br><span class="line">        <span class="keyword">self</span>.weakCache = [[<span class="built_in">NSMapTable</span> alloc] initWithKeyOptions:<span class="built_in">NSPointerFunctionsStrongMemory</span> valueOptions:<span class="built_in">NSPointerFunctionsWeakMemory</span> capacity:<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">self</span>.weakCacheLock = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">self</span>.config = config;</span><br><span class="line">        <span class="comment">//添加内粗警告的通知</span></span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></span><br><span class="line">                                                 selector:<span class="keyword">@selector</span>(didReceiveMemoryWarning:)</span><br><span class="line">                                                     name:<span class="built_in">UIApplicationDidReceiveMemoryWarningNotification</span></span><br><span class="line">                                                   object:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)didReceiveMemoryWarning:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">    <span class="comment">//只删除缓存，但保持弱缓存</span></span><br><span class="line">    [<span class="keyword">super</span> removeAllObjects];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `setObject:forKey:` 只需调用0即可，覆盖这就足够了</span></span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>)obj forKey:(<span class="keyword">id</span>)key cost:(<span class="built_in">NSUInteger</span>)g &#123;</span><br><span class="line">    <span class="comment">//调用系统的NSCache方法</span></span><br><span class="line">    [<span class="keyword">super</span> setObject:obj forKey:key cost:g];</span><br><span class="line">    <span class="comment">//如果缓存配置不使用弱内存缓存，返回</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.config.shouldUseWeakMemoryCache) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key &amp;&amp; obj) &#123;</span><br><span class="line">        <span class="comment">//若果key和obj存在，存储弱缓存</span></span><br><span class="line">        LOCK(<span class="keyword">self</span>.weakCacheLock);</span><br><span class="line">        [<span class="keyword">self</span>.weakCache setObject:obj forKey:key];</span><br><span class="line">        UNLOCK(<span class="keyword">self</span>.weakCacheLock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过key获取object</span></span><br><span class="line">- (<span class="keyword">id</span>)objectForKey:(<span class="keyword">id</span>)key &#123;</span><br><span class="line">    <span class="keyword">id</span> obj = [<span class="keyword">super</span> objectForKey:key];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.config.shouldUseWeakMemoryCache) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key &amp;&amp; !obj) &#123;</span><br><span class="line">        <span class="comment">// 若果key存在，obj不存在，存储弱缓存</span></span><br><span class="line">        LOCK(<span class="keyword">self</span>.weakCacheLock);</span><br><span class="line">        obj = [<span class="keyword">self</span>.weakCache objectForKey:key];</span><br><span class="line">        UNLOCK(<span class="keyword">self</span>.weakCacheLock);</span><br><span class="line">        <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">            <span class="comment">//同步缓存</span></span><br><span class="line">            <span class="built_in">NSUInteger</span> cost = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> ([obj isKindOfClass:[<span class="built_in">UIImage</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">                <span class="comment">//diskImage所要占用的字节数</span></span><br><span class="line">                cost = SDCacheCostForImage(obj);</span><br><span class="line">            &#125;</span><br><span class="line">            [<span class="keyword">super</span> setObject:obj forKey:key cost:cost];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据key移除对象</span></span><br><span class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="keyword">id</span>)key &#123;</span><br><span class="line">    [<span class="keyword">super</span> removeObjectForKey:key];</span><br><span class="line">    <span class="comment">//如果缓存配置不使用弱内存缓存，返回</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.config.shouldUseWeakMemoryCache) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key) &#123;</span><br><span class="line">        <span class="comment">// 如果key存在，移除缓存</span></span><br><span class="line">        LOCK(<span class="keyword">self</span>.weakCacheLock);</span><br><span class="line">        [<span class="keyword">self</span>.weakCache removeObjectForKey:key];</span><br><span class="line">        UNLOCK(<span class="keyword">self</span>.weakCacheLock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移除所有对象</span></span><br><span class="line">- (<span class="keyword">void</span>)removeAllObjects &#123;</span><br><span class="line">    [<span class="keyword">super</span> removeAllObjects];</span><br><span class="line">    <span class="comment">//如果缓存配置不使用弱内存缓存，返回</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.config.shouldUseWeakMemoryCache) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 手动删除也应该删除弱缓存</span></span><br><span class="line">    LOCK(<span class="keyword">self</span>.weakCacheLock);</span><br><span class="line">    [<span class="keyword">self</span>.weakCache removeAllObjects];</span><br><span class="line">    UNLOCK(<span class="keyword">self</span>.weakCacheLock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#else</span></span><br><span class="line"><span class="comment">//如果是macos，直接初始化</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithConfig:(SDImageCacheConfig *)config &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p><strong>属性</strong><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SDImageCache</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - 属性</span></span><br><span class="line"><span class="comment">//内存缓存</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) SDMemoryCache *memCache;</span><br><span class="line"><span class="comment">//磁盘缓存路径</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSString</span> *diskCachePath;</span><br><span class="line"><span class="comment">//自定义路径</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">NSMutableArray</span>&lt;<span class="built_in">NSString</span> *&gt; *customPaths;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">dispatch_queue_t</span> ioQueue;</span><br><span class="line"><span class="comment">//文件管理器</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSFileManager</span> *fileManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p><strong>初始化</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark - 单例, 初始化, dealloc</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)sharedImageCache &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> once;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">id</span> instance;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;once, ^&#123;</span><br><span class="line">        instance = [<span class="keyword">self</span> new];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="comment">//初始化，namespace 默认为：default</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithNamespace:<span class="string">@"default"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)initWithNamespace:(<span class="keyword">nonnull</span> <span class="built_in">NSString</span> *)ns &#123;</span><br><span class="line">    <span class="comment">//获取磁盘缓存路径，默认的是：~/default （ns为default，拼接到缓存路径的最后面）</span></span><br><span class="line">    <span class="built_in">NSString</span> *path = [<span class="keyword">self</span> makeDiskCachePath:ns];</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithNamespace:ns diskCacheDirectory:path];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)initWithNamespace:(<span class="keyword">nonnull</span> <span class="built_in">NSString</span> *)ns</span><br><span class="line">                       diskCacheDirectory:(<span class="keyword">nonnull</span> <span class="built_in">NSString</span> *)directory &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *fullNamespace = [<span class="string">@"com.hackemist.SDWebImageCache."</span> stringByAppendingString:ns];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建IO串行队列</span></span><br><span class="line">        _ioQueue = dispatch_queue_create(<span class="string">"com.hackemist.SDWebImageCache"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//初始化缓存配置</span></span><br><span class="line">        _config = [[SDImageCacheConfig alloc] init];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化内存缓存</span></span><br><span class="line">        _memCache = [[SDMemoryCache alloc] initWithConfig:_config];</span><br><span class="line">        _memCache.name = fullNamespace;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化磁盘缓存</span></span><br><span class="line">        <span class="keyword">if</span> (directory != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">//如果路径不为nil，在路径的结尾拼接fullNamespace</span></span><br><span class="line">            _diskCachePath = [directory stringByAppendingPathComponent:fullNamespace];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//如果路径为nil，获取路径</span></span><br><span class="line">            <span class="built_in">NSString</span> *path = [<span class="keyword">self</span> makeDiskCachePath:ns];</span><br><span class="line">            _diskCachePath = path;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dispatch_sync</span>(_ioQueue, ^&#123;</span><br><span class="line">            <span class="comment">//初始化文件管理器</span></span><br><span class="line">            <span class="keyword">self</span>.fileManager = [<span class="built_in">NSFileManager</span> new];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="meta">#if SD_UIKIT</span></span><br><span class="line">        <span class="comment">//添加删除通知</span></span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></span><br><span class="line">                                                 selector:<span class="keyword">@selector</span>(deleteOldFiles)</span><br><span class="line">                                                     name:<span class="built_in">UIApplicationWillTerminateNotification</span></span><br><span class="line">                                                   object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></span><br><span class="line">                                                 selector:<span class="keyword">@selector</span>(backgroundDeleteOldFiles)</span><br><span class="line">                                                     name:<span class="built_in">UIApplicationDidEnterBackgroundNotification</span></span><br><span class="line">                                                   object:<span class="literal">nil</span>];</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>缓存路径</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加只读缓存路径用来搜索由SDImageCache预先缓存的图片</span></span><br><span class="line">- (<span class="keyword">void</span>)addReadOnlyCachePath:(<span class="keyword">nonnull</span> <span class="built_in">NSString</span> *)path &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.customPaths) &#123;</span><br><span class="line">        <span class="keyword">self</span>.customPaths = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不包含就添加</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span>.customPaths containsObject:path]) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.customPaths addObject:path];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要根路径和key来查询文件所在的位置 (需要缓存路径根文件夹）</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)cachePathForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key inPath:(<span class="keyword">nonnull</span> <span class="built_in">NSString</span> *)path &#123;</span><br><span class="line">    <span class="comment">//根据key获取缓存文件名</span></span><br><span class="line">    <span class="built_in">NSString</span> *filename = [<span class="keyword">self</span> cachedFileNameForKey:key];</span><br><span class="line">    <span class="keyword">return</span> [path stringByAppendingPathComponent:filename];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据key获取默认缓存路径</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)defaultCachePathForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> cachePathForKey:key inPath:<span class="keyword">self</span>.diskCachePath];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据key获取缓存文件名</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)cachedFileNameForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *str = key.UTF8String;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        str = <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> r[CC_MD5_DIGEST_LENGTH];</span><br><span class="line">    CC_MD5(str, (CC_LONG)strlen(str), r);</span><br><span class="line">    <span class="built_in">NSURL</span> *keyURL = [<span class="built_in">NSURL</span> URLWithString:key];</span><br><span class="line">    <span class="built_in">NSString</span> *ext = keyURL ? keyURL.pathExtension : key.pathExtension;</span><br><span class="line">    <span class="built_in">NSString</span> *filename = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%@"</span>,</span><br><span class="line">                          r[<span class="number">0</span>], r[<span class="number">1</span>], r[<span class="number">2</span>], r[<span class="number">3</span>], r[<span class="number">4</span>], r[<span class="number">5</span>], r[<span class="number">6</span>], r[<span class="number">7</span>], r[<span class="number">8</span>], r[<span class="number">9</span>], r[<span class="number">10</span>],</span><br><span class="line">                          r[<span class="number">11</span>], r[<span class="number">12</span>], r[<span class="number">13</span>], r[<span class="number">14</span>], r[<span class="number">15</span>], ext.length == <span class="number">0</span> ? <span class="string">@""</span> : [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@".%@"</span>, ext]];</span><br><span class="line">    <span class="keyword">return</span> filename;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据fullNamespace获取磁盘缓存路径</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)makeDiskCachePath:(<span class="keyword">nonnull</span> <span class="built_in">NSString</span>*)fullNamespace &#123;</span><br><span class="line">    <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *paths = <span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSCachesDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>);</span><br><span class="line">    <span class="keyword">return</span> [paths[<span class="number">0</span>] stringByAppendingPathComponent:fullNamespace];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>存储操作</strong></p><p>根据key将图片异步缓存到内存和磁盘中（默认存到内存和磁盘）<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据key将图片异步缓存到内存和磁盘中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> image           需要缓存的图片</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key             唯一的缓存图片的key,通常是图像的绝对URL</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> completionBlock 操作完成后执行的块</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">storeImage:</span>(nullable UIImage *)image</span><br><span class="line"><span class="symbol">            forKey:</span>(nullable NSString *)key</span><br><span class="line"><span class="symbol">        completion:</span>(nullable SDWebImageNoParamsBlock)completionBlock &#123;</span><br><span class="line">    [self <span class="string">storeImage:</span>image <span class="string">imageData:</span>nil <span class="string">forKey:</span>key <span class="string">toDisk:</span>YES <span class="string">completion:</span>completionBlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据key将图片异步缓存到内存和磁盘中 （默认存储到内存，根据判断是否存储到磁盘中）<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据key将图片异步缓存到内存和磁盘中</span></span><br><span class="line"><span class="comment"> * （根据toDisk来判断是否要存储到磁盘中，这里的磁盘缓存是可选的）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> image           需要缓存的图片</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key            唯一的缓存图片的key,通常是图像的绝对URL</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toDisk          是否缓存到磁盘中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> completionBlock 操作完成后执行的块</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">storeImage:</span>(nullable UIImage *)image</span><br><span class="line"><span class="symbol">            forKey:</span>(nullable NSString *)key</span><br><span class="line"><span class="symbol">            toDisk:</span>(BOOL)toDisk</span><br><span class="line"><span class="symbol">        completion:</span>(nullable SDWebImageNoParamsBlock)completionBlock &#123;</span><br><span class="line">    [self <span class="string">storeImage:</span>image <span class="string">imageData:</span>nil <span class="string">forKey:</span>key <span class="string">toDisk:</span>toDisk <span class="string">completion:</span>completionBlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据key将图片异步缓存到内存和磁盘中 （默认存储到内存，根据判断是否存储到磁盘）<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据key将图片异步缓存到内存和磁盘中</span></span><br><span class="line"><span class="comment"> * （这里面的方法会根据imageData如果没有，但是image有的话，就会考虑到图片格式的问题）</span></span><br><span class="line"><span class="comment"> * @param image         需要缓存的图片</span></span><br><span class="line"><span class="comment"> * @param imageData     服务器返回的图像数据，此表示将用于磁盘存储，而不是将给定的图像对象转换为可存储/压缩的图像格式，以节省质量和CPU</span></span><br><span class="line"><span class="comment"> * @param key            唯一的缓存图片的key,通常是图像的绝对URL</span></span><br><span class="line"><span class="comment"> * @param toDisk          是否缓存到磁盘中</span></span><br><span class="line"><span class="comment"> * @param completionBlock 操作完成后执行的块  typedef void(^SDWebImageNoParamsBlock)(void); 不需要传任何参数</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)storeImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image</span><br><span class="line">         imageData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)imageData</span><br><span class="line">            forKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key</span><br><span class="line">            toDisk:(<span class="built_in">BOOL</span>)toDisk</span><br><span class="line">        completion:(<span class="keyword">nullable</span> SDWebImageNoParamsBlock)completionBlock &#123;</span><br><span class="line">    <span class="comment">//若图片或者key不存在，则不存储，执行回调，返回</span></span><br><span class="line">    <span class="keyword">if</span> (!image || !key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (completionBlock) &#123;</span><br><span class="line">            completionBlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果启用了内存缓存</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.config.shouldCacheImagesInMemory) &#123;</span><br><span class="line">        <span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(image);</span><br><span class="line">        <span class="comment">//根据key缓存image，</span></span><br><span class="line">        [<span class="keyword">self</span>.memCache setObject:image forKey:key cost:cost];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//若需要缓存到磁盘</span></span><br><span class="line">    <span class="keyword">if</span> (toDisk) &#123;</span><br><span class="line">        <span class="comment">//异步执行缓存操作</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</span><br><span class="line">            <span class="keyword">@autoreleasepool</span> &#123; <span class="comment">//自动释放池（里面创建了很多临时变量，当@autoreleasepool结束时，里面的内存就会回收）</span></span><br><span class="line">                <span class="built_in">NSData</span> *data = imageData;</span><br><span class="line">                <span class="keyword">if</span> (!data &amp;&amp; image) &#123;</span><br><span class="line">                    <span class="comment">// 如果我们没有任何数据来检测图像格式，请检查它是否包含使用PNG或JPEG格式的Alpha通道</span></span><br><span class="line">                    SDImageFormat format;</span><br><span class="line">                    <span class="keyword">if</span> (SDCGImageRefContainsAlpha(image.CGImage)) &#123;</span><br><span class="line">                        format = SDImageFormatPNG;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        format = SDImageFormatJPEG;</span><br><span class="line">                    &#125;</span><br><span class="line">                    将图片编码为图片数据，该方法在SDWebImageCoder类中</span><br><span class="line">                    data = [[SDWebImageCodersManager sharedInstance] encodedDataWithImage:image format:format];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//根据key存储imageData</span></span><br><span class="line">                [<span class="keyword">self</span> _storeImageDataToDisk:data forKey:key];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果需要回调，在主线程执行回调</span></span><br><span class="line">            <span class="keyword">if</span> (completionBlock) &#123;</span><br><span class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    completionBlock();</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">//如果不存储磁盘，执行完成回调</span></span><br><span class="line">        <span class="keyword">if</span> (completionBlock) &#123;</span><br><span class="line">            completionBlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据key将图片data同步缓存到磁盘中<br> <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据key将图片data同步缓存到内存和磁盘中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param imageData  需要缓存的图片data</span></span><br><span class="line"><span class="comment"> * @param key       唯一的缓存图片的key,通常是图像的绝对URL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)storeImageDataToDisk:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)imageData forKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">     <span class="comment">//若图片或者key不存在，则不能存储</span></span><br><span class="line">    <span class="keyword">if</span> (!imageData || !key) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> _storeImageDataToDisk:imageData forKey:key];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据key将图片data同步缓存到内存和磁盘中（确保通过调用者调用表单io队列）<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)_storeImageDataToDisk:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)imageData forKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="comment">//若图片或者key不存在，则不能存储</span></span><br><span class="line">    <span class="keyword">if</span> (!imageData || !key) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果文件管理器中不存在磁盘缓存的路径，则创建</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span>.fileManager fileExistsAtPath:_diskCachePath]) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.fileManager createDirectoryAtPath:_diskCachePath withIntermediateDirectories:<span class="literal">YES</span> attributes:<span class="literal">nil</span> error:<span class="literal">NULL</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过key获取缓存路径</span></span><br><span class="line">    <span class="built_in">NSString</span> *cachePathForKey = [<span class="keyword">self</span> defaultCachePathForKey:key];</span><br><span class="line">    <span class="comment">// 转换成 NSUrl</span></span><br><span class="line">    <span class="built_in">NSURL</span> *fileURL = [<span class="built_in">NSURL</span> fileURLWithPath:cachePathForKey];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将图片写入fileURL中（options写入的选项，默认的配置为：NSDataWritingAtomic）</span></span><br><span class="line">    [imageData writeToURL:fileURL options:<span class="keyword">self</span>.config.diskCacheWritingOptions error:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 禁用iCloud备份</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.config.shouldDisableiCloud) &#123;</span><br><span class="line">        <span class="comment">//NSURLIsExcludedFromBackupKey：如果应从备份中排除资源，则为true，否则为false（读写，值类型为boolean NSNumber）。 此属性仅用于排除备份中不需要的缓存和其他应用程序支持文件。 通常对用户文档执行的某些操作将导致此属性重置为false，因此不应在用户文档上使用此属性。</span></span><br><span class="line">        [fileURL setResourceValue:@YES forKey:<span class="built_in">NSURLIsExcludedFromBackupKey</span> error:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>查询和检索操作</strong></p><p>异步检查磁盘缓存中是否存在图片（不加载图片），回调返回结果<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  异步检查串行队列的磁盘缓存中是否存在图片（不加载图片），回调返回结果</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param key             描述url的key</span></span><br><span class="line"><span class="comment"> *  @param completionBlock 检查完成时要执行的块。</span></span><br><span class="line"><span class="comment"> *  @note  将在主队列上始终执行完成块</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)diskImageExistsWithKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key completion:(<span class="keyword">nullable</span> SDWebImageCheckCacheCompletionBlock)completionBlock &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</span><br><span class="line">        <span class="comment">// 根据key判断磁盘中是否图片数据</span></span><br><span class="line">        <span class="built_in">BOOL</span> exists = [<span class="keyword">self</span> _diskImageDataExistsWithKey:key];</span><br><span class="line">        <span class="keyword">if</span> (completionBlock) &#123;</span><br><span class="line">            <span class="comment">//如果回调代码存在，主线程执行完成查询的回调</span></span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                completionBlock(exists);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同步检查磁盘缓存中是否存在图片（不加载图片），直接返回结果<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  同步检查磁盘缓存中是否存在图片（不加载图片），直接返回结果</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param key             描述url的key</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)diskImageDataExistsWithKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="comment">//如果key不存在，返回查询结果为NO ，否则同步根据key同步查询是否存在图片，返回结果</span></span><br><span class="line">    <span class="keyword">if</span> (!key) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    __block <span class="built_in">BOOL</span> exists = <span class="literal">NO</span>;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</span><br><span class="line">        exists = [<span class="keyword">self</span> _diskImageDataExistsWithKey:key];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> exists;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据key判断磁盘中是否存在图片数据<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)_diskImageDataExistsWithKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="comment">//如果key不存在，返回查询结果为NO </span></span><br><span class="line">    <span class="keyword">if</span> (!key) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//key存在，则判断文件管理器中是否存在该key的缓存路径，如果存在返回，</span></span><br><span class="line">    <span class="built_in">BOOL</span> exists = [<span class="keyword">self</span>.fileManager fileExistsAtPath:[<span class="keyword">self</span> defaultCachePathForKey:key]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果不存在，进一步判断是否存在该key删除扩展名的缓存路径，返回判断结果</span></span><br><span class="line">    <span class="keyword">if</span> (!exists) &#123;</span><br><span class="line">        <span class="comment">//stringByDeletingPathExtension：从文件的最后一部分删除扩展名</span></span><br><span class="line">        exists = [<span class="keyword">self</span>.fileManager fileExistsAtPath:[<span class="keyword">self</span> defaultCachePathForKey:key].stringByDeletingPathExtension];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> exists;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据key同步查询图片数据data<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)diskImageDataForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">     <span class="comment">//如果key不存在，返回nil</span></span><br><span class="line">    <span class="keyword">if</span> (!key) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据key搜索所有的路径获取磁盘图片data</span></span><br><span class="line">    __block <span class="built_in">NSData</span> *imageData = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</span><br><span class="line">        imageData = [<span class="keyword">self</span> diskImageDataBySearchingAllPathsForKey:key];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> imageData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据key同步查询内存缓存图片<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)imageFromMemoryCacheForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.memCache objectForKey:key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据key同步查询磁盘缓存图片<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)imageFromDiskCacheForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="comment">//根据key查询磁盘缓存图片，最终调用的是：- (UIImage *)diskImageForKey: data: options:这个方法</span></span><br><span class="line">    <span class="built_in">UIImage</span> *diskImage = [<span class="keyword">self</span> diskImageForKey:key];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果图片存在，并且需要缓存到内存中，则计算所占用字节数，并缓存到内存中</span></span><br><span class="line">    <span class="keyword">if</span> (diskImage &amp;&amp; <span class="keyword">self</span>.config.shouldCacheImagesInMemory) &#123;</span><br><span class="line">        <span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(diskImage);</span><br><span class="line">        [<span class="keyword">self</span>.memCache setObject:diskImage forKey:key cost:cost];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> diskImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>检查缓存后，同步查询缓存（磁盘或内存）<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (nullable UIImage *)imageFromCacheForKey:(nullable NSString *)<span class="built_in">key</span> &#123;</span><br><span class="line">    <span class="comment">// 先从内存中查询缓存图片，如果存在，结束查询并返回图片</span></span><br><span class="line">    UIImage *<span class="built_in">image</span> = [self imageFromMemoryCacheForKey:<span class="built_in">key</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">image</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">image</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果内存中未查到该key的图片，则从磁盘中查询，返回最后查询的结果</span></span><br><span class="line">    <span class="built_in">image</span> = [self imageFromDiskCacheForKey:<span class="built_in">key</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">image</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据key搜索所有的路径获取磁盘图片data<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)diskImageDataBySearchingAllPathsForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="comment">//根据key获取默认的缓存路径</span></span><br><span class="line">    <span class="built_in">NSString</span> *defaultPath = [<span class="keyword">self</span> defaultCachePathForKey:key];</span><br><span class="line">    <span class="comment">//self.config.diskCacheReadingOptions ：默认是0，即：NSDataReadingMappedIfSafe</span></span><br><span class="line">    <span class="comment">//根据缓存路径和磁盘缓存读取选项，获取图片data，若存在则返回data，不存在则继续读取该key删除扩展名的缓存路径</span></span><br><span class="line">    <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfFile:defaultPath options:<span class="keyword">self</span>.config.diskCacheReadingOptions error:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取该key删除扩展名的缓存路径，获取图片data，若存在则返回data</span></span><br><span class="line">    data = [<span class="built_in">NSData</span> dataWithContentsOfFile:defaultPath.stringByDeletingPathExtension options:<span class="keyword">self</span>.config.diskCacheReadingOptions error:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">    如果上面均未读取tupiandata，则依据上面的方法查找自定义路径，若存在返回data，如果仍未找到则返回<span class="literal">nil</span></span><br><span class="line">    <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *customPaths = [<span class="keyword">self</span>.customPaths <span class="keyword">copy</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *path <span class="keyword">in</span> customPaths) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *filePath = [<span class="keyword">self</span> cachePathForKey:key inPath:path];</span><br><span class="line">        <span class="built_in">NSData</span> *imageData = [<span class="built_in">NSData</span> dataWithContentsOfFile:filePath options:<span class="keyword">self</span>.config.diskCacheReadingOptions error:<span class="literal">nil</span>];</span><br><span class="line">        <span class="keyword">if</span> (imageData) &#123;</span><br><span class="line">            <span class="keyword">return</span> imageData;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        imageData = [<span class="built_in">NSData</span> dataWithContentsOfFile:filePath.stringByDeletingPathExtension options:<span class="keyword">self</span>.config.diskCacheReadingOptions error:<span class="literal">nil</span>];</span><br><span class="line">        <span class="keyword">if</span> (imageData) &#123;</span><br><span class="line">            <span class="keyword">return</span> imageData;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据key获取磁盘图片<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">缓存图片到磁盘是存储的imageData；到内存是存储的image。</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)diskImageForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="comment">//现获取imagedata，再转换成image</span></span><br><span class="line">    <span class="built_in">NSData</span> *data = [<span class="keyword">self</span> diskImageDataForKey:key];</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> diskImageForKey:key data:data];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据key和data得到磁盘图片<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)diskImageForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key data:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> diskImageForKey:key data:data options:<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>//最终调用的方法，根据key和data、选项获取磁盘图片<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (nullable <span class="type">UIImage</span> *)diskImageForKey:(nullable <span class="type">NSString</span> *)key <span class="class"><span class="keyword">data</span>:(<span class="title">nullable</span> <span class="type">NSData</span> *)<span class="keyword">data</span> options:(<span class="type">SDImageCacheOptions</span>)options &#123;</span></span><br><span class="line"><span class="class">    //如果图片的<span class="title">data</span>存在，进行进一步的转换，否则返回<span class="title">nil</span></span></span><br><span class="line"><span class="class">    <span class="title">if</span> (<span class="title">data</span>) &#123;</span></span><br><span class="line"><span class="class">        //将<span class="title">data</span>转换成<span class="title">image</span></span></span><br><span class="line"><span class="class">        <span class="type">UIImage</span> *<span class="title">image</span> = [[<span class="type">SDWebImageCodersManager</span> <span class="title">sharedInstance</span>] <span class="title">decodedImageWithData</span>:<span class="title">data</span>];</span></span><br><span class="line"><span class="class">        //对图片进行缩放操作</span></span><br><span class="line"><span class="class">        <span class="title">image</span> = [<span class="title">self</span> <span class="title">scaledImageForKey</span>:<span class="title">key</span> <span class="title">image</span>:<span class="title">image</span>];</span></span><br><span class="line"><span class="class">        //如果需要解压缩操作，就进行其操作，否则直接返回图片</span></span><br><span class="line"><span class="class">        <span class="title">if</span> (<span class="title">self</span>.<span class="title">config</span>.<span class="title">shouldDecompressImages</span>) &#123;</span></span><br><span class="line"><span class="class">            //默认情况下，图像会根据其原始大小进行解码。在<span class="title">iOS</span>上，此选项会将图像缩小到与设备的受限内存兼容的大小。</span></span><br><span class="line"><span class="class">            <span class="type">BOOL</span> <span class="title">shouldScaleDown</span> = <span class="title">options</span> &amp; <span class="type">SDImageCacheScaleDownLargeImages</span>;</span></span><br><span class="line"><span class="class">            /**</span></span><br><span class="line"><span class="class">              *- (<span class="title">nullable</span> <span class="type">UIImage</span> *)<span class="title">decompressedImageWithImage</span>:(<span class="title">nullable</span> <span class="type">UIImage</span> *)<span class="title">image</span></span></span><br><span class="line"><span class="class">                                            <span class="title">data</span>:(<span class="type">NSData</span> * <span class="title">_Nullable</span> * <span class="title">_Nonnull</span>)<span class="title">data</span></span></span><br><span class="line"><span class="class">                                         <span class="title">options</span>:(<span class="title">nullable</span> <span class="type">NSDictionary</span>&lt;<span class="type">NSString</span>*, <span class="type">NSObject</span>*&gt;*)<span class="title">optionsDict</span>;</span></span><br><span class="line"><span class="class">              * 使用原始图像和图像数据解压缩图像。</span></span><br><span class="line"><span class="class">              *</span></span><br><span class="line"><span class="class">              * @<span class="title">param</span> <span class="title">image</span>要解压缩的原始图像</span></span><br><span class="line"><span class="class">              * @<span class="title">param</span> <span class="title">data</span>指向原始图像数据的指针。 指针本身是非空的，但图像数据可以为空。 如果需要，此数据将设置为缓存。 如果您不需要同时修改数据，请忽略此参数。</span></span><br><span class="line"><span class="class">              * @<span class="title">param</span> <span class="title">optionsDict</span>包含任何解压缩选项的字典。 通过&#123;<span class="type">SDWebImageCoderScaleDownLargeImagesKey</span>：@（<span class="type">YES</span>）&#125;缩小大图像</span></span><br><span class="line">              * @return解压缩的图像</span><br><span class="line">              */</span><br><span class="line">            </span><br><span class="line">            image = [[<span class="type">SDWebImageCodersManager</span> sharedInstance] decompressedImageWithImage:image <span class="class"><span class="keyword">data</span>:&amp;<span class="keyword">data</span> options:@&#123;<span class="type">SDWebImageCoderScaleDownLargeImagesKey</span>: @(<span class="title">shouldScaleDown</span>)&#125;];</span></span><br><span class="line">        &#125;</span><br><span class="line">        return image;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>//图片缩放操作<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)scaledImageForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key image:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image &#123;</span><br><span class="line">    <span class="keyword">return</span> SDScaledImageForKey(key, image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>异步查询缓存并在完成后调用完成的操作<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步查询缓存并在完成后调用完成的操作。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key      用来存储所需图片唯一的key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> doneBlock The completion block. 如果操作被取消，则不会被调用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>       包含缓存操作的NSOperation实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (NSOperation *)<span class="string">queryCacheOperationForKey:</span>(NSString *)key <span class="string">done:</span>(SDCacheQueryCompletedBlock)doneBlock &#123;</span><br><span class="line">    <span class="keyword">return</span> [self <span class="string">queryCacheOperationForKey:</span>key <span class="string">options:</span><span class="number">0</span> <span class="string">done:</span>doneBlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>异步查询缓存并在完成后调用完成的操作<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步查询缓存并在完成后调用完成的操作。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param key      用来存储所需图片唯一的key</span></span><br><span class="line"><span class="comment"> * @param options  用于指定用于此高速缓存查询的选项</span></span><br><span class="line"><span class="comment"> * @param doneBlock The completion block. 如果操作被取消，则不会被调用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return     包含缓存操作的NSOperation实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSOperation</span> *)queryCacheOperationForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key options:(SDImageCacheOptions)options done:(<span class="keyword">nullable</span> SDCacheQueryCompletedBlock)doneBlock &#123;</span><br><span class="line">    <span class="comment">//如果key不存在，返回查询操作为nil，如果执行回调，则image，data传nil，类型传SDImageCacheTypeNone</span></span><br><span class="line">    <span class="keyword">if</span> (!key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (doneBlock) &#123;</span><br><span class="line">            doneBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, SDImageCacheTypeNone);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 先从内存中查找图片，</span></span><br><span class="line">    <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> imageFromMemoryCacheForKey:key];</span><br><span class="line">    <span class="built_in">BOOL</span> shouldQueryMemoryOnly = (image &amp;&amp; !(options &amp; SDImageCacheQueryDataWhenInMemory));</span><br><span class="line">    如果image存在，并且只从内存中查找，返回<span class="built_in">NSOperation</span>为<span class="literal">nil</span>，，如果执行回调，则传image为查找的image，data传<span class="literal">nil</span>，类型传SDImageCacheTypeMemory</span><br><span class="line">    <span class="keyword">if</span> (shouldQueryMemoryOnly) &#123;</span><br><span class="line">        <span class="keyword">if</span> (doneBlock) &#123;</span><br><span class="line">            doneBlock(image, <span class="literal">nil</span>, SDImageCacheTypeMemory);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建一个NSOperation来获取磁盘图片</span></span><br><span class="line">    <span class="built_in">NSOperation</span> *operation = [<span class="built_in">NSOperation</span> new];</span><br><span class="line">    <span class="keyword">void</span>(^queryDiskBlock)(<span class="keyword">void</span>) =  ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (operation.isCancelled) &#123;</span><br><span class="line">            <span class="comment">// 如果操作被取消，则不执行回调</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//在自动释放池中执行，当@autoreleasepool结束时，里面的内存就会回收</span></span><br><span class="line">        <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">            <span class="comment">//获取缓存data</span></span><br><span class="line">            <span class="built_in">NSData</span> *diskData = [<span class="keyword">self</span> diskImageDataBySearchingAllPathsForKey:key];</span><br><span class="line">            <span class="built_in">UIImage</span> *diskImage;</span><br><span class="line">            SDImageCacheType cacheType = SDImageCacheTypeDisk;</span><br><span class="line">            <span class="keyword">if</span> (image) &#123;</span><br><span class="line">                <span class="comment">// 如果从内存中查找的image存在，赋值给diskImage，缓存类型为SDImageCacheTypeMemory</span></span><br><span class="line">                diskImage = image;</span><br><span class="line">                cacheType = SDImageCacheTypeMemory;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (diskData) &#123;</span><br><span class="line">                <span class="comment">// 如果内存缓存未找到image，并且缓存data存在，通过diskData转换为image</span></span><br><span class="line">                diskImage = [<span class="keyword">self</span> diskImageForKey:key data:diskData options:options];</span><br><span class="line">                <span class="keyword">if</span> (diskImage &amp;&amp; <span class="keyword">self</span>.config.shouldCacheImagesInMemory) &#123;</span><br><span class="line">                    <span class="comment">//磁盘图片存在，并且需要缓存到内存，则做内存存储图片操作</span></span><br><span class="line">                    <span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(diskImage);</span><br><span class="line">                    [<span class="keyword">self</span>.memCache setObject:diskImage forKey:key cost:cost];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//完成回调存在，如果选项为：SDImageCacheQueryDiskSync（此选项可以强制同步查询磁盘缓存），则执行同步回调，否则在主线程执行回调</span></span><br><span class="line">            <span class="keyword">if</span> (doneBlock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (options &amp; SDImageCacheQueryDiskSync) &#123;</span><br><span class="line">                    doneBlock(diskImage, diskData, cacheType);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                        doneBlock(diskImage, diskData, cacheType);</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果选项为：SDImageCacheQueryDiskSync（此选项可以强制同步查询磁盘缓存），则执行同步执行上面的queryDiskBlock代码块，否则异步执行</span></span><br><span class="line">    <span class="keyword">if</span> (options &amp; SDImageCacheQueryDiskSync) &#123;</span><br><span class="line">        queryDiskBlock();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, queryDiskBlock);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>移除操作</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从内存或者磁盘缓存中异步移除图片</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param key            唯一的图片缓存key</span></span><br><span class="line"><span class="comment"> * @param completion      删除图像后应执行的块（可选）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeImageForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key withCompletion:(<span class="keyword">nullable</span> SDWebImageNoParamsBlock)completion &#123;</span><br><span class="line">    [<span class="keyword">self</span> removeImageForKey:key fromDisk:<span class="literal">YES</span> withCompletion:completion];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从内存和可选磁盘缓存中异步移除图片</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param key            唯一的图片缓存key</span></span><br><span class="line"><span class="comment"> * @param fromDisk        是否也从磁盘中移除</span></span><br><span class="line"><span class="comment"> * @param completion      删除图像后应执行的块（可选）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)removeImageForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key fromDisk:(<span class="built_in">BOOL</span>)fromDisk withCompletion:(<span class="keyword">nullable</span> SDWebImageNoParamsBlock)completion &#123;</span><br><span class="line">    <span class="comment">//key为空，返回</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果缓存配置允许缓存到内存上，则需要在内存上也删除该key的缓存</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.config.shouldCacheImagesInMemory) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.memCache removeObjectForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果需要从磁盘上移除缓存，则执行磁盘移除缓存操作</span></span><br><span class="line">    <span class="keyword">if</span> (fromDisk) &#123;</span><br><span class="line">        <span class="comment">//异步执行移除磁盘缓存操作</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</span><br><span class="line">            [<span class="keyword">self</span>.fileManager removeItemAtPath:[<span class="keyword">self</span> defaultCachePathForKey:key] error:<span class="literal">nil</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//主线程执行完成回调</span></span><br><span class="line">            <span class="keyword">if</span> (completion) &#123;</span><br><span class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    completion();</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (completion)&#123;</span><br><span class="line">        <span class="comment">//执行完成回调</span></span><br><span class="line">        completion();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>缓存清理操作</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//清理缓存</span></span><br><span class="line">- (<span class="keyword">void</span>)clearMemory &#123;</span><br><span class="line">    <span class="comment">//清理所有内存缓存</span></span><br><span class="line">    [<span class="keyword">self</span>.memCache removeAllObjects];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//异步清理磁盘缓存，回调结果</span></span><br><span class="line">- (<span class="keyword">void</span>)clearDiskOnCompletion:(<span class="keyword">nullable</span> SDWebImageNoParamsBlock)completion &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</span><br><span class="line">        <span class="comment">//删除该磁盘缓存路径，之后再重新创建一个作为新的缓存路径（其实就是同一个路径，目的就是删除缓存数据）</span></span><br><span class="line">        [<span class="keyword">self</span>.fileManager removeItemAtPath:<span class="keyword">self</span>.diskCachePath error:<span class="literal">nil</span>];</span><br><span class="line">        [<span class="keyword">self</span>.fileManager createDirectoryAtPath:<span class="keyword">self</span>.diskCachePath</span><br><span class="line">                withIntermediateDirectories:<span class="literal">YES</span></span><br><span class="line">                                 attributes:<span class="literal">nil</span></span><br><span class="line">                                      error:<span class="literal">NULL</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (completion) &#123;</span><br><span class="line">            <span class="comment">//主线程执行完成回调</span></span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                completion();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除过期的文件</span></span><br><span class="line">- (<span class="keyword">void</span>)deleteOldFiles &#123;</span><br><span class="line">    [<span class="keyword">self</span> deleteOldFilesWithCompletionBlock:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//异步从磁盘中删除所有过期的缓存图片</span></span><br><span class="line">- (<span class="keyword">void</span>)deleteOldFilesWithCompletionBlock:(<span class="keyword">nullable</span> SDWebImageNoParamsBlock)completionBlock &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</span><br><span class="line">        <span class="comment">//获取磁盘缓存的默认根目录</span></span><br><span class="line">        <span class="built_in">NSURL</span> *diskCacheURL = [<span class="built_in">NSURL</span> fileURLWithPath:<span class="keyword">self</span>.diskCachePath isDirectory:<span class="literal">YES</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算用于测试的内容日期key</span></span><br><span class="line">        <span class="built_in">NSURLResourceKey</span> cacheContentDateKey = <span class="built_in">NSURLContentModificationDateKey</span>;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">self</span>.config.diskCacheExpireType) &#123;</span><br><span class="line">            <span class="keyword">case</span> SDImageCacheConfigExpireTypeAccessDate:</span><br><span class="line">                cacheContentDateKey = <span class="built_in">NSURLContentAccessDateKey</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> SDImageCacheConfigExpireTypeModificationDate:</span><br><span class="line">                cacheContentDateKey = <span class="built_in">NSURLContentModificationDateKey</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//记录遍历需要预先获取文件的哪些属性</span></span><br><span class="line">        <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *resourceKeys = @[<span class="built_in">NSURLIsDirectoryKey</span>, cacheContentDateKey, <span class="built_in">NSURLTotalFileAllocatedSizeKey</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// diskCacheURL 和 resourceKeys 这两个变量主要是为了下面生成NSDirectoryEnumerator准备的</span></span><br><span class="line">        <span class="comment">//此枚举器为我们的缓存文件预取有用的属性。</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * 递归地遍历diskCachePath这个文件夹中的所有目录，此处不是直接使用diskCachePath，而是使用其生成的NSURL</span></span><br><span class="line"><span class="comment">          * 此处使用includingPropertiesForKeys:resourceKeys，这样每个file的resourceKeys对应的属性也会在遍历时预先获取到</span></span><br><span class="line"><span class="comment">          * NSDirectoryEnumerationSkipsHiddenFiles表示不遍历隐藏文件</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSDirectoryEnumerator</span> *fileEnumerator = [<span class="keyword">self</span>.fileManager enumeratorAtURL:diskCacheURL</span><br><span class="line">                                                   includingPropertiesForKeys:resourceKeys</span><br><span class="line">                                                                      options:<span class="built_in">NSDirectoryEnumerationSkipsHiddenFiles</span></span><br><span class="line">                                                                 errorHandler:<span class="literal">NULL</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * 获取文件的过期时间，SDWebImage中默认是一个星期</span></span><br><span class="line"><span class="comment">          * expirationDate为过期时间，例如：现在时间是2018/10/16/00:00:00，当前时间减去1个星期，得到</span></span><br><span class="line"><span class="comment">          * 2018/10/09/00:00:00，这个时间为函数中的expirationDate</span></span><br><span class="line"><span class="comment">          * 用这个expirationDate和最后一次修改时间modificationDate比较看谁更晚就行</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">        <span class="built_in">NSDate</span> *expirationDate = [<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:-<span class="keyword">self</span>.config.maxCacheAge];</span><br><span class="line">        <span class="comment">//用来存储对应文件的一些属性，比如文件所需磁盘空间</span></span><br><span class="line">        <span class="built_in">NSMutableDictionary</span>&lt;<span class="built_in">NSURL</span> *, <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *&gt; *cacheFiles = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">        <span class="comment">//记录党建已经使用的磁盘缓存大小</span></span><br><span class="line">        <span class="built_in">NSUInteger</span> currentCacheSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在缓存的目录开始遍历文件.  此次遍历有两个目的:</span></span><br><span class="line">        <span class="comment">//  1. 移除过期的文件</span></span><br><span class="line">        <span class="comment">//  2. 同时存储每个文件的属性（比如该file是否是文件夹、该file所需磁盘大小，修改时间）</span></span><br><span class="line">        <span class="built_in">NSMutableArray</span>&lt;<span class="built_in">NSURL</span> *&gt; *urlsToDelete = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSURL</span> *fileURL <span class="keyword">in</span> fileEnumerator) &#123;</span><br><span class="line">            <span class="built_in">NSError</span> *error;</span><br><span class="line">            <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *resourceValues = [fileURL resourceValuesForKeys:resourceKeys error:&amp;error];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前扫描的是目录，就跳过</span></span><br><span class="line">            <span class="keyword">if</span> (error || !resourceValues || [resourceValues[<span class="built_in">NSURLIsDirectoryKey</span>] boolValue]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 移除过期文件(这里判断过期的方式：对比文件的最后一次修改日期和expirationDate谁更晚，如果expirationDate更晚，就认为该文件已经过期)</span></span><br><span class="line">            <span class="built_in">NSDate</span> *modifiedDate = resourceValues[cacheContentDateKey];</span><br><span class="line">            <span class="keyword">if</span> ([[modifiedDate laterDate:expirationDate] isEqualToDate:expirationDate]) &#123;</span><br><span class="line">                [urlsToDelete addObject:fileURL];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 计算当前已经使用的cache大小,并将对应file的属性存到cacheFiles中</span></span><br><span class="line">            <span class="built_in">NSNumber</span> *totalAllocatedSize = resourceValues[<span class="built_in">NSURLTotalFileAllocatedSizeKey</span>];</span><br><span class="line">            currentCacheSize += totalAllocatedSize.unsignedIntegerValue;</span><br><span class="line">            cacheFiles[fileURL] = resourceValues;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据需要移除文件的url来移除对应file</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSURL</span> *fileURL <span class="keyword">in</span> urlsToDelete) &#123;</span><br><span class="line">            [<span class="keyword">self</span>.fileManager removeItemAtURL:fileURL error:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 如果我们当前cache的大小已经超过了允许配置的缓存大小，那就删除已经缓存的文件</span></span><br><span class="line">         <span class="comment">// 删除策略就是，首先删除修改时间更早的缓存文件</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.config.maxCacheSize &gt; <span class="number">0</span> &amp;&amp; currentCacheSize &gt; <span class="keyword">self</span>.config.maxCacheSize) &#123;</span><br><span class="line">            <span class="comment">// 直接将当前cache大小降到允许最大的cache大小的一般</span></span><br><span class="line">            <span class="comment">//预期的缓存大小</span></span><br><span class="line">            <span class="keyword">const</span> <span class="built_in">NSUInteger</span> desiredCacheSize = <span class="keyword">self</span>.config.maxCacheSize / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 根据文件修改时间来给所有缓存文件排序，按照修改时间越早越在前的规则排序</span></span><br><span class="line">            <span class="built_in">NSArray</span>&lt;<span class="built_in">NSURL</span> *&gt; *sortedFiles = [cacheFiles keysSortedByValueWithOptions:<span class="built_in">NSSortConcurrent</span></span><br><span class="line">                                                                     usingComparator:^<span class="built_in">NSComparisonResult</span>(<span class="keyword">id</span> obj1, <span class="keyword">id</span> obj2) &#123;</span><br><span class="line">                                                                         <span class="keyword">return</span> [obj1[<span class="built_in">NSURLContentModificationDateKey</span>] compare:obj2[<span class="built_in">NSURLContentModificationDateKey</span>]];</span><br><span class="line">                                                                     &#125;];</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 每次删除file后，就计算此时的cache的大小.</span></span><br><span class="line">            <span class="comment">//如果此时的cache大小已经降到期望的大小了，就停止删除文件了</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSURL</span> *fileURL <span class="keyword">in</span> sortedFiles) &#123;</span><br><span class="line">                <span class="keyword">if</span> ([<span class="keyword">self</span>.fileManager removeItemAtURL:fileURL error:<span class="literal">nil</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 获取该文件对应的属性</span></span><br><span class="line">                    <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *resourceValues = cacheFiles[fileURL];</span><br><span class="line">                    <span class="comment">// 根据resourceValues获取该文件所需磁盘空间大小</span></span><br><span class="line">                    <span class="built_in">NSNumber</span> *totalAllocatedSize = resourceValues[<span class="built_in">NSURLTotalFileAllocatedSizeKey</span>];</span><br><span class="line">                    <span class="comment">// 计算当前cache大小</span></span><br><span class="line">                    currentCacheSize -= totalAllocatedSize.unsignedIntegerValue;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (currentCacheSize &lt; desiredCacheSize) &#123;</span><br><span class="line">                        如果当前的缓存小于预期的缓存，结束删除file操作</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果有completionBlock，就在主线程中调用</span></span><br><span class="line">        <span class="keyword">if</span> (completionBlock) &#123;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                completionBlock();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#if SD_UIKIT</span></span><br><span class="line"><span class="comment">//后台删除过期文件</span></span><br><span class="line">- (<span class="keyword">void</span>)backgroundDeleteOldFiles &#123;</span><br><span class="line">    Class <span class="built_in">UIApplicationClass</span> = <span class="built_in">NSClassFromString</span>(<span class="string">@"UIApplication"</span>);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">UIApplicationClass</span> || ![<span class="built_in">UIApplicationClass</span> respondsToSelector:<span class="keyword">@selector</span>(sharedApplication)]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">UIApplication</span> *application = [<span class="built_in">UIApplication</span> performSelector:<span class="keyword">@selector</span>(sharedApplication)];</span><br><span class="line">    <span class="comment">//如果backgroundTask对应的时间结束了，任务还没有处理完成，则直接终止任务</span></span><br><span class="line">    __block <span class="built_in">UIBackgroundTaskIdentifier</span> bgTask = [application beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class="line">        <span class="comment">//通过标记您的位置来清理任何未完成的任务业务</span></span><br><span class="line">        <span class="comment">//完全停止或结束任务。</span></span><br><span class="line">        <span class="comment">//当任务非正常终止的时候，做清理工作</span></span><br><span class="line">        [application endBackgroundTask:bgTask];</span><br><span class="line">        bgTask = <span class="built_in">UIBackgroundTaskInvalid</span>;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动长时间运行的任务并立即返回。</span></span><br><span class="line">    <span class="comment">//图片清理结束以后，处理完成</span></span><br><span class="line">    [<span class="keyword">self</span> deleteOldFilesWithCompletionBlock:^&#123;</span><br><span class="line">        <span class="comment">//清理完成以后，终止任务</span></span><br><span class="line">        [application endBackgroundTask:bgTask];</span><br><span class="line">        bgTask = <span class="built_in">UIBackgroundTaskInvalid</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><p><strong>缓存信息</strong></p><p>获取磁盘缓存使用的大小</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSUInteger</span>)getSize &#123;</span><br><span class="line">    __block <span class="built_in">NSUInteger</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 需要同步操作：等待队列self.ioQueue中的任务执行完后（有可能队列中的任务正在添加图片或者删除图片操作），再进行获取文件大小计算</span></span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSDirectoryEnumerator</span> *fileEnumerator = [<span class="keyword">self</span>.fileManager enumeratorAtPath:<span class="keyword">self</span>.diskCachePath];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSString</span> *fileName <span class="keyword">in</span> fileEnumerator) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *filePath = [<span class="keyword">self</span>.diskCachePath stringByAppendingPathComponent:fileName];</span><br><span class="line">            <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *attrs = [<span class="keyword">self</span>.fileManager attributesOfItemAtPath:filePath error:<span class="literal">nil</span>];</span><br><span class="line">            size += [attrs fileSize];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取磁盘缓存中的图片数量</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (NSUInteger)getDiskCount &#123;</span><br><span class="line">    __block NSUInteger <span class="built_in">count</span> = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">    <span class="keyword">dispatch_sync(self.ioQueue, </span>^&#123;</span><br><span class="line">        NSDirectoryEnumerator *fileEnumerator = [self.fileManager enumeratorAtPath:self.<span class="keyword">diskCachePath];</span></span><br><span class="line"><span class="keyword"> </span>       <span class="built_in">count</span> = fileEnumerator.allObjects.count<span class="comment">;</span></span><br><span class="line">    &#125;)<span class="comment">;</span></span><br><span class="line">    return <span class="built_in">count</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异步计算磁盘缓存的大小</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)calculateSizeWithCompletionBlock:(<span class="keyword">nullable</span> SDWebImageCalculateSizeBlock)completionBlock &#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *diskCacheURL = [<span class="built_in">NSURL</span> fileURLWithPath:<span class="keyword">self</span>.diskCachePath isDirectory:<span class="literal">YES</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSUInteger</span> fileCount = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">NSUInteger</span> totalSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSDirectoryEnumerator</span> *fileEnumerator = [<span class="keyword">self</span>.fileManager enumeratorAtURL:diskCacheURL</span><br><span class="line">                                                   includingPropertiesForKeys:@[<span class="built_in">NSFileSize</span>]</span><br><span class="line">                                                                      options:<span class="built_in">NSDirectoryEnumerationSkipsHiddenFiles</span></span><br><span class="line">                                                                 errorHandler:<span class="literal">NULL</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSURL</span> *fileURL <span class="keyword">in</span> fileEnumerator) &#123;</span><br><span class="line">            <span class="built_in">NSNumber</span> *fileSize;</span><br><span class="line">            [fileURL getResourceValue:&amp;fileSize forKey:<span class="built_in">NSURLFileSizeKey</span> error:<span class="literal">NULL</span>];</span><br><span class="line">            totalSize += fileSize.unsignedIntegerValue;</span><br><span class="line">            fileCount += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (completionBlock) &#123;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                completionBlock(fileCount, totalSize);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>属性Get和Set方法</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//缓存中最大的消耗的内存，这里计算的是内存中的像素个数</span></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)maxMemoryCost &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.memCache.totalCostLimit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置缓存中最大的消耗的内存，这里计算的是内存中的像素个数</span></span><br><span class="line">- (<span class="keyword">void</span>)setMaxMemoryCost:(<span class="built_in">NSUInteger</span>)maxMemoryCost &#123;</span><br><span class="line">    <span class="keyword">self</span>.memCache.totalCostLimit = maxMemoryCost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缓存应持有的对象的的最大数量</span></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)maxMemoryCountLimit &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.memCache.countLimit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置缓存应持有的对象的的最大数量</span></span><br><span class="line">- (<span class="keyword">void</span>)setMaxMemoryCountLimit:(<span class="built_in">NSUInteger</span>)maxCountLimit &#123;</span><br><span class="line">    <span class="keyword">self</span>.memCache.countLimit = maxCountLimit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、介绍&quot;&gt;&lt;a href=&quot;#1、介绍&quot; class=&quot;headerlink&quot; title=&quot;1、介绍&quot;&gt;&lt;/a&gt;1、介绍&lt;/h3&gt;&lt;p&gt;&lt;code&gt;SDImageCache&lt;/code&gt; 是 &lt;code&gt;SDWebImage&lt;/code&gt; 处理图片缓存的类。图
      
    
    </summary>
    
      <category term="iOS" scheme="http://guohuaden.com/categories/iOS/"/>
    
    
      <category term="SDWebImage" scheme="http://guohuaden.com/tags/SDWebImage/"/>
    
  </entry>
  
  <entry>
    <title>读SDWebImage 二 (SDWebImageManager)</title>
    <link href="http://guohuaden.com/2018/10/01/Read-SDWebImage-SDWebImageManager/"/>
    <id>http://guohuaden.com/2018/10/01/Read-SDWebImage-SDWebImageManager/</id>
    <published>2018-10-01T01:38:06.000Z</published>
    <updated>2018-10-24T10:53:38.432Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、整体框架"><a href="#1、整体框架" class="headerlink" title="1、整体框架"></a>1、整体框架</h2><p>看下整体的框架图：</p><p><img src="http://obzx0h1re.bkt.clouddn.com/SDWebImageClassDiagram.png" alt="SDWebImage框架"><br>从图中可以更清晰的看出，<code>SDWebImage</code>库是围绕<code>SDWebImageManager</code>、<code>SDWebImageCache</code>、<code>SDWebImageDownloader</code>三个类展开的，而这三个类又是以<code>SDWebImageManager</code>作为核心类。</p><p>下面就重点分析<code>SDWebImageManager</code>：<br><code>SDWebImageManager</code>是 <code>SDWebImage</code> 的管理以及操作类。也是<code>SDWebImage</code>的核心类，拥有一个<code>SDWebImageCache</code> 和 <code>SDWebImageDownloader</code> 属性，分别用于图片缓存和下载处理。</p><h2 id="2、SDWebImageManager类分析"><a href="#2、SDWebImageManager类分析" class="headerlink" title="2、SDWebImageManager类分析"></a>2、<code>SDWebImageManager</code>类分析</h2><h3 id="先看下-h文件"><a href="#先看下-h文件" class="headerlink" title="先看下.h文件"></a>先看下.h文件</h3><h3 id="2-1、公共枚举"><a href="#2-1、公共枚举" class="headerlink" title="2.1、公共枚举"></a>2.1、公共枚举</h3><p>该枚举定义了图像加载的可选项:<br><strong>options 选项（枚举类型）</strong></p><blockquote><p><code>SDWebImageRetryFailed = 1 &lt;&lt; 0,</code><br>默认情况下当通过URL下载图片失败后，该URL就被加入黑名单，之后SDWebImage不会再去尝试下载。此标志作用就是禁用该黑名单，也就是说使用SDWebImageRetryFailed后，图片下载失败仍会尝试下载<br><code>SDWebImageLowPriority = 1 &lt;&lt; 1,</code><br>默认情况下图片在UI交互期间下载，此标志的作用就是禁用该功能。例如：在UIScrollView减速时导致延迟下载。<br><code>SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2,</code><br>此标志作用是：图片下载完成后仅缓存到内存，不缓存在磁盘上<br><code>SDWebImageProgressiveDownload = 1 &lt;&lt; 3,</code><br>此标志启用渐进式下载，图像在下载过程中逐步显示，就像浏览器一样。<br>默认情况下，图像仅在完全下载后显示。<br><code>SDWebImageRefreshCached = 1 &lt;&lt; 4,</code><br>即使缓存中存在该图片，也尊重HTTP响应缓存控制，在需要时从远程刷新图片。<br>磁盘缓存将由 <code>NSURLCache</code> 替代 <code>SDWebImage</code> 去处理，这样也将导致性能略有下降。<br>该选项有助于处理同一个URL请求但更换图片的情况，例如Facebook图形api配置文件的图片。<br>如果刷新了缓存图片，则使用缓存图片调用一次完成block代码块，再使用最终的图片调用完成block代码块。<br>仅当你无法使用嵌入式缓存清除参数使URL保持静态时，才使用该标志。<br><code>SDWebImageContinueInBackground = 1 &lt;&lt; 5,</code><br>在<code>iOS 4+</code>中，如果app进入后台也继续下载图片，这是通过询问系统实现的。<br>在后台有额外的时间让请求完成，如果后台任务到期，则操作被取消。<br><code>SDWebImageHandleCookies = 1 &lt;&lt; 6,</code><br>通过<code>NSMutableURLRequest.HTTPShouldHandleCookies = YES</code>设置处理在 <code>NSHTTPCookieStore</code>中的cookies。<br><code>SDWebImageAllowInvalidSSLCertificates = 1 &lt;&lt; 7,</code><br>启用允许不受信任的SSL证书（用于测试目的，在生产中谨慎使用）<br><code>SDWebImageHighPriority = 1 &lt;&lt; 8,</code><br>默认情况下，图像按其排队顺序加载，此标志将它们移动到队列的前面<br><code>SDWebImageDelayPlaceholder = 1 &lt;&lt; 9,</code><br>默认情况下，加载图像时会加载占位符。 此标志将延迟加载占位符图像，直到图像加载完毕。<br><code>SDWebImageTransformAnimatedImage = 1 &lt;&lt; 10,</code><br>我们通常不会在动画图像上调用transformDownloadedImage委托方法，因为大多数转换代码会破坏它。如果使用必须使用此标志来转换它们。<br><code>SDWebImageAvoidAutoSetImage = 1 &lt;&lt; 11,</code><br>默认情况下，下载后会将图像添加到imageView。 但在某些情况下，我们想要<br>在设置图像之前手动处理一些东西（例如应用滤镜或添加交叉渐变动画）请使用此标志<br><code>SDWebImageScaleDownLargeImages = 1 &lt;&lt; 12,</code><br>默认情况下，图像会根据其原始大小进行解码。 在iOS上，此标志将缩小<br>图像尺寸与设备的受限内存兼容。（如果设置了“SDWebImageProgressiveDownload”标志，则停用缩小比例。）<br><code>SDWebImageQueryDataWhenInMemory = 1 &lt;&lt; 13,</code><br>默认情况下，当图像缓存在内存中时，我们不查询磁盘数据。 此掩码可以强制同时查询磁盘数据。<br>建议将此标志与<code>SDWebImageQueryDiskSync</code>一起使用，以确保图像在同一个runloop中加载。<br><code>SDWebImageQueryDiskSync = 1 &lt;&lt; 14,</code><br>默认情况下，我们同步查询内存缓存，异步查询磁盘缓存。 此掩码可以强制同步查询磁盘缓存，以确保在同一个runloop中加载映像。<br>如果禁用内存缓存或在某些其他情况下，此标志可以避免在单元重用期间闪烁。<br><code>SDWebImageFromCacheOnly = 1 &lt;&lt; 15,</code><br>默认情况下，当缓存丢失时，将从网络下载映像。此标志可以阻止网络仅从缓存加载。<br><code>SDWebImageForceTransition = 1 &lt;&lt; 16</code><br>默认情况下，当您使用 <code>SDWebImageTransition</code> 在图像加载完成后进行某些视图转换时，此转换仅适用于从网络下载图像。 此掩码也可以强制为内存和磁盘缓存应用视图转换。</p></blockquote><h3 id="2-2、公共类型定义"><a href="#2-2、公共类型定义" class="headerlink" title="2.2、公共类型定义"></a>2.2、公共类型定义</h3><p>四个回调代码块：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//用于外部分类中完成回调的block</span><br><span class="line">typedef void(^<span class="type">SDExternalCompletionBlock</span>)(<span class="type">UIImage</span> * _Nullable image, <span class="type">NSError</span> * _Nullable error, <span class="type">SDImageCacheType</span> cacheType, <span class="type">NSURL</span> * _Nullable imageURL);</span><br><span class="line"></span><br><span class="line">//用于该类内部完成回调的block</span><br><span class="line">typedef void(^<span class="type">SDInternalCompletionBlock</span>)(<span class="type">UIImage</span> * _Nullable image, <span class="type">NSData</span> * _Nullable data, <span class="type">NSError</span> * _Nullable error, <span class="type">SDImageCacheType</span> cacheType, <span class="type">BOOL</span> finished, <span class="type">NSURL</span> * _Nullable imageURL);</span><br><span class="line"></span><br><span class="line">//将url处理成缓存图像用的key的方法，返回字符串作为存储时的key，可以删除url中的产讯字段</span><br><span class="line">//用于在使用某url生成key之前，先把url的某些动态信息除掉，以便可以用简洁一点的url来生成key。因此这个block的内容就是对url的操作，返回值是一个简洁版的url。</span><br><span class="line">typedef <span class="type">NSString</span> * _Nullable(^<span class="type">SDWebImageCacheKeyFilterBlock</span>)(<span class="type">NSURL</span> * _Nullable url);</span><br><span class="line"></span><br><span class="line">//将图像缓存到磁盘的解码算法，返回的是data。</span><br><span class="line">typedef <span class="type">NSData</span> * _Nullable(^<span class="type">SDWebImageCacheSerializerBlock</span>)(<span class="type">UIImage</span> * _Nonnull image, <span class="type">NSData</span> * _Nullable data, <span class="type">NSURL</span> * _Nullable imageURL);</span><br></pre></td></tr></table></figure><h3 id="2-3、协议：SDWebImageManagerDelegate"><a href="#2-3、协议：SDWebImageManagerDelegate" class="headerlink" title="2.3、协议：SDWebImageManagerDelegate"></a>2.3、协议：<code>SDWebImageManagerDelegate</code></h3><p>使用协议的优点在于：</p><ol><li>不需要担心循环引用问题</li><li>有利于程序的结构化与层次化</li><li>有利于代码的封装</li></ol><p><code>SDWebImageManager</code>提供的三个都是可选协议，这也是我们平时常用的方式，遵守协议的类根据需要实现协议方法，不需要编译器警告提示。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当缓存没有发现当前图片，会查看调用者是否实现该方法，如果返回NO，则不会继续下载该图片</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param imageManager 当前的 `SDWebImageManager`</span></span><br><span class="line"><span class="comment"> * @param imageURL    应该下载的图像的URL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return  返回结果，返回NO时阻止去下载，如果不执行，默认的是YES</span></span><br><span class="line"><span class="comment"> Return NO to prevent the downloading of the image on cache misses. If not implemented, YES is implied.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)imageManager:(<span class="keyword">nonnull</span> SDWebImageManager *)imageManager shouldDownloadImageForURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)imageURL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当图片下载失败时，会查看调用者是否将该图片URL标记为失败，如果返回YES，则将此URL标记为失败。</span></span><br><span class="line"><span class="comment"> 注意：如果委托实现此方法，将不会使用内置方式根据错误代码将URL标记为失败;</span></span><br><span class="line"><span class="comment"> @param imageManager 当前的`SDWebImageManager`</span></span><br><span class="line"><span class="comment"> @param imageURL 图像的网址</span></span><br><span class="line"><span class="comment"> @param error URL下载的错误</span></span><br><span class="line"><span class="comment"> @return 是否阻止失败的URL再去下载，返回YES，将URL标记为失败，不再下载</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)imageManager:(<span class="keyword">nonnull</span> SDWebImageManager *)imageManager shouldBlockFailedURL:(<span class="keyword">nonnull</span> <span class="built_in">NSURL</span> *)imageURL withError:(<span class="keyword">nonnull</span> <span class="built_in">NSError</span> *)error;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 允许在下载后立即转换图像，然后将图像缓存到磁盘和内存中。</span></span><br><span class="line"><span class="comment"> * 注意：从全局队列调用此方法，以便不阻止主线程。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param imageManager  当前的`SDWebImageManager`</span></span><br><span class="line"><span class="comment"> * @param image        要转换的图像</span></span><br><span class="line"><span class="comment"> * @param imageURL     要转换的图像的网址</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return 转换后的图像对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)imageManager:(<span class="keyword">nonnull</span> SDWebImageManager *)imageManager transformDownloadedImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image withURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)imageURL;</span><br></pre></td></tr></table></figure><h3 id="2-4、协议：属性和方法"><a href="#2-4、协议：属性和方法" class="headerlink" title="2.4、协议：属性和方法"></a>2.4、协议：属性和方法</h3><p>声明属性：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代理</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="keyword">id</span> &lt;SDWebImageManagerDelegate&gt; delegate;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图片缓存</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) SDImageCache *imageCache;</span><br><span class="line"><span class="comment">//图片下载</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) SDWebImageDownloader *imageDownloader;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缓存过滤器代码块（每次SDWebImageManager将URL转换为缓存所需要的key时使用的代码块，这个可以用于删除图片URL的动态部分）</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) SDWebImageCacheKeyFilterBlock cacheKeyFilter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//高速缓存序列化器，用于将解码图像（愿下载数据）转换为用于存储到磁盘高速缓存的世纪数据的代码块，如果返回nil，则表示从图像实例生成数据。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) SDWebImageCacheSerializerBlock cacheSerializer;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局SDWebImageManager实例。</span></span><br><span class="line">+ (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)sharedManager;</span><br><span class="line"></span><br><span class="line"><span class="comment">//允许指定与图像管理器一起使用的缓存和图像下载器的实例。</span></span><br><span class="line"><span class="comment">//返回带有指定缓存和下载器的`SDWebImageManager`的新实例。</span></span><br><span class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)initWithCache:(<span class="keyword">nonnull</span> SDImageCache *)cache downloader:(<span class="keyword">nonnull</span> SDWebImageDownloader *)downloader <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果缓存中不存在，就下载给定URL的图像，存在就返回缓存的版本</span></span><br><span class="line"><span class="comment"> Downloads the image at the given URL if not present in cache or return the cached version otherwise.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param url           图像的URL</span></span><br><span class="line"><span class="comment"> * @param options       用于指定此请求的选项掩码</span></span><br><span class="line"><span class="comment"> * @param progressBlock 下载图像时调用的代码块（在后台队列上执行的进度代码块）</span></span><br><span class="line"><span class="comment"> *                      </span></span><br><span class="line"><span class="comment"> * @param completedBlock  操作完成时调用的代码块</span></span><br><span class="line"><span class="comment">* @return 返回 SDWebImageDownloaderOperation 的一个实例</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">completedBlock 即：typedef void(^SDInternalCompletionBlock)(UIImage * _Nullable image, NSData * _Nullable data, NSError * _Nullable error, SDImageCacheType cacheType, BOOL finished, NSURL * _Nullable imageURL);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> 该代码块没有返回值，将请求到的UIImage作为第一个参数；NSData作为第二个参数；如果出错，则image参数为nil，第三个参数可能包含NSError；第四个参数是一个`SDImageCacheType`枚举，指明图像的来源（本地缓存中检索、内存缓存、网络下载。）第五个参数用来判断下载是否完成；最后一个参数为原始图像的URL</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;SDWebImageOperation&gt;)loadImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">                                              options:(SDWebImageOptions)options</span><br><span class="line">                                             progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                            completed:(<span class="keyword">nullable</span> SDInternalCompletionBlock)completedBlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将图像保存到给定的URL的缓存中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param image要缓存的图像</span></span><br><span class="line"><span class="comment"> * @param url   图像的URL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">- (<span class="keyword">void</span>)saveImageToCache:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image forURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">//取消当前所有的操作</span></span><br><span class="line">- (<span class="keyword">void</span>)cancelAll;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//检查一个或多个正在运行的操作</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isRunning;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  异步检查图像是否已被缓存</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param url              图像 url</span></span><br><span class="line"><span class="comment"> *  @param completionBlock  检查完成时要执行的代码块</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  @note 完成代码块总是在主队列上执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)cachedImageExistsForURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">                     completion:(<span class="keyword">nullable</span> SDWebImageCheckCacheCompletionBlock)completionBlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  异步检查图像是否已仅缓存在磁盘上</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param url             图像 url</span></span><br><span class="line"><span class="comment"> *  @param completionBlock  检查完成时要执行的代码块</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @note 完成代码块总是在主队列上执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)diskImageExistsForURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">                   completion:(<span class="keyword">nullable</span> SDWebImageCheckCacheCompletionBlock)completionBlock;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回给定URL的缓存key</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)cacheKeyForURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url;</span><br></pre></td></tr></table></figure></p><p>——————</p><h3 id="再看-m文件-的声明"><a href="#再看-m文件-的声明" class="headerlink" title="再看.m文件 的声明"></a>再看.m文件 的声明</h3><h3 id="2-5-SDWebImageCombinedOperation的属性声明和协议方法实现"><a href="#2-5-SDWebImageCombinedOperation的属性声明和协议方法实现" class="headerlink" title="2.5 SDWebImageCombinedOperation的属性声明和协议方法实现"></a>2.5 <code>SDWebImageCombinedOperation</code>的属性声明和协议方法实现</h3><p>定义一个<code>SDWebImageCombinedOperation</code>类，该类遵循 <code>SDWebImageOperation</code>协议 ，该协议仅定义了一个cancel的方法。<br>之所以在这里定义这个类，而不是直接使用<code>SDWebImageDownloaderOperation</code>类来表示下载任务，原因有两方面：</p><ol><li>为了可以在下面使用中修改<code>cancelled</code>属性的值，在<code>SDWebImageDownloaderOperation</code>中 <code>cancelled</code>属于对外是只读的</li><li>一个操作表示一个获取图像的动作，通常优先从缓存中取出图像，缓存中没鱼哦才需要下载，而<code>SDWebImageDownloderOperation</code>是专门用来下载的，没有包含查找缓存的功能。</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SDWebImageCombinedOperation</span> : <span class="title">NSObject</span> &lt;<span class="title">SDWebImageOperation</span>&gt;</span></span><br><span class="line"><span class="comment">//是否已取消</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>, <span class="keyword">getter</span> = isCancelled) <span class="built_in">BOOL</span> cancelled;</span><br><span class="line"><span class="comment">//下载任务</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) SDWebImageDownloadToken *downloadToken;</span><br><span class="line"><span class="comment">//取消操作</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">NSOperation</span> *cacheOperation;</span><br><span class="line"><span class="comment">//管理类</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) SDWebImageManager *manager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>实现<code>SDWebImageOperation</code>协议的cancel的方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SDWebImageCombinedOperation</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)cancel &#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">//设置为取消状态</span></span><br><span class="line">        <span class="keyword">self</span>.cancelled = <span class="literal">YES</span>;</span><br><span class="line">        <span class="comment">//取消的操作存在，就执行该取消操作，并置为nil</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.cacheOperation) &#123;</span><br><span class="line">            [<span class="keyword">self</span>.cacheOperation cancel];</span><br><span class="line">            <span class="keyword">self</span>.cacheOperation = <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在管理类的下载任务中取消该下载任务</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.downloadToken) &#123;</span><br><span class="line">            <span class="comment">//在下载SDWebImageDownloader类中执行取消任务操作</span></span><br><span class="line">            [<span class="keyword">self</span>.manager.imageDownloader cancel:<span class="keyword">self</span>.downloadToken];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//安全移除该操作</span></span><br><span class="line">        [<span class="keyword">self</span>.manager safelyRemoveOperationFromRunning:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)safelyRemoveOperationFromRunning:(<span class="keyword">nullable</span> SDWebImageCombinedOperation*)operation &#123;</span><br><span class="line">    <span class="keyword">if</span> (!operation) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加锁是为了安全，防止正在移除该操作时有变化</span></span><br><span class="line">    LOCK(<span class="keyword">self</span>.runningOperationsLock);</span><br><span class="line">    [<span class="keyword">self</span>.runningOperations removeObject:operation];</span><br><span class="line">    UNLOCK(<span class="keyword">self</span>.runningOperationsLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-SDWebImageManager的属性声明"><a href="#2-6-SDWebImageManager的属性声明" class="headerlink" title="2.6 SDWebImageManager的属性声明"></a>2.6 <code>SDWebImageManager</code>的属性声明</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SDWebImageManager</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>, <span class="keyword">nonnull</span>) SDImageCache *imageCache;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>, <span class="keyword">nonnull</span>) SDWebImageDownloader *imageDownloader;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSMutableSet</span>&lt;<span class="built_in">NSURL</span> *&gt; *failedURLs;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) dispatch_semaphore_t failedURLsLock; <span class="comment">// a lock to keep the access to `failedURLs` thread-safe</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSMutableSet</span>&lt;SDWebImageCombinedOperation *&gt; *runningOperations;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) dispatch_semaphore_t runningOperationsLock; <span class="comment">// a lock to keep the access to `runningOperations` thread-safe</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p><code>imageCache</code> 和 <code>imageDownloader</code> 在.h文件中已经声明，但是只读类型。这里重复声明成读写类型，实现外部为只读，内部为读写类型。</p><p>两个可变集合体<code>failedURLs</code> 和 <code>runningOperations</code> 前者存储<code>NSURL</code> 类型，记录失败的urls，后者存储<code>SDWebImageCombinedOperation</code>类型，记录正在运行的操作。</p><p>两个信号量<code>failedURLsLock</code> 和 <code>runningOperationsLock</code>锁，为了保持访问<code>failedURLs</code> 和 <code>runningOperations</code>线程安全的。</p><h3 id="2-7、SDWebImageManager的方法实现"><a href="#2-7、SDWebImageManager的方法实现" class="headerlink" title="2.7、SDWebImageManager的方法实现"></a>2.7、<code>SDWebImageManager</code>的方法实现</h3><h4 id="2-7-1、初始化"><a href="#2-7-1、初始化" class="headerlink" title="2.7.1、初始化"></a>2.7.1、初始化</h4><p>三个初始化方法，单例模式确保全局只有一个实例，避免每次调用时创建新的实例。</p><p>使用GCD中的<code>dispatch_once</code>创建的实例对象必须确保只有一个，所以使用static修饰 <code>static dispatch_once_t once; static id instance;</code><br><code>dispatch_once</code>可以简化代码且保证线程安全，开发者无需担心加锁或同步。所有问题都在GCD底层处理。此外，<code>dispatch_once</code>更高效。它没有使用重量级的同步机制。使用同步机制，每次运行代码都需要获取锁。<code>dispatch_once</code>采用“原子访问”来查询标记，判断代码是否执行过。</p><p><code>[self new]</code>是一种比较老式的写法，而<code>alloc/init</code>的引入则是因为<code>new</code>不够灵活，因为使用<code>new</code>的话，会使得初始化方法被固定死只能调用<code>init</code>。而这里就是使用的<code>new</code>方法，所以调用的顺序只能是<code>sharedManager ---&gt; init ---&gt; initWithCache: downloader:</code>。</p><p>在<code>init</code>初始化中，可以看出<code>cache</code> 和 <code>downloader</code>也是单例模式，其实也是使用的<code>new</code>方法，原理和这里的相同。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单例模式</span></span><br><span class="line">+ (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)sharedManager &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> once;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">id</span> instance;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;once, ^&#123;</span><br><span class="line">        instance = [<span class="keyword">self</span> new];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化 cache 和 downloader</span></span><br><span class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    SDImageCache *cache = [SDImageCache sharedImageCache];</span><br><span class="line">    SDWebImageDownloader *downloader = [SDWebImageDownloader sharedDownloader];</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithCache:cache downloader:downloader];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里实现一些属性的初始化。</span></span><br><span class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)initWithCache:(<span class="keyword">nonnull</span> SDImageCache *)cache downloader:(<span class="keyword">nonnull</span> SDWebImageDownloader *)downloader &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) &#123;</span><br><span class="line">        _imageCache = cache;</span><br><span class="line">        _imageDownloader = downloader;</span><br><span class="line">        _failedURLs = [<span class="built_in">NSMutableSet</span> new];</span><br><span class="line">        _failedURLsLock = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">        _runningOperations = [<span class="built_in">NSMutableSet</span> new];</span><br><span class="line">        _runningOperationsLock = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-7-2、功能实现方法"><a href="#2-7-2、功能实现方法" class="headerlink" title="2.7.2、功能实现方法"></a>2.7.2、功能实现方法</h4><ol><li><p>通过URL获取缓存时使用的key<br>利用Image的URL生成一个缓存时需要的key.<br>如果检测到cacheKeyFilter不为空时,利用cacheKeyFilter来处理URL生成一个key；否则直接返回URL的string内容,当做key.</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)cacheKeyForURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url &#123;</span><br><span class="line">    <span class="keyword">if</span> (!url) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">@""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.cacheKeyFilter) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.cacheKeyFilter(url);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> url.absoluteString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>图像放缩操作：根据图片中的图片组 或 scale 重新计算返回图片。该方法专门使用了一个类（<code>SDWebImageCompat</code>）来实现。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)scaledImageForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key image:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image &#123;</span><br><span class="line">    <span class="keyword">return</span> SDScaledImageForKey(key, image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>缓存图像</p></li></ol><p>通过URL缓存图像到内存<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)cachedImageExistsForURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">                     completion:(<span class="keyword">nullable</span> SDWebImageCheckCacheCompletionBlock)completionBlock &#123;</span><br><span class="line">    <span class="comment">//获取缓存所需的key</span></span><br><span class="line">    <span class="built_in">NSString</span> *key = [<span class="keyword">self</span> cacheKeyForURL:url];</span><br><span class="line">    <span class="comment">//判断内存中是否已缓存该图像</span></span><br><span class="line">    <span class="built_in">BOOL</span> isInMemoryCache = ([<span class="keyword">self</span>.imageCache imageFromMemoryCacheForKey:key] != <span class="literal">nil</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果已经缓存，在主线程中执行完成回调代码块</span></span><br><span class="line">    <span class="keyword">if</span> (isInMemoryCache) &#123;</span><br><span class="line">        <span class="comment">// making sure we call the completion block on the main queue</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="keyword">if</span> (completionBlock) &#123;</span><br><span class="line">                completionBlock(<span class="literal">YES</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果还未缓存，则调用 diskImageExistsWithKey，该方法会将图像缓存到磁盘中（在存储之前也会判断磁盘中是否已缓存该图像），该方法在异步线程执行。</span></span><br><span class="line">    [<span class="keyword">self</span>.imageCache diskImageExistsWithKey:key completion:^(<span class="built_in">BOOL</span> isInDiskCache) &#123;</span><br><span class="line">        <span class="comment">// the completion block of checkDiskCacheForImageWithKey:completion: is always called on the main queue, no need to further dispatch</span></span><br><span class="line">        <span class="keyword">if</span> (completionBlock) &#123;</span><br><span class="line">            completionBlock(isInDiskCache);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将图像缓存到磁盘中<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)diskImageExistsForURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">                   completion:(<span class="keyword">nullable</span> SDWebImageCheckCacheCompletionBlock)completionBlock &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *key = [<span class="keyword">self</span> cacheKeyForURL:url];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.imageCache diskImageExistsWithKey:key completion:^(<span class="built_in">BOOL</span> isInDiskCache) &#123;</span><br><span class="line">        <span class="comment">// the completion block of checkDiskCacheForImageWithKey:completion: is always called on the main queue, no need to further dispatch</span></span><br><span class="line">        <span class="keyword">if</span> (completionBlock) &#123;</span><br><span class="line">            completionBlock(isInDiskCache);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将图像缓存到内存中<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)saveImageToCache:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image forURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url &#123;</span><br><span class="line">    <span class="keyword">if</span> (image &amp;&amp; url) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *key = [<span class="keyword">self</span> cacheKeyForURL:url];</span><br><span class="line">        [<span class="keyword">self</span>.imageCache storeImage:image forKey:key toDisk:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="4"><li><p>取消掉所有正在执行的操作Operation</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)cancelAll &#123;</span><br><span class="line">    LOCK(self.runningOperations<span class="class">Lock);</span></span><br><span class="line">    NSSet&lt;SDWebImageCombinedOperation *&gt; *copiedOperations = [self.runningOperations copy];</span><br><span class="line">    UNLOCK(self.runningOperations<span class="class">Lock);</span></span><br><span class="line">    [copiedOperations makeObjectsPerformSelector:@selector(cancel)]; // This will call `safelyRemoveOperationFromRunning:`<span class="built_in"> and </span>remove from the array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>判断是否有正在运行的操作Operation</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">BOOL)isRunning </span>&#123;</span><br><span class="line">    <span class="keyword">BOOL </span>isRunning = NO<span class="comment">;</span></span><br><span class="line">    LOCK(self.runningOperationsLock)<span class="comment">;</span></span><br><span class="line">    isRunning = (self.runningOperations.count &gt; <span class="number">0</span>)<span class="comment">;</span></span><br><span class="line">    UNLOCK(self.runningOperationsLock)<span class="comment">;</span></span><br><span class="line">    return isRunning<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>安全移除正在运行的操作Operation</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)safelyRemoveOperationFromRunning:(<span class="keyword">nullable</span> SDWebImageCombinedOperation*)operation &#123;</span><br><span class="line">    <span class="keyword">if</span> (!operation) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LOCK(<span class="keyword">self</span>.runningOperationsLock);</span><br><span class="line">    [<span class="keyword">self</span>.runningOperations removeObject:operation];</span><br><span class="line">    UNLOCK(<span class="keyword">self</span>.runningOperationsLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>回调方法</p></li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)callCompletionBlockForOperation:(<span class="keyword">nullable</span> SDWebImageCombinedOperation*)operation</span><br><span class="line">                             completion:(<span class="keyword">nullable</span> SDInternalCompletionBlock)completionBlock</span><br><span class="line">                                  error:(<span class="keyword">nullable</span> <span class="built_in">NSError</span> *)error</span><br><span class="line">                                    url:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url &#123;</span><br><span class="line">    [<span class="keyword">self</span> callCompletionBlockForOperation:operation completion:completionBlock image:<span class="literal">nil</span> data:<span class="literal">nil</span> error:error cacheType:SDImageCacheTypeNone finished:<span class="literal">YES</span> url:url];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)callCompletionBlockForOperation:(<span class="keyword">nullable</span> SDWebImageCombinedOperation*)operation</span><br><span class="line">                             completion:(<span class="keyword">nullable</span> SDInternalCompletionBlock)completionBlock</span><br><span class="line">                                  image:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image</span><br><span class="line">                                   data:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)data</span><br><span class="line">                                  error:(<span class="keyword">nullable</span> <span class="built_in">NSError</span> *)error</span><br><span class="line">                              cacheType:(SDImageCacheType)cacheType</span><br><span class="line">                               finished:(<span class="built_in">BOOL</span>)finished</span><br><span class="line">                                    url:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url &#123;</span><br><span class="line">    dispatch_main_async_safe(^&#123;</span><br><span class="line">        <span class="keyword">if</span> (operation &amp;&amp; !operation.isCancelled &amp;&amp; completionBlock) &#123;</span><br><span class="line">            completionBlock(image, data, error, cacheType, finished, url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>通过url建立一个operation用来下载图片. 返回operation<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><span class="line">- (id &lt;SDWebImageOperation&gt;)<span class="string">loadImageWithURL:</span>(nullable NSURL *)url</span><br><span class="line"><span class="symbol">                                     options:</span>(SDWebImageOptions)options</span><br><span class="line"><span class="symbol">                                    progress:</span>(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line"><span class="symbol">                                   completed:</span>(nullable SDInternalCompletionBlock)completedBlock &#123;</span><br><span class="line">    <span class="comment">// Invoking this method without a completedBlock is pointless</span></span><br><span class="line">    NSAssert(completedBlock != nil, @<span class="string">"If you mean to prefetch the image, use -[SDWebImagePrefetcher prefetchURLs] instead"</span>);</span><br><span class="line">     <span class="comment">//在没有completedBlock的情况下调用此方法毫无意义 ， NSAssert（completedBlock！= nil，@“如果你的意思是预取图像，请使用 - [SDWebImagePrefetcher prefetchURLs]代替”）;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Very common mistake is to send the URL using NSString object instead of NSURL. For some strange reason, Xcode won't</span></span><br><span class="line">    <span class="comment">// throw any warning for this type mismatch. Here we failsafe this error by allowing URLs to be passed as NSString.</span></span><br><span class="line">  （非常常见的错误是使用NSString对象而不是NSURL发送URL。 出于某些奇怪的原因，Xcode不会抛出此类型不匹配的任何警告。在这里，我们通过允许URL作为NSString传递来确保此错误。）</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> ([url <span class="string">isKindOfClass:</span>NSString.<span class="keyword">class</span>]) &#123;</span><br><span class="line">        <span class="comment">//如果传入的url是字符串类型，则转换成NSURL类型</span></span><br><span class="line">        url = [NSURL <span class="string">URLWithString:</span>(NSString *)url];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prevents app crashing on argument type error like sending NSNull instead of NSURL</span></span><br><span class="line">    <span class="comment">//防止应用程序崩溃类型错误，如发送NSNull而不是NSURL，则url置为nil</span></span><br><span class="line">    <span class="keyword">if</span> (![url <span class="string">isKindOfClass:</span>NSURL.<span class="keyword">class</span>]) &#123;</span><br><span class="line">        url = nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    初始化一个SDWebImageCombinedOperation对象</span><br><span class="line">    SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation <span class="keyword">new</span>];</span><br><span class="line">    <span class="comment">//设置它的SDWebImageManager 等于self</span></span><br><span class="line">    operation.manager = self;</span><br><span class="line"></span><br><span class="line">    BOOL isFailedUrl = NO;</span><br><span class="line">    <span class="comment">//如果url存在，判断该url是否失败过，并赋值给isFailedUrl；加锁是为了安全，防止在判断的过程中被其他线程修改</span></span><br><span class="line">    <span class="keyword">if</span> (url) &#123;</span><br><span class="line">        LOCK(self.failedURLsLock);</span><br><span class="line">        isFailedUrl = [self.failedURLs <span class="string">containsObject:</span>url];</span><br><span class="line">        UNLOCK(self.failedURLsLock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断条件：如果url不存在，或者options不是SDWebImageRetryFailed（失败重试）并且isFailedUrl 为 YES。就回调一个error的block （异常处理），并返回operation</span></span><br><span class="line">    <span class="comment">//error为：[NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil]</span></span><br><span class="line">    <span class="keyword">if</span> (url.absoluteString.length == <span class="number">0</span> || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) &#123;</span><br><span class="line">        [self <span class="string">callCompletionBlockForOperation:</span>operation <span class="string">completion:</span>completedBlock <span class="string">error:</span>[NSError <span class="string">errorWithDomain:</span>NSURLErrorDomain <span class="string">code:</span>NSURLErrorFileDoesNotExist <span class="string">userInfo:</span>nil] <span class="string">url:</span>url];</span><br><span class="line">        <span class="keyword">return</span> operation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建互斥锁，执行runningOperations添加operation操作</span></span><br><span class="line">    LOCK(self.runningOperationsLock);</span><br><span class="line">    [self.runningOperations <span class="string">addObject:</span>operation];</span><br><span class="line">    UNLOCK(self.runningOperationsLock);</span><br><span class="line">    <span class="comment">//获取缓存所需要的key</span></span><br><span class="line">    NSString *key = [self <span class="string">cacheKeyForURL:</span>url];</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 下面都是判断我们的cacheOptions里包含哪些SDWebImageOptions,然后给我们的cacheOptions相应的添加对应的SDImageCacheOptions. cacheOptions |= SDImageCacheQueryDataWhenInMemory这种表达式的意思等同于cacheOptions = cacheOptions | SDImageCacheQueryDataWhenInMemory</span></span><br><span class="line">     </span><br><span class="line">    SDImageCacheOptions cacheOptions = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (options &amp; SDWebImageQueryDataWhenInMemory) cacheOptions |= SDImageCacheQueryDataWhenInMemory;</span><br><span class="line">    <span class="keyword">if</span> (options &amp; SDWebImageQueryDiskSync) cacheOptions |= SDImageCacheQueryDiskSync;</span><br><span class="line">    <span class="keyword">if</span> (options &amp; SDWebImageScaleDownLargeImages) cacheOptions |= SDImageCacheScaleDownLargeImages;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//弱引用</span></span><br><span class="line">    __weak SDWebImageCombinedOperation *weakOperation = operation;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *如果图片是从内存加载，则返回的cacheOperation是nil，</span></span><br><span class="line"><span class="comment">    *如果是从磁盘加载，则返回的cacheOperation是`NSOperation`对象。</span></span><br><span class="line"><span class="comment">    *如果是从网络加载，则返回的cacheOperation对象是`SDWebImageDownloaderOperation`对象。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    operation.cacheOperation = [self.imageCache <span class="string">queryCacheOperationForKey:</span>key <span class="string">options:</span>cacheOptions <span class="string">done:</span>^(UIImage *cachedImage, NSData *cachedData, SDImageCacheType cacheType) &#123;</span><br><span class="line">        <span class="comment">//强引用，防止被提前释放</span></span><br><span class="line">        __strong __typeof(weakOperation) strongOperation = weakOperation;</span><br><span class="line">        <span class="comment">//operation不存在或者已经被取消，返回并移除该operation对象</span></span><br><span class="line">        <span class="keyword">if</span> (!strongOperation || strongOperation.isCancelled) &#123;</span><br><span class="line">            [self <span class="string">safelyRemoveOperationFromRunning:</span>strongOperation];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Check whether we should download image from network</span></span><br><span class="line">        <span class="comment">//检查是否应该从网络下载图像</span></span><br><span class="line">        BOOL shouldDownload = (!(options &amp; SDWebImageFromCacheOnly))</span><br><span class="line">            &amp;&amp; (!cachedImage || options &amp; SDWebImageRefreshCached)</span><br><span class="line">            &amp;&amp; (![self.delegate <span class="string">respondsToSelector:</span><span class="meta">@selector</span>(<span class="string">imageManager:</span><span class="string">shouldDownloadImageForURL:</span>)] || [self.delegate <span class="string">imageManager:</span>self <span class="string">shouldDownloadImageForURL:</span>url]);</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//应该从网络下载图像  </span></span><br><span class="line">        <span class="keyword">if</span> (shouldDownload) &#123;</span><br><span class="line">            <span class="comment">//如果缓存图像存在，但options设置为SDWebImageRetryFailed。则先返回缓存图像</span></span><br><span class="line">            <span class="keyword">if</span> (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</span><br><span class="line">                <span class="comment">// If image was found in the cache but SDWebImageRefreshCached is provided, notify about the cached image</span></span><br><span class="line">                <span class="comment">// AND try to re-download it in order to let a chance to NSURLCache to refresh it from server.</span></span><br><span class="line">                <span class="comment">//构建回调block</span></span><br><span class="line">                [self <span class="string">callCompletionBlockForOperation:</span>strongOperation <span class="string">completion:</span>completedBlock <span class="string">image:</span>cachedImage <span class="string">data:</span>cachedData <span class="string">error:</span>nil <span class="string">cacheType:</span>cacheType <span class="string">finished:</span>YES <span class="string">url:</span>url];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// download if no image or requested to refresh anyway, and download allowed by delegate</span></span><br><span class="line">             <span class="comment">/*</span></span><br><span class="line"><span class="comment">             把图片加载的`SDWebImageOptions`类型枚举转换为图片下载的`SDWebImageDownloaderOptions`类型的枚举</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            SDWebImageDownloaderOptions downloaderOptions = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (options &amp; SDWebImageLowPriority) downloaderOptions |= SDWebImageDownloaderLowPriority;</span><br><span class="line">            <span class="keyword">if</span> (options &amp; SDWebImageProgressiveDownload) downloaderOptions |= SDWebImageDownloaderProgressiveDownload;</span><br><span class="line">            <span class="keyword">if</span> (options &amp; SDWebImageRefreshCached) downloaderOptions |= SDWebImageDownloaderUseNSURLCache;</span><br><span class="line">            <span class="keyword">if</span> (options &amp; SDWebImageContinueInBackground) downloaderOptions |= SDWebImageDownloaderContinueInBackground;</span><br><span class="line">            <span class="keyword">if</span> (options &amp; SDWebImageHandleCookies) downloaderOptions |= SDWebImageDownloaderHandleCookies;</span><br><span class="line">            <span class="keyword">if</span> (options &amp; SDWebImageAllowInvalidSSLCertificates) downloaderOptions |= SDWebImageDownloaderAllowInvalidSSLCertificates;</span><br><span class="line">            <span class="keyword">if</span> (options &amp; SDWebImageHighPriority) downloaderOptions |= SDWebImageDownloaderHighPriority;</span><br><span class="line">            <span class="keyword">if</span> (options &amp; SDWebImageScaleDownLargeImages) downloaderOptions |= SDWebImageDownloaderScaleDownLargeImages;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             如果设置了强制刷新缓存的选项。则`SDWebImageDownloaderProgressiveDownload`选项失效并且添加`SDWebImageDownloaderIgnoreCachedResponse`选项。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</span><br><span class="line">                <span class="comment">// force progressive off if image already cached but forced refreshing</span></span><br><span class="line">                <span class="comment">//如果图像已缓存但强制刷新，则强制渐进关闭</span></span><br><span class="line">                downloaderOptions &amp;= ~SDWebImageDownloaderProgressiveDownload;</span><br><span class="line">                <span class="comment">// ignore image read from NSURLCache if image if cached but force refreshing</span></span><br><span class="line">                <span class="comment">//忽略从NSURLCache读取的图像，如果图像缓存但强制刷新</span></span><br><span class="line">                downloaderOptions |= SDWebImageDownloaderIgnoreCachedResponse;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// `SDWebImageCombinedOperation` -&gt; `SDWebImageDownloadToken` -&gt; `downloadOperationCancelToken`, which is a `SDCallbacksDictionary` and retain the completed block below, so we need weak-strong again to avoid retain cycle</span></span><br><span class="line">            __weak typeof(strongOperation) weakSubOperation = strongOperation;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             新建一个网络下载的操作。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            strongOperation.downloadToken = [self.imageDownloader <span class="string">downloadImageWithURL:</span>url <span class="string">options:</span>downloaderOptions <span class="string">progress:</span>progressBlock <span class="string">completed:</span>^(UIImage *downloadedImage, NSData *downloadedData, NSError *error, BOOL finished) &#123;</span><br><span class="line">                __strong typeof(weakSubOperation) strongSubOperation = weakSubOperation;</span><br><span class="line">                <span class="comment">//如果操作被取消或者不存在，则不执行任何操作</span></span><br><span class="line">                <span class="keyword">if</span> (!strongSubOperation || strongSubOperation.isCancelled) &#123;</span><br><span class="line">                    <span class="comment">// Do nothing if the operation was cancelled</span></span><br><span class="line">                    <span class="comment">// See #699 for more details</span></span><br><span class="line">                    <span class="comment">// if we would call the completedBlock, there could be a race condition between this block and another completedBlock for the same object, so if this one is called second, we will overwrite the new data</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                    <span class="comment">//如果加载出错。则直接返回回调。并且添加到failedURLs中</span></span><br><span class="line">                    [self <span class="string">callCompletionBlockForOperation:</span>strongSubOperation <span class="string">completion:</span>completedBlock <span class="string">error:</span>error <span class="string">url:</span>url];</span><br><span class="line">                    BOOL shouldBlockFailedURL;</span><br><span class="line">                    <span class="comment">// Check whether we should block failed url</span></span><br><span class="line">                    <span class="comment">//检查我们是否应该阻止失败的网址</span></span><br><span class="line">                    <span class="keyword">if</span> ([self.delegate <span class="string">respondsToSelector:</span><span class="meta">@selector</span>(<span class="string">imageManager:</span><span class="string">shouldBlockFailedURL:</span><span class="string">withError:</span>)]) &#123;</span><br><span class="line">                        shouldBlockFailedURL = [self.delegate <span class="string">imageManager:</span>self <span class="string">shouldBlockFailedURL:</span>url <span class="string">withError:</span>error];</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        shouldBlockFailedURL = (   error.code != NSURLErrorNotConnectedToInternet</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorCancelled</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorTimedOut</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorInternationalRoamingOff</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorDataNotAllowed</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorCannotFindHost</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorCannotConnectToHost</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorNetworkConnectionLost);</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//如果shouldBlockFailedURL为YES，即阻止失败的网址，添加到failedURLs中</span></span><br><span class="line">                    <span class="keyword">if</span> (shouldBlockFailedURL) &#123;</span><br><span class="line">                        LOCK(self.failedURLsLock);</span><br><span class="line">                        [self.failedURLs <span class="string">addObject:</span>url];</span><br><span class="line">                        UNLOCK(self.failedURLsLock);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//加载图片成功，</span></span><br><span class="line">                    <span class="comment">//如果options选项设置为SDWebImageRetryFailed，则把url从failedURLS中移除</span></span><br><span class="line">                    <span class="keyword">if</span> ((options &amp; SDWebImageRetryFailed)) &#123;</span><br><span class="line">                        LOCK(self.failedURLsLock);</span><br><span class="line">                        [self.failedURLs <span class="string">removeObject:</span>url];</span><br><span class="line">                        UNLOCK(self.failedURLsLock);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//是否缓存在磁盘上</span></span><br><span class="line">                    BOOL cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// We've done the scale process in SDWebImageDownloader with the shared manager, this is used for custom manager and avoid extra scale.（我们已经使用共享管理器在SDWebImageDownloader中完成了缩放过程，这用于自定义管理器并避免额外的扩展。）</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//如果self不为SDWebImageManager单例，并且cacheKeyFilter（缓存可以代码块存在，下载的图像存在），则缩放下载的图像</span></span><br><span class="line">                    <span class="keyword">if</span> (self != [SDWebImageManager sharedManager] &amp;&amp; self.cacheKeyFilter &amp;&amp; downloadedImage) &#123;</span><br><span class="line">                        downloadedImage = [self <span class="string">scaledImageForKey:</span>key <span class="string">image:</span>downloadedImage];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果options选项为SDWebImageRefreshCached，并且缓存图像存在，下载图像不存在。图像刷新命中NSURLCache缓存，不调用完成块</span></span><br><span class="line">                    <span class="keyword">if</span> (options &amp; SDWebImageRefreshCached &amp;&amp; cachedImage &amp;&amp; !downloadedImage) &#123;</span><br><span class="line">                        <span class="comment">// Image refresh hit the NSURLCache cache, do not call the completion block</span></span><br><span class="line">                        <span class="comment">//图像刷新命中NSURLCache缓存，不调用完成块</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [self.delegate <span class="string">respondsToSelector:</span><span class="meta">@selector</span>(<span class="string">imageManager:</span><span class="string">transformDownloadedImage:</span><span class="string">withURL:</span>)]) &#123;</span><br><span class="line">                     <span class="comment">//如果成功下载图片。并且图片是动态图片。并且设置了SDWebImageTransformAnimatedImage属性。则处理图片</span></span><br><span class="line">                     </span><br><span class="line">                        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123;</span><br><span class="line">                            <span class="comment">//获取transform以后的图片</span></span><br><span class="line">                            UIImage *transformedImage = [self.delegate <span class="string">imageManager:</span>self <span class="string">transformDownloadedImage:</span>downloadedImage <span class="string">withURL:</span>url];</span><br><span class="line">                            <span class="comment">//存储transform以后的的图片</span></span><br><span class="line">                            <span class="keyword">if</span> (transformedImage &amp;&amp; finished) &#123;</span><br><span class="line">                                BOOL imageWasTransformed = ![transformedImage <span class="string">isEqual:</span>downloadedImage];</span><br><span class="line">                                NSData *cacheData;</span><br><span class="line">                                <span class="comment">// pass nil if the image was transformed, so we can recalculate the data from the image（如果图像被转换，则传递nil，因此我们可以重新计算图像中的数据）</span></span><br><span class="line">                                </span><br><span class="line">                                <span class="comment">//cacheSerializer：将图像缓存到磁盘的解码算法，返回的是data。如果self.cacheSerializer存在，则重新计算图像中的数据。</span></span><br><span class="line">                                <span class="keyword">if</span> (self.cacheSerializer) &#123;</span><br><span class="line">                                    cacheData = self.cacheSerializer(transformedImage, (imageWasTransformed ? nil : downloadedData), url);</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    cacheData = (imageWasTransformed ? nil : downloadedData);</span><br><span class="line">                                &#125;</span><br><span class="line">                               <span class="comment">//存储transform以后的图片</span></span><br><span class="line">                                [self.imageCache <span class="string">storeImage:</span>transformedImage <span class="string">imageData:</span>cacheData <span class="string">forKey:</span>key <span class="string">toDisk:</span>cacheOnDisk <span class="string">completion:</span>nil];</span><br><span class="line">                            &#125;</span><br><span class="line">                             <span class="comment">//回调拼接</span></span><br><span class="line">                            [self <span class="string">callCompletionBlockForOperation:</span>strongSubOperation <span class="string">completion:</span>completedBlock <span class="string">image:</span>transformedImage <span class="string">data:</span>downloadedData <span class="string">error:</span>nil <span class="string">cacheType:</span>SDImageCacheTypeNone <span class="string">finished:</span>finished <span class="string">url:</span>url];</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果成功下载图片。并且图片不是图片。则直接缓存和回调</span></span><br><span class="line">                        <span class="keyword">if</span> (downloadedImage &amp;&amp; finished) &#123;</span><br><span class="line">                            <span class="comment">//cacheSerializer：将图像缓存到磁盘的解码算法，返回的是data。如果self.cacheSerializer存在，则重新计算图像中的数据。</span></span><br><span class="line">                            <span class="keyword">if</span> (self.cacheSerializer) &#123;</span><br><span class="line">                                dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123;</span><br><span class="line">                                    NSData *cacheData = self.cacheSerializer(downloadedImage, downloadedData, url);</span><br><span class="line">                                     <span class="comment">//存储transform以后的图片</span></span><br><span class="line">                                    [self.imageCache <span class="string">storeImage:</span>downloadedImage <span class="string">imageData:</span>cacheData <span class="string">forKey:</span>key <span class="string">toDisk:</span>cacheOnDisk <span class="string">completion:</span>nil];</span><br><span class="line">                                &#125;);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="comment">//存储transform以后的图片</span></span><br><span class="line">                                [self.imageCache <span class="string">storeImage:</span>downloadedImage <span class="string">imageData:</span>downloadedData <span class="string">forKey:</span>key <span class="string">toDisk:</span>cacheOnDisk <span class="string">completion:</span>nil];</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                         <span class="comment">//回调拼接</span></span><br><span class="line">                        [self <span class="string">callCompletionBlockForOperation:</span>strongSubOperation <span class="string">completion:</span>completedBlock <span class="string">image:</span>downloadedImage <span class="string">data:</span>downloadedData <span class="string">error:</span>nil <span class="string">cacheType:</span>SDImageCacheTypeNone <span class="string">finished:</span>finished <span class="string">url:</span>url];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//从正在加载的图片操作集合中移除当前操作</span></span><br><span class="line">                <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">                    [self <span class="string">safelyRemoveOperationFromRunning:</span>strongSubOperation];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cachedImage) &#123;</span><br><span class="line">            <span class="comment">//如果缓存的图像存在，回调拼接，安全移除Operation对象</span></span><br><span class="line">            [self <span class="string">callCompletionBlockForOperation:</span>strongOperation <span class="string">completion:</span>completedBlock <span class="string">image:</span>cachedImage <span class="string">data:</span>cachedData <span class="string">error:</span>nil <span class="string">cacheType:</span>cacheType <span class="string">finished:</span>YES <span class="string">url:</span>url];</span><br><span class="line">            [self <span class="string">safelyRemoveOperationFromRunning:</span>strongOperation];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Image not in cache and download disallowed by delegate（委托不允许图像不在缓存和下载中）</span></span><br><span class="line">             <span class="comment">//如果缓存的图像不存在，回调拼接，安全移除Operation对象</span></span><br><span class="line">            [self <span class="string">callCompletionBlockForOperation:</span>strongOperation <span class="string">completion:</span>completedBlock <span class="string">image:</span>nil <span class="string">data:</span>nil <span class="string">error:</span>nil <span class="string">cacheType:</span>SDImageCacheTypeNone <span class="string">finished:</span>YES <span class="string">url:</span>url];</span><br><span class="line">            [self <span class="string">safelyRemoveOperationFromRunning:</span>strongOperation];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-8、SDWebImageCompat的图像缩放操作"><a href="#2-8、SDWebImageCompat的图像缩放操作" class="headerlink" title="2.8、SDWebImageCompat的图像缩放操作"></a>2.8、<code>SDWebImageCompat</code>的图像缩放操作</h3><p>/**</p><ul><li>放缩操作：根据图片中的图片组 或 scale 重新计算返回图片<br>*</li><li>@param key   键：就是图片的地址</li><li>@param image UIImage<br>*</li><li>@return UIImage<br>*/<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> UIImage *SDScaledImageForKey(NSString * _Nullable key, UIImage * _Nullable <span class="built_in">image</span>) &#123;</span><br><span class="line">    <span class="comment">//图片为空，返回nil</span></span><br><span class="line">    <span class="built_in">if</span> (!<span class="built_in">image</span>) &#123;</span><br><span class="line">        <span class="built_in">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SD_MAC <span class="comment">//如果是MAC，直接返回图片</span></span></span><br><span class="line">    <span class="built_in">return</span> <span class="built_in">image</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> SD_UIKIT || SD_WATCH <span class="comment">//iOS或者watch</span></span></span><br><span class="line">    <span class="built_in">if</span> ((<span class="built_in">image</span>.images).count &gt; <span class="number">0</span>) &#123;<span class="comment">//动态图</span></span><br><span class="line">        NSMutableArray&lt;UIImage *&gt; *scaledImages = [NSMutableArray <span class="keyword">array</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">for</span> (UIImage *tempImage in <span class="built_in">image</span>.images) &#123;</span><br><span class="line">            <span class="comment">//动态图还是执行该方法，处理单个图片</span></span><br><span class="line">            [scaledImages addObject:SDScaledImageForKey(key, tempImage)];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建一个动态图片，动态图片持续的时间为duration</span></span><br><span class="line">        UIImage *animatedImage = [UIImage animatedImageWithImages:scaledImages duration:<span class="built_in">image</span>.duration];</span><br><span class="line">        <span class="built_in">if</span> (animatedImage) &#123;</span><br><span class="line">            animatedImage.sd_imageLoopCount = <span class="built_in">image</span>.sd_imageLoopCount;</span><br><span class="line">            animatedImage.sd_imageFormat = <span class="built_in">image</span>.sd_imageFormat;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> animatedImage;</span><br><span class="line">    &#125; <span class="built_in">else</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SD_WATCH</span></span><br><span class="line">        <span class="built_in">if</span> ([[WKInterfaceDevice currentDevice] respondsToSelector:@selector(screenScale)]) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> SD_UIKIT</span></span><br><span class="line">        <span class="built_in">if</span> ([[UIScreen mainScreen] respondsToSelector:@selector(scale)]) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">           <span class="comment">// 比如屏幕为320x480时，scale为1，屏幕为640x960时，scale为2</span></span><br><span class="line">            CGFloat scale = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// “@2x.png”的长度为7，所以此处添加了这个判断，很巧妙</span></span><br><span class="line">            <span class="built_in">if</span> (key.length &gt;= <span class="number">8</span>) &#123;</span><br><span class="line">                <span class="comment">//根据后缀给scale赋值</span></span><br><span class="line">                NSRange range = [key rangeOfString:@<span class="string">"@2x."</span>];</span><br><span class="line">                <span class="built_in">if</span> (range.location != NSNotFound) &#123;</span><br><span class="line">                    scale = <span class="number">2.0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                range = [key rangeOfString:@<span class="string">"@3x."</span>];</span><br><span class="line">                <span class="built_in">if</span> (range.location != NSNotFound) &#123;</span><br><span class="line">                    scale = <span class="number">3.0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 使用initWithCGImage来根据Core Graphics的图片构建UIImage。</span></span><br><span class="line">            <span class="comment">// 这个函数可以使用scale和orientation</span></span><br><span class="line">            UIImage *scaledImage = [[UIImage alloc] initWithCGImage:<span class="built_in">image</span>.CGImage scale:scale orientation:<span class="built_in">image</span>.imageOrientation];</span><br><span class="line">            scaledImage.sd_imageFormat = <span class="built_in">image</span>.sd_imageFormat;</span><br><span class="line">            <span class="built_in">image</span> = scaledImage;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> <span class="built_in">image</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NSString *<span class="keyword">const</span> SDWebImageErrorDomain = @<span class="string">"SDWebImageErrorDomain"</span>;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、整体框架&quot;&gt;&lt;a href=&quot;#1、整体框架&quot; class=&quot;headerlink&quot; title=&quot;1、整体框架&quot;&gt;&lt;/a&gt;1、整体框架&lt;/h2&gt;&lt;p&gt;看下整体的框架图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://obzx0h1re.bkt.cloudd
      
    
    </summary>
    
      <category term="iOS" scheme="http://guohuaden.com/categories/iOS/"/>
    
    
      <category term="SDWebImage" scheme="http://guohuaden.com/tags/SDWebImage/"/>
    
  </entry>
  
  <entry>
    <title>读 SDWebImage 一 使用分析</title>
    <link href="http://guohuaden.com/2018/09/29/Read-SDWebImage-note1/"/>
    <id>http://guohuaden.com/2018/09/29/Read-SDWebImage-note1/</id>
    <published>2018-09-29T06:32:04.000Z</published>
    <updated>2018-10-24T09:54:51.847Z</updated>
    
    <content type="html"><![CDATA[<p>SDWebImage整体的框架：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">SDWebImage</span><br><span class="line">    -</span><br><span class="line">    |<span class="string">--SDWebImageCompat :一些兼容性相关的宏定义 </span></span><br><span class="line"><span class="string">    </span>|<span class="string">--SDWebImageOperation :只有一个 cancel 方法的 protocal</span></span><br><span class="line"><span class="string">    </span>|</span><br><span class="line">    |<span class="string">--Downloader :下载模块</span></span><br><span class="line"><span class="string">    </span>|<span class="string">   </span>|<span class="string">-- SDWebImageDownloader</span></span><br><span class="line"><span class="string">    </span>|<span class="string">   </span>|<span class="string">-- SDWebImageDownloaderOperation</span></span><br><span class="line"><span class="string">    </span>|<span class="string">   </span></span><br><span class="line"><span class="string">    </span>|<span class="string">--Cache :内存和硬盘缓存模块</span></span><br><span class="line"><span class="string">    </span>|<span class="string">   </span>|<span class="string">-- SDImageCache</span></span><br><span class="line"><span class="string">    </span>|</span><br><span class="line">    |<span class="string">--Utils :</span></span><br><span class="line"><span class="string">    </span>|<span class="string">   </span>|<span class="string">-- SDWebImageManager 将缓存和下载模块结合起来使用</span></span><br><span class="line"><span class="string">    </span>|<span class="string">   </span>|<span class="string">-- SDWebImagePrefetcher 预下载图片</span></span><br><span class="line"><span class="string">    </span>|<span class="string">   </span>|<span class="string">-- SDWebImageDecoder</span></span><br><span class="line"><span class="string">    </span>|</span><br><span class="line">    |<span class="string">--Categories : UIKit 相关的Category,方便使用,还支持 MKAnnotationView</span></span><br><span class="line"><span class="string">        </span>|<span class="string">-- MKAnnotationView+WebCache</span></span><br><span class="line"><span class="string">        </span>|<span class="string">-- UIButton+WebCache</span></span><br><span class="line"><span class="string">        </span>|<span class="string">-- UIImageView+WebCache</span></span><br><span class="line"><span class="string">    -</span></span><br><span class="line"><span class="string">    ... ...</span></span><br></pre></td></tr></table></figure><h2 id="1、使用配置"><a href="#1、使用配置" class="headerlink" title="1、使用配置"></a>1、使用配置</h2><p>为项目添加一个通用的只读缓存的存储路径:</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">NSString</span> *bundlePath = [[<span class="symbol">NSBundle</span> mainBundle].resourcePath stringByAppendingPathComponent:@<span class="string">"CustomPathImages"</span>];</span><br><span class="line"> </span><br><span class="line">[[<span class="symbol">SDImageCache</span> sharedImageCache] addReadOnlyCachePath:bundlePath];</span><br></pre></td></tr></table></figure><h2 id="2、-身份鉴定"><a href="#2、-身份鉴定" class="headerlink" title="2、 身份鉴定"></a>2、 身份鉴定</h2><p>如果请求的图片需要身份鉴定才可以获取，SDWebImage提供了两种方法：</p><p>一种是直接设置用户名和密码：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[SDWebImageManager <span class="keyword">sharedManager].imageDownloader.username </span>= @<span class="string">"httpwatch"</span><span class="comment">;</span></span><br><span class="line">[SDWebImageManager <span class="keyword">sharedManager].imageDownloader.password </span>= @<span class="string">"httpwatch01"</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p>另一种是通过 <code>NSURLCredential</code> 属性去配置用户名和密码</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSURLCredential *<span class="keyword">new</span><span class="type">Credential</span> = [NSURLCredential credentialWithUser:<span class="type"></span>@<span class="string">"httpwatch"</span> password:<span class="type"></span>@<span class="string">"httpwatch01"</span> persistence:<span class="type">NSURLCredentialPersistenceNone</span>];</span><br><span class="line">[SDWebImageManager sharedManager].imageDownloader.urlCredential = <span class="keyword">new</span><span class="type">Credential</span>;</span><br></pre></td></tr></table></figure><p>这里做下测试：<br>图片地址（需要身份验证才可以查看）：<a href="http://www.httpwatch.com/httpgallery/authentication/authenticatedimage/default.aspx?0.35786508303135633" target="_blank" rel="noopener">http://www.httpwatch.com/httpgallery/authentication/authenticatedimage/default.aspx?0.35786508303135633</a></p><p>浏览器去打开会弹出提示框让输入验证信息，如下：<br><img src="http://obzx0h1re.bkt.clouddn.com/Authentication_Image_SDWebImage.jpg" alt="Authentication_Image_SDWebImage"></p><p>这种情况下，在项目中就需要配置身份验证信息，否则图片无法显示。</p><h2 id="3、设置要附加到每个下载HTTP请求的HTTP标头的值"><a href="#3、设置要附加到每个下载HTTP请求的HTTP标头的值" class="headerlink" title="3、设置要附加到每个下载HTTP请求的HTTP标头的值"></a>3、设置要附加到每个下载HTTP请求的HTTP标头的值</h2><p>如果想要自定义图片请求的Request Header时，可以使用以下方法：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置要附加到每个下载HTTP请求的HTTP标头的值。</span></span><br><span class="line">  [SDWebImageManager.sharedManager.imageDownloader <span class="string">setValue:</span>@<span class="string">"&amp;&amp;Jason&amp;&amp;"</span> <span class="string">forHTTPHeaderField:</span>@<span class="string">"****SDWebImageM****"</span>];</span><br></pre></td></tr></table></figure><p>通过charles抓包可以看到设置的Request Header：</p><p><img src="http://obzx0h1re.bkt.clouddn.com/setValue_1_SDWebImageManager.jpg" alt="setValue_1_SDWebImageManager"></p><p><img src="http://obzx0h1re.bkt.clouddn.com/setValue_2_SDWebImageManager.jpg" alt="setValue_2_SDWebImageManager"></p><h2 id="4、图片下载执行顺序"><a href="#4、图片下载执行顺序" class="headerlink" title="4、图片下载执行顺序"></a>4、图片下载执行顺序</h2><p>执行顺序分：LIFO（先入后出） 和 FIFO（先进先出）两种<br>默认值为 <code>FIFO</code> 。</p><p><code>SDWebImageDownloaderExecutionOrder</code> ：枚举类型</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SDWebImageManager.<span class="keyword">sharedManager.imageDownloader.executionOrder </span>= SDWebImageDownloaderLIFOExecutionOrder<span class="comment">;</span></span><br></pre></td></tr></table></figure><h2 id="5、手动清理缓存"><a href="#5、手动清理缓存" class="headerlink" title="5、手动清理缓存"></a>5、手动清理缓存</h2><p>SDWebImage提供了手动清理缓存操作，从SDWebImage的工作原理可以想到清理缓存需清理两处：内存和磁盘。</p><p>注：这里清理的仅仅是SDWebImage的缓存，并没有清理整个app的缓存</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[SDWebImageManager.sharedManager.imageCache clearMemory]</span><span class="comment">;</span></span><br><span class="line"><span class="section">[SDWebImageManager.sharedManager.imageCache clearDiskOnCompletion:nil]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><hr><h2 id="6、将图片显示到ImgaeView-Button上"><a href="#6、将图片显示到ImgaeView-Button上" class="headerlink" title="6、将图片显示到ImgaeView / Button上"></a>6、将图片显示到ImgaeView / Button上</h2><p>Button图片或者背景图的显示和ImageView同理，只是多了几个额外的参数,下面以ImageView为例。</p><h3 id="6-1、图片显示动画"><a href="#6-1、图片显示动画" class="headerlink" title="6.1、图片显示动画"></a>6.1、图片显示动画</h3><p>图片显示过渡类型：<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.customImageView.sd_imageTransition = SDWebImageTransition.curlUpTransition<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>SDWebImage提供了七种动画过渡类型，分别是：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Fade transition. 淡出过渡</span></span><br><span class="line"><span class="meta">@property</span> (nonatomic, <span class="class"><span class="keyword">class</span>, <span class="type">nonnull</span>, <span class="type">readonly) SDWebImageTransition *fadeTransition;</span></span></span><br><span class="line"><span class="comment">/// Flip from left transition. 从左过渡翻转。</span></span><br><span class="line"><span class="meta">@property</span> (nonatomic, <span class="class"><span class="keyword">class</span>, <span class="type">nonnull</span>, <span class="type">readonly) SDWebImageTransition *flipFromLeftTransition;</span></span></span><br><span class="line"><span class="comment">/// Flip from right transition. 从右过渡翻转。</span></span><br><span class="line"><span class="meta">@property</span> (nonatomic, <span class="class"><span class="keyword">class</span>, <span class="type">nonnull</span>, <span class="type">readonly) SDWebImageTransition *flipFromRightTransition;</span></span></span><br><span class="line"><span class="comment">/// Flip from top transition. 从顶部过渡翻转。</span></span><br><span class="line"><span class="meta">@property</span> (nonatomic, <span class="class"><span class="keyword">class</span>, <span class="type">nonnull</span>, <span class="type">readonly) SDWebImageTransition *flipFromTopTransition;</span></span></span><br><span class="line"><span class="comment">/// Flip from bottom transition. 从底部过渡翻转。</span></span><br><span class="line"><span class="meta">@property</span> (nonatomic, <span class="class"><span class="keyword">class</span>, <span class="type">nonnull</span>, <span class="type">readonly) SDWebImageTransition *flipFromBottomTransition;</span></span></span><br><span class="line"><span class="comment">/// Curl up transition. 向上卷起过渡。</span></span><br><span class="line"><span class="meta">@property</span> (nonatomic, <span class="class"><span class="keyword">class</span>, <span class="type">nonnull</span>, <span class="type">readonly) SDWebImageTransition *curlUpTransition;</span></span></span><br><span class="line"><span class="comment">/// Curl down transition. 向下卷起过渡。</span></span><br><span class="line"><span class="meta">@property</span> (nonatomic, <span class="class"><span class="keyword">class</span>, <span class="type">nonnull</span>, <span class="type">readonly) SDWebImageTransition *curlDownTransition;</span></span></span><br></pre></td></tr></table></figure><h3 id="6-2-、图片显示方法"><a href="#6-2-、图片显示方法" class="headerlink" title="6.2 、图片显示方法"></a>6.2 、图片显示方法</h3><p>SDWebImage提供7种方法去显示图片，我们只看第7个，因为其他6种方法最后都是通过该方法图显示图片的。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">          placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</span><br><span class="line">                   options:(SDWebImageOptions)options</span><br><span class="line">                  progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                 completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock;</span><br></pre></td></tr></table></figure><p><strong>通过给定的URL加载图片并将其加载到此imageView中。它适用于静态和动态图像。<br>先从缓存和磁盘中寻找该图片，有则直接显示，无就下载显示并缓存。<br>下载是异步和缓存的，SDWebImage会先显示传入的占位符，直到请求完成</strong></p><h4 id="6-2-1分析参数"><a href="#6-2-1分析参数" class="headerlink" title="6.2.1分析参数"></a>6.2.1分析参数</h4><ol><li>@param url  ：图片URL</li><li>@param placeholder ：占位符（最初要设置的图像，直到图像请求完成。）</li><li>@param options ：下载图像时使用的选项。</li><li>@param progressBlock ：下载图像时调用的block代码块（稍后分析）</li><li>@param completedBlock ： 操作完成时调用的代码块。 该代码块没有返回值（稍后分析）</li></ol><p><strong>解析 options 选项（枚举类型）</strong></p><blockquote><p><code>SDWebImageRetryFailed = 1 &lt;&lt; 0,</code><br>  默认情况下当通过URL下载图片失败后，该URL就被加入黑名单，之后SDWebImage不会再去尝试下载。此标志作用就是禁用该黑名单，也就是说使用SDWebImageRetryFailed后，图片下载失败仍会尝试下载</p><p> <code>SDWebImageLowPriority = 1 &lt;&lt; 1,</code><br>  默认情况下图片在UI交互期间下载，此标志的作用就是禁用该功能。例如：在UIScrollView减速时导致延迟下载。</p><p><code>SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2,</code><br>  此标志作用是：图片下载完成后仅缓存到内存，不缓存在磁盘上</p><p><code>SDWebImageProgressiveDownload = 1 &lt;&lt; 3,</code><br>  此标志启用渐进式下载，图像在下载过程中逐步显示，就像浏览器一样。<br>  默认情况下，图像仅在完全下载后显示。</p><p><code>SDWebImageRefreshCached = 1 &lt;&lt; 4,</code><br>  即使缓存中存在该图片，也尊重HTTP响应缓存控制，在需要时从远程刷新图片。<br>  磁盘缓存将由 <code>NSURLCache</code> 替代 <code>SDWebImage</code> 去处理，这样也将导致性能略有下降。<br>  该选项有助于处理同一个URL请求但更换图片的情况，例如Facebook图形api配置文件的图片。<br>  如果刷新了缓存图片，则使用缓存图片调用一次完成block代码块，再使用最终的图片调用完成block代码块。<br>  仅当你无法使用嵌入式缓存清除参数使URL保持静态时，才使用该标志。</p><p><code>SDWebImageContinueInBackground = 1 &lt;&lt; 5,</code><br>  在<code>iOS 4+</code>中，如果app进入后台也继续下载图片，这是通过询问系统实现的。<br>  在后台有额外的时间让请求完成，如果后台任务到期，则操作被取消。</p><p><code>SDWebImageHandleCookies = 1 &lt;&lt; 6,</code><br>  通过<code>NSMutableURLRequest.HTTPShouldHandleCookies = YES</code>设置处理在 <code>NSHTTPCookieStore</code>中的cookies。</p><p>  <code>SDWebImageAllowInvalidSSLCertificates = 1 &lt;&lt; 7,</code><br>  启用允许不受信任的SSL证书（用于测试目的，在生产中谨慎使用）</p><p><code>SDWebImageHighPriority = 1 &lt;&lt; 8,</code><br>  默认情况下，图像按其排队顺序加载，此标志将它们移动到队列的前面</p><p><code>SDWebImageDelayPlaceholder = 1 &lt;&lt; 9,</code><br>  默认情况下，加载图像时会加载占位符。 此标志将延迟加载占位符图像，直到图像加载完毕。</p><p><code>SDWebImageTransformAnimatedImage = 1 &lt;&lt; 10,</code><br>  我们通常不会在动画图像上调用transformDownloadedImage委托方法，因为大多数转换代码会破坏它。如果使用必须使用此标志来转换它们。  </p><p><code>SDWebImageAvoidAutoSetImage = 1 &lt;&lt; 11,</code><br>  默认情况下，下载后会将图像添加到imageView。 但在某些情况下，我们想要<br>  在设置图像之前手动处理一些东西（例如应用滤镜或添加交叉渐变动画）请使用此标志</p><p><code>SDWebImageScaleDownLargeImages = 1 &lt;&lt; 12,</code><br>  默认情况下，图像会根据其原始大小进行解码。 在iOS上，此标志将缩小<br>  图像尺寸与设备的受限内存兼容。（如果设置了“SDWebImageProgressiveDownload”标志，则停用缩小比例。）</p><p><code>SDWebImageQueryDataWhenInMemory = 1 &lt;&lt; 13,</code><br>  默认情况下，当图像缓存在内存中时，我们不查询磁盘数据。 此掩码可以强制同时查询磁盘数据。<br>  建议将此标志与<code>SDWebImageQueryDiskSync</code>一起使用，以确保图像在同一个runloop中加载。 </p><p><code>SDWebImageQueryDiskSync = 1 &lt;&lt; 14,</code><br>  默认情况下，我们同步查询内存缓存，异步查询磁盘缓存。 此掩码可以强制同步查询磁盘缓存，以确保在同一个runloop中加载映像。<br>  如果禁用内存缓存或在某些其他情况下，此标志可以避免在单元重用期间闪烁。</p><p><code>SDWebImageFromCacheOnly = 1 &lt;&lt; 15,</code><br>  默认情况下，当缓存丢失时，将从网络下载映像。此标志可以阻止网络仅从缓存加载。</p><p><code>SDWebImageForceTransition = 1 &lt;&lt; 16</code><br>  默认情况下，当您使用 <code>SDWebImageTransition</code> 在图像加载完成后进行某些视图转换时，此转换仅适用于从网络下载图像。 此掩码也可以强制为内存和磁盘缓存应用视图转换。</p></blockquote><p><strong>解析progressBlock代码块</strong><br>下载图像时重复调用的代码块,在后台队列上执行,包含三个参数，分别是：<br>NSInteger receivedSize：接收到的图片大小<br>NSInteger expectedSize：预期的图片大小<br>NSURL * _Nullable targetURL：目标图片的URL</p><p><strong>completedBlock代码块</strong><br>包含四个参数：<br>(UIImage <em> _Nullable image, NSError </em> _Nullable error, SDImageCacheType cacheType, NSURL * _Nullable imageURL)</p><ol><li>第一个参数是：请求得到的UIImage，如果请求失败，该图像参数是为nil</li><li>第二个参数： 请求结果中可能包含的NSError</li><li>第三个参数： 是枚举，缓存类型，通过类型判断图片从哪里获取。分三种： SDImageCacheTypeNone 、SDImageCacheTypeDisk、SDImageCacheTypeMemory 。</li><li>第四个参数：图片的URL。</li></ol><p>以下是其他6种显示图片的方法，只做简单的分析：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *通过给定的URL加载图片并将其加载到此imageView中。它适用于静态和动态图像</span></span><br><span class="line"><span class="comment"> * 先从缓存和磁盘中寻找，有则显示，无就下载显示并缓存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">          placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder ;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">          placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</span><br><span class="line">                   options:(SDWebImageOptions)options ;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">                 completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">          placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</span><br><span class="line">                 completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock ;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">          placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</span><br><span class="line">                   options:(SDWebImageOptions)options</span><br><span class="line">                 completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">          placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</span><br><span class="line">                   options:(SDWebImageOptions)options</span><br><span class="line">                  progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                 completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock;</span><br></pre></td></tr></table></figure></p><hr><h2 id="7、图像显示的最终调用方法解析"><a href="#7、图像显示的最终调用方法解析" class="headerlink" title="7、图像显示的最终调用方法解析"></a>7、图像显示的最终调用方法解析</h2><p>通过上面的七种方法来加载图像，其实前6种都是调用第7种完善的方法。而这7种方法都是调用的另一种方法。如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)sd_internalSetImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">                  placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</span><br><span class="line">                           options:(SDWebImageOptions)options</span><br><span class="line">                      operationKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)operationKey</span><br><span class="line">                     setImageBlock:(<span class="keyword">nullable</span> SDSetImageBlock)setImageBlock</span><br><span class="line">                          progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                         completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock</span><br><span class="line">                           context:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)context;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ol><li>@param url  ：图像URL</li><li>@param placeholder ：初始化image，知道图像请求完成</li><li>@param options ：图像下载时的选项</li><li>@param operationKey ：用作操作key的字符串。 如果为nil，将使用类名（ImageView加载图像时直接传的nil，Button加载图像时传【字符串和UIControlState状态的拼接】）</li><li>@param setImageBlock ： 用于自定义设置图像的代码块</li><li>@param progressBlock ： 下载图像时调用的代码块</li><li>@param completedBlock ： 操作完成时调用的代码块。 该块没有返回值</li><li>@param context ： 具有执行特定更改或过程的额外信息的上下文。</li></ol><p>其实可以看出：除了参数4、5、8之外，剩下的都是和ImageView加载图像时参数一样，因为这本就是ImageView加载图像最终调用的方法。而参数4、5、8则是Button加载图像传入的参数，这也证明了代码的高内聚力。</p><p><strong>SDSetImageBlock：</strong><br>包含两个参数：<br>(UIImage <em>image, NSData </em>imageData)<br>我们通常在该回调中自定义图像（比如说压缩、剪切、加滤镜、加蒙层等）<br>或者直接简单的显示图像：<code>[weakSelf setImage:image forState:state];</code></p><p>看下整体的代码：<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="literal">self</span> sd_internalSetImageWithURL:url</span><br><span class="line">                    placeholderImage:placeholder</span><br><span class="line">                             options:options</span><br><span class="line">                        operationKey:imageOperationKeyForState(<span class="keyword">state</span>)</span><br><span class="line">                       <span class="built_in">set</span>ImageBlock:^(UIImage *image, NSData *imageData) &#123;</span><br><span class="line">                           [weakSelf <span class="built_in">set</span>Image:image <span class="keyword">for</span>State:<span class="keyword">state</span>]; //自定义图像</span><br><span class="line">                       &#125;</span><br><span class="line">                            progress:nil</span><br><span class="line">                           completed:completedBlock];</span><br></pre></td></tr></table></figure></p><p> <strong>context ： 上下文信息</strong></p><p>这个是最后才加上的，为的是获取额外的信息（加载的过程信息、更改信息等）</p><h3 id="7-1、分析最终的加载图像的方法"><a href="#7-1、分析最终的加载图像的方法" class="headerlink" title="7.1、分析最终的加载图像的方法"></a>7.1、分析最终的加载图像的方法</h3><p>该方法是针对UIView的子类进行图像加载的（例如：UIImageView、UIButton）<br>下面会拆成代码片段一步一步看</p><h4 id="7-1-1、第一步"><a href="#7-1-1、第一步" class="headerlink" title="7.1.1、第一步"></a>7.1.1、第一步</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> imageURLKey;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *validOperationKey = operationKey ?: <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]);</span><br><span class="line">[<span class="keyword">self</span> sd_cancelImageLoadOperationWithKey:validOperationKey];</span><br><span class="line">objc_setAssociatedObject(<span class="keyword">self</span>, &amp;imageURLKey, url, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br></pre></td></tr></table></figure><ol><li>初始化一个有效的操作key，如果传入的 <code>operationKey</code> 为nil，则赋值为类名 <code>NSStringFromClass([self class])</code> </li><li>通过 <code>operationKey</code> 从队列中取消正在进行的下载操作。</li><li>最后将该类与图像的URL关联起来，关联类型是 ：<code>OBJC_ASSOCIATION_RETAIN_NONATOMIC</code> (指定对关联对象的强引用。)</li></ol><p>以下列出所有的关联类型</p><table><thead><tr><th style="text-align:left">关联策略</th><th style="text-align:left">等价属性</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">OBJC_ASSOCIATION_ASSIGN</td><td style="text-align:left">@property (assign) or @property (unsafe_unretained)</td><td style="text-align:left">弱引用关联对象</td></tr><tr><td style="text-align:left">OBJC_ASSOCIATION_RETAIN_NONATOMIC</td><td style="text-align:left">@property (strong, nonatomic)</td><td style="text-align:left">强引用关联对象，且为非原子操作</td></tr><tr><td style="text-align:left">OBJC_ASSOCIATION_COPY_NONATOMIC</td><td style="text-align:left">@property (copy, nonatomic)</td><td style="text-align:left">复制关联对象，且为非原子操作</td></tr><tr><td style="text-align:left">OBJC_ASSOCIATION_RETAIN</td><td style="text-align:left">@property (strong, atomic)</td><td style="text-align:left">强引用关联对象，且为原子操作</td></tr><tr><td style="text-align:left">OBJC_ASSOCIATION_COPY</td><td style="text-align:left">@property (copy, atomic)</td><td style="text-align:left">复制关联对象，且为原子操作</td></tr></tbody></table><p>再回到第2条看下怎么通过 <code>operationKey</code> 取消对应正在进行下载的操作（顺便附上加载图像的操作，因为两者正好始和末）：<br>代码：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置加载图像的操作</span></span><br><span class="line">- (<span class="keyword">void</span>)sd_setImageLoadOperation:(<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;SDWebImageOperation&gt;)operation forKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">if</span> (key) &#123;</span><br><span class="line">        [<span class="keyword">self</span> sd_cancelImageLoadOperationWithKey:key];</span><br><span class="line">        <span class="keyword">if</span> (operation) &#123;</span><br><span class="line">            SDOperationsDictionary *operationDictionary = [<span class="keyword">self</span> sd_operationDictionary];</span><br><span class="line">            <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">                [operationDictionary setObject:operation forKey:key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置取消加载图像的操作</span></span><br><span class="line">- (<span class="keyword">void</span>)sd_cancelImageLoadOperationWithKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">if</span> (key) &#123;</span><br><span class="line">        <span class="comment">// Cancel in progress downloader from queue</span></span><br><span class="line">        SDOperationsDictionary *operationDictionary = [<span class="keyword">self</span> sd_operationDictionary];</span><br><span class="line">        <span class="keyword">id</span>&lt;SDWebImageOperation&gt; operation;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">            operation = [operationDictionary objectForKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (operation) &#123;</span><br><span class="line">            <span class="keyword">if</span> ([operation conformsToProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">SDWebImageOperation</span>)]) </span>&#123;</span><br><span class="line">                [operation cancel];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">                [operationDictionary removeObjectForKey:key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>分析：<br><strong>首先</strong>，获取当前的一个 <code>NSMapTable</code> ，可以说是一个广义的字典，官方文档是这样解释 <code>NSMapTable</code> 的：</p><blockquote><p>An NSMapTable is modeled after a dictionary, although, because of its options, is not a dictionary because it will behave differently.  The major option is to have keys and/or values held “weakly” in a manner that entries will be removed at some indefinite point after one of the objects is reclaimed.  In addition to being held weakly, keys or values may be copied on input or may use pointer identity for equality and hashing.<br> An NSMapTable can also be configured to operate on arbitrary pointers and not just objects.We recommend the C function API for “void *” access</p></blockquote><p>大体可以理解为：<br> <code>NSMapTable</code> 是在字典之后的一个可变集合模型化的类，但由于它的选项是使 <code>key</code> 和/或 <code>valus</code> 保持“弱有化”，以便在回收其中一个对象之后在某个不确定点删除条目，所以它不是字典，因为它的行为会有所不同。 除了被弱化之外，可以在输入上复制 <code>key</code> 或 <code>valus</code>，或者可以使用指针标识来进行相等和 <code>hash</code>（散列or哈希）操作。<br> <code>NSMapTable</code> 也可以配置为对任意指针进行操作，而不仅仅是对象。 Apple建议使用C函数API进行 <code>void *</code> 访问。</p><p> SDWebImage是这样定义 <code>NSMapTable</code> 的：<br> <figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// key is copy, value is weak because operation<span class="built_in"> instance </span>is retained by SDWebImageManager's runningOperations property</span><br><span class="line">typedef NSMapTable&lt;NSString *, id&lt;SDWebImageOperation&gt;&gt; SDOperationsDictionary;</span><br></pre></td></tr></table></figure></p><p> key使用的是copy，value则使用的是weak，并给出了解释：操作实例由SDWebImageManager的runningOperations属性保留</p><p><strong>注：</strong>获取当前的 <code>NSMapTable</code> ，以下用 <code>operationDictionary</code> 叙述。</p><p> <strong>其次</strong>，将该图像的加载操作存放入 <code>operationDictionary</code> 中，而key正是我们上面分析的 <code>operationKey</code> 。这里为了防止在操作是被篡改，使用 <code>@synchronized</code> 做了互斥锁处理。</p><p> <strong>最后</strong>，现在再看取消加载图像的操作流程就显得清晰了，大体如下：</p><ol><li>获取当前的一个 <code>operationDictionary</code> 通过key取得操作。</li><li>如果该操作存在，就通过 <code>conformsToProtocol:@protocol()</code> 检查对象是否实现了指定协议类的方法。</li><li>如果存在就直接取消，最后从移除 <code>operationDictionary</code> 该操作</li></ol><p><strong>扩展：<code>objc_setAssociatedObject</code></strong></p><ul><li>在 Objective-C 中可以通过 Category 给一个现有的类添加属性，却不能添加实例变量，这成了 Objective-C 的一个明显短板。但可以通过 Associated Objects 来弥补这一不足。</li><li>相关函数：<br>与 Associated Objects 相关的函数主要有三个:<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_setAssociatedObject</span>(<span class="params">id <span class="keyword">object</span>, <span class="keyword">const</span> <span class="keyword">void</span> *key, id <span class="keyword">value</span>, objc_AssociationPolicy policy</span>)</span>;</span><br><span class="line"><span class="function">id <span class="title">objc_getAssociatedObject</span>(<span class="params">id <span class="keyword">object</span>, <span class="keyword">const</span> <span class="keyword">void</span> *key</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_removeAssociatedObjects</span>(<span class="params">id <span class="keyword">object</span></span>)</span>;</span><br></pre></td></tr></table></figure></li></ul><p>在使用是需要引入 <code>objc/runtime.h</code> 头文件</p><ul><li>函数的作用：<br>objc_setAssociatedObject 用于给对象添加关联对象，传入 nil 则可以移除已有的关联对象；<br>objc_getAssociatedObject 用于获取关联对象；<br>objc_removeAssociatedObjects 用于移除一个对象的所有关联对象。</li><li>key值使用：<br>推荐的方法大体有三种：<br>（1）声明 static char kAssociatedObjectKey; 使用 &amp;kAssociatedObjectKey 作为 key 值;<br>（2）声明 static void *kAssociatedObjectKey = &kAssociatedObjectKey; 使用 kAssociatedObjectKey 作为 key 值；<br>（3）用 selector ，使用 getter 方法的名称作为 key 值。</li></ul><p>我们看到的SDWebInage是使用的 <code>static char kAssociatedObjectKey</code> 这种方法。而 <code>static char</code> 这种声明是C语言的写法，意思是：声明一个局部静态变量。</p><p>附上一个讲的很不错的文章：<a href="http://blog.leichunfeng.com/blog/2015/06/26/objective-c-associated-objects-implementation-principle/" target="_blank" rel="noopener">Objective-C Associated Objects 的实现原理</a></p><h4 id="7-1-2、第二步"><a href="#7-1-2、第二步" class="headerlink" title="7.1.2、第二步"></a>7.1.2、第二步</h4><p>代码片段：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">        dispatch_main_async_safe(^&#123;</span><br><span class="line">            [self <span class="string">sd_setImage:</span>placeholder <span class="string">imageData:</span>nil <span class="string">basedOnClassOrViaCustomSetImageBlock:</span>setImageBlock];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>解析：<br>条件语句判断options选项是否为 <code>SDWebImageDelayPlaceholder</code> 若不是则执行条件语句里的内容。（条件语句中执行的是设置占位符图像，但该选项是延迟占位符加载，所以需要加以判断。）</p><p><code>dispatch_main_async_safe(^{})</code> 宏定义主线程异步安全加载，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> dispatch_main_async_safe</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dispatch_main_async_safe(block) dispatch_queue_async_safe(dispatch_get_main_queue(), block)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> dispatch_queue_async_safe</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dispatch_queue_async_safe(queue, block)\</span></span><br><span class="line">    <span class="keyword">if</span> (dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL) == dispatch_queue_get_label(<span class="built_in">queue</span>)) &#123;\</span><br><span class="line">        block();\</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;\</span><br><span class="line">        dispatch_async(<span class="built_in">queue</span>, block);\</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>dispatch_main_async_safe</code> 安全的分发任务到主线程里面运行<br><code>dispatch_queue_get_label</code> 用来取队列的名字，进而判断如果当前已经是主队列，那么直接执行，否则回调到主队列之后再执行。</p><p>原因是：如果当前队列已经是主队列，那么再调用 <code>dispatch_async(dispatch_get_main_queue(), block)</code>有可能会出现<code>crash</code>。而该方法则很好的做了预防工作。</p><p>下面看条件语句中的执行方法：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)sd_setImage:(<span class="built_in">UIImage</span> *)image imageData:(<span class="built_in">NSData</span> *)imageData basedOnClassOrViaCustomSetImageBlock:(SDSetImageBlock)setImageBlock &#123;</span><br><span class="line"><span class="meta">#if SD_UIKIT || SD_MAC</span></span><br><span class="line">    [<span class="keyword">self</span> sd_setImage:image imageData:imageData basedOnClassOrViaCustomSetImageBlock:setImageBlock transition:<span class="literal">nil</span> cacheType:<span class="number">0</span> imageURL:<span class="literal">nil</span>];</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">    <span class="comment">// watchOS does not support view transition. Simplify the logic</span></span><br><span class="line">    <span class="keyword">if</span> (setImageBlock) &#123;</span><br><span class="line">        setImageBlock(image, imageData);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">self</span> isKindOfClass:[<span class="built_in">UIImageView</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="built_in">UIImageView</span> *imageView = (<span class="built_in">UIImageView</span> *)<span class="keyword">self</span>;</span><br><span class="line">        [imageView setImage:image];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该方法目的为了执行加载占位符图像。分了两种情况 <code>iOS和VTOS 、masOS系统</code> 和 其他。分类型的原因 <code>SDWebImage</code> 给了简单说明： <code>watchOS</code> 不支持 <code>view</code> 的翻转动画，所以 <code>SDWebImage</code> 做了一个简单的加载显示处理。而其他类型则和图像URL的加载显示共用了一套方法（具体实现在加载URL图像时细看）。<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>sd_setImage:<span class="params">(UIImage *)</span>image imageData:<span class="params">(NSData *)</span>imageData basedOnClassOrViaCustomSetImageBlock:<span class="params">(SDSetImageBlock)</span>setImageBlock transition:<span class="params">(SDWebImageTransition *)</span>transition cacheType:<span class="params">(SDImageCacheType)</span>cacheType imageURL:<span class="params">(NSURL *)</span>imageURL</span><br></pre></td></tr></table></figure></p><h4 id="7-1-3、第三步-正式准备加载URL图像"><a href="#7-1-3、第三步-正式准备加载URL图像" class="headerlink" title="7.1.3、第三步 正式准备加载URL图像"></a>7.1.3、第三步 正式准备加载URL图像</h4><p>同样分两种情况，根据所传的 <code>url</code> 是否存在做区分</p><ol><li><strong><code>url</code> 不存在情况</strong><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        dispatch_main_async_safe(^&#123;</span><br><span class="line"><span class="meta">#if SD_UIKIT</span></span><br><span class="line">            [self sd_removeActivityIndicator];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="keyword">if</span> (completedBlock) &#123;</span><br><span class="line">                NSError *<span class="built_in">error</span> = [NSError errorWithDomain:SDWebImageErrorDomain <span class="built_in">code</span>:<span class="number">-1</span> userInfo:<span class="comment">@&#123;NSLocalizedDescriptionKey : @</span><span class="string">"Trying to load a nil url"</span>&#125;];</span><br><span class="line">                completedBlock(nil, <span class="built_in">error</span>, SDImageCacheTypeNone, url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></li></ol><p>分析：<br>首先确保在线程安全的情况下，如果<code>iOS和VTOS系统</code>就做下移除<strong>加载指示器</strong>操作。<br>如果<code>completedBlock</code>代码块存在，就获取错误信息，执行回调内的操作。<br><code>SDExternalCompletionBlock</code> 的声明:<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^<span class="type">SDExternalCompletionBlock</span>)(<span class="type">UIImage</span> * _Nullable image, <span class="type">NSError</span> * _Nullable error, <span class="type">SDImageCacheType</span> cacheType, <span class="type">NSURL</span> * _Nullable imageURL);</span><br></pre></td></tr></table></figure></p><p>下面是url传nil时的情况：<br><img src="http://obzx0h1re.bkt.clouddn.com/SDWebImage_Error.jpg" alt="SDWebImage_Error"></p><ol start="2"><li><strong><code>url</code> 存在情况</strong></li></ol><ul><li>1、如果是<code>iOS和VTOS</code>的系统，则判断使用显示加载指示器，如果显示则创建并添加到View上。<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#if SD_UIKIT</span></span><br><span class="line">        //<span class="built_in"> check </span>if activityView is enabled<span class="built_in"> or </span>not</span><br><span class="line">       <span class="built_in"> if </span>([self sd_showActivityIndicatorView]) &#123;</span><br><span class="line">            [self sd_addActivityIndicator];</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">#endif</span></span><br></pre></td></tr></table></figure></li></ul><p>配置加载指示器：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[self.customImageView sd_setShowActivityIndicatorView:YES]</span><span class="comment">;</span></span><br><span class="line"><span class="section">[self.customImageView sd_setIndicatorStyle:UIActivityIndicatorViewStyleGray]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p><ul><li>2、根据上下文获取 <code>SDWebImageManager</code></li></ul><p>根据上下文（<code>context</code>）获取 <code>SDWebImageManager</code>，没有则创建。<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SDWebImageManager *manager<span class="comment">;</span></span><br><span class="line">if ([<span class="built_in">context</span> valueForKey:SDWebImageExternalCustomManagerKey]) &#123;</span><br><span class="line">    manager = (SDWebImageManager *)[<span class="built_in">context</span> valueForKey:SDWebImageExternalCustomManagerKey]<span class="comment">;</span></span><br><span class="line">&#125; else &#123;</span><br><span class="line">    manager = [SDWebImageManager <span class="keyword">sharedManager];</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure></p><p><code>SDWebImageManager</code>是 <code>SDWebImage</code> 管理以及操作的类。该类是<code>SDWebImage</code>的核心类，拥有一个SDWebImageCache 和 SDWebImageDownloader 属性，分别用于图片缓存和下载处理。</p><p>关于 <code>SDWebImageManager</code> 这里不细说，分出去单独研究。</p><ul><li>3 加载进度回调（或者说加载进度回调中…）</li></ul><p>下载图像时重复调用该代码块，在后台队列上执行。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reset the progress</span></span><br><span class="line"><span class="keyword">self</span>.sd_imageProgress.totalUnitCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">self</span>.sd_imageProgress.completedUnitCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">__<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)wself = <span class="keyword">self</span>;</span><br><span class="line">SDWebImageDownloaderProgressBlock combinedProgressBlock = ^(<span class="built_in">NSInteger</span> receivedSize, <span class="built_in">NSInteger</span> expectedSize, <span class="built_in">NSURL</span> * _Nullable targetURL) &#123;</span><br><span class="line">    wself.sd_imageProgress.totalUnitCount = expectedSize;</span><br><span class="line">    wself.sd_imageProgress.completedUnitCount = receivedSize;</span><br><span class="line">    <span class="keyword">if</span> (progressBlock) &#123;</span><br><span class="line">        progressBlock(receivedSize, expectedSize, targetURL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>代码块中会判断传入的 <code>progressBlock</code> 是否为空，不为空的话执行回调操作，回调方法中开发者可以处理一些其他操作。看下图：</p><p><img src="http://obzx0h1re.bkt.clouddn.com/SDWebImage_progressBlock.jpg" alt="SDWebImage_progressBlock"></p><h4 id="7-1-4、第四步-加载URL图像"><a href="#7-1-4、第四步-加载URL图像" class="headerlink" title="7.1.4、第四步 加载URL图像"></a>7.1.4、第四步 加载URL图像</h4><p>加载图像的代码比较多，接下来就在代码中加注释分析。<br>加载图像的方法是在 <code>SDWebImageManager</code>类中完成的，这里只是执行加载完成后的代码块中的内容。<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(id &lt;SDWebImageOperation&gt;)</span>loadImageWithURL:<span class="params">(nullable NSURL *)</span>url</span><br><span class="line">                                     options:<span class="params">(SDWebImageOptions)</span>options</span><br><span class="line">                                    progress:<span class="params">(nullable SDWebImageDownloaderProgressBlock)</span>progressBlock</span><br><span class="line">                                   completed:<span class="params">(nullable SDInternalCompletionBlock)</span>completedBlock</span><br></pre></td></tr></table></figure></p><p>加载图像的过程先不去考虑，先看加载完成后的代码块中执行的内容：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> &lt;SDWebImageOperation&gt; operation = [manager loadImageWithURL:url options:options progress:combinedProgressBlock completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="built_in">BOOL</span> finished, <span class="built_in">NSURL</span> *imageURL) &#123;</span><br><span class="line">        </span><br><span class="line">    __<span class="keyword">strong</span> __<span class="keyword">typeof</span> (wself) sself = wself; <span class="comment">//代码块中创建强引用</span></span><br><span class="line">    <span class="keyword">if</span> (!sself) &#123; <span class="keyword">return</span>; &#125; <span class="comment">//如果强引用的self不存在，退出block</span></span><br><span class="line"><span class="meta">#if SD_UIKIT</span></span><br><span class="line">    [sself sd_removeActivityIndicator]; <span class="comment">//不是iOS and tvOS系统的话，移除加载指示器</span></span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    <span class="comment">// if the progress not been updated, mark it to complete state （如果进度未更新，请将其标记为完成状态）</span></span><br><span class="line">    <span class="keyword">if</span> (finished &amp;&amp; !error &amp;&amp; sself.sd_imageProgress.totalUnitCount == <span class="number">0</span> &amp;&amp; sself.sd_imageProgress.completedUnitCount == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//如果加载结束、没错误、sd_imageProgress.totalUnitCount 和 sd_imageProgress.completedUnitCount 都为0，则设置两者的值为未知值</span></span><br><span class="line">        sself.sd_imageProgress.totalUnitCount = SDWebImageProgressUnitCountUnknown;</span><br><span class="line">        sself.sd_imageProgress.completedUnitCount = SDWebImageProgressUnitCountUnknown;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   是否应该回调CompletedBlock （ 加载完成 或者 传入的 options 选项 为 SDWebImageAvoidAutoSetImage）</span><br><span class="line">    <span class="built_in">BOOL</span> shouldCallCompletedBlock = finished || (options &amp; SDWebImageAvoidAutoSetImage);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断是否应该不设置Image （如果有图片但设置了SDWebImageAvoidAutoSetImage 或者没有图片并且没有设置SDWebImageDelayPlaceholder）</span></span><br><span class="line">    <span class="built_in">BOOL</span> shouldNotSetImage = ((image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage)) ||</span><br><span class="line">                              (!image &amp;&amp; !(options &amp; SDWebImageDelayPlaceholder)));</span><br><span class="line">                              </span><br><span class="line">    SDWebImageNoParamsBlock callCompletedBlockClojure = ^&#123;</span><br><span class="line">        <span class="comment">//如果view不存在，终止执行</span></span><br><span class="line">        <span class="keyword">if</span> (!sself) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">        </span><br><span class="line">        需要设置Image，就刷新视图</span><br><span class="line">        <span class="keyword">if</span> (!shouldNotSetImage) &#123;</span><br><span class="line">            [sself sd_setNeedsLayout];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果传入了completedBlock并且应该回调，则执行回调</span></span><br><span class="line">        <span class="keyword">if</span> (completedBlock &amp;&amp; shouldCallCompletedBlock) &#123;</span><br><span class="line">        <span class="comment">//回调</span></span><br><span class="line">            completedBlock(image, error, cacheType, url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// case 1a: we got an image, but the SDWebImageAvoidAutoSetImage flag is set （我们得到了一个图像，但设置了SDWebImageAvoidAutoSetImage标志）</span></span><br><span class="line">    <span class="comment">// OR</span></span><br><span class="line">    <span class="comment">// case 1b: we got no image and the SDWebImageDelayPlaceholder is not set（我们没有图像，并且没有设置SDWebImageDelayPlaceholder标志）</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">//如果不需要设置图片就在主线程队列种调用上面生成的完成回调代码块，然后停止执行</span></span><br><span class="line">    <span class="keyword">if</span> (shouldNotSetImage) &#123;</span><br><span class="line">        dispatch_main_async_safe(callCompletedBlockClojure);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化变量</span></span><br><span class="line">    <span class="built_in">UIImage</span> *targetImage = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSData</span> *targetData = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (image) &#123;</span><br><span class="line">        <span class="comment">// case 2a: we got an image and the SDWebImageAvoidAutoSetImage is not set （我们得到了一个图像，并且没有设置SDWebImageAvoidAutoSetImage）</span></span><br><span class="line">        <span class="comment">//如果图片下载成功就将其保存到变量中</span></span><br><span class="line">        targetImage = image;</span><br><span class="line">        targetData = data;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options &amp; SDWebImageDelayPlaceholder) &#123;</span><br><span class="line">        <span class="comment">// case 2b: we got no image and the SDWebImageDelayPlaceholder flag is set（我们没有图像，并且设置了SDWebImage Delay Placeholder标志）</span></span><br><span class="line">        如果图片下载失败并且设置了延迟加载占位符图像，就保存占位符图像</span><br><span class="line">        targetImage = placeholder;</span><br><span class="line">        targetData = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line"><span class="meta">#if SD_UIKIT || SD_MAC （iOS and tvOS macOS）</span></span><br><span class="line">    <span class="comment">// check whether we should use the image transition（检查我们是否应该使用图像过渡转换）</span></span><br><span class="line">    SDWebImageTransition *transition = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">//如果加载结束并且options选项为：SDWebImageForceTransition 或者 缓存类型为：SDImageCacheTypeNone</span></span><br><span class="line">    <span class="keyword">if</span> (finished &amp;&amp; (options &amp; SDWebImageForceTransition || cacheType == SDImageCacheTypeNone)) &#123;</span><br><span class="line">    <span class="comment">//保存图像过渡转换</span></span><br><span class="line">        transition = sself.sd_imageTransition;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">    dispatch_main_async_safe(^&#123;</span><br><span class="line">    <span class="comment">//主线程队列种设置图像</span></span><br><span class="line"><span class="meta">#if SD_UIKIT || SD_MAC （iOS and tvOS macOS）</span></span><br><span class="line">            设置图像</span><br><span class="line">            [sself sd_setImage:targetImage imageData:targetData basedOnClassOrViaCustomSetImageBlock:setImageBlock transition:transition cacheType:cacheType imageURL:imageURL];</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">            <span class="comment">//iWatchOS系统设置图像</span></span><br><span class="line">            [sself sd_setImage:targetImage imageData:targetData basedOnClassOrViaCustomSetImageBlock:setImageBlock];</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">            <span class="comment">//设置完成后调用完成回调代码块</span></span><br><span class="line">            callCompletedBlockClojure();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">//SDOperationsDictionary存储当前的操作。</span></span><br><span class="line">    [<span class="keyword">self</span> sd_setImageLoadOperation:operation forKey:validOperationKey];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面再使用纯描述的方式，过一遍流程：（为了简便，以下：<code>SD_UIKIT || SD_MAC</code> 简称：<code>iOS_tvOS_MAC</code>; <code>SD_MAC</code>简称：<code>MAC</code>  <code>SD_UIKIT</code> 简称 ：<code>iOS_tvOS</code>）</p><p><code>__strong</code>在<code>Block</code>内部修饰的对象,会保证,在使用这个对象在block内,这个对象都不会被释放。</p><p>之前分析过，加载指示器只能在<code>iOS_tvOS</code>的情况下添加，所以加载完成后需要移除。如下：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SD_UIKIT</span></span><br><span class="line">            [<span class="meta">sself sd_removeActivityIndicator</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><p>如果加载已经完成并且没有错误；iamge进度的总单元和完成单元都是0，就设置<code>imageProgress</code> 的总单元和完成单元值为未知。</p><p>创建 “应该执行完成加载的回调” 和 “不应该设置Image” 两个布尔值。<br><code>SDWebImageAvoidAutoSetImage</code>: 在设置图像之前手动处理一些东西（例如应用滤镜或添加交叉渐变动画）请使用此标志<br><code>SDWebImageDelayPlaceholder</code> : 延迟显示占位符图像</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载完成 或者 传入的 options 选项为 SDWebImageAvoidAutoSetImage</span></span><br><span class="line">BOOL shouldCallCompletedBlock = finished <span class="string">|| (options &amp; SDWebImageAvoidAutoSetImage);</span></span><br><span class="line"><span class="comment">//图片存在并且选项为 SDWebImageAvoidAutoSetImage 或者 图片不存在并且选项不为SDWebImageDelayPlaceholder</span></span><br><span class="line">BOOL shouldNotSetImage = ((image <span class="meta">&amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage)) ||</span></span><br><span class="line">                                    (!image <span class="meta">&amp;&amp; !(options &amp; SDWebImageDelayPlaceholder)));</span></span><br></pre></td></tr></table></figure><p><code>SDWebImageNoParamsBlock</code> 回调<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SDWebImageNoParamsBlock callCompletedBlockClojure = ^&#123;</span><br><span class="line">                <span class="keyword">if</span> (!sself) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">                <span class="keyword">if</span> (!shouldNotSetImage) &#123;</span><br><span class="line">                    <span class="comment">//需要设置Image</span></span><br><span class="line">                    [sself sd_setNeedsLayout];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//completedBlock存在并且需要回调</span></span><br><span class="line">                <span class="keyword">if</span> (completedBlock &amp;&amp; shouldCallCompletedBlock) &#123;</span><br><span class="line">                    completedBlock(<span class="keyword">image</span>, <span class="keyword">error</span>, cacheType, url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure></p><p>不需要设置Image，执行callCompletedBlockClojure回调代码<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shouldNotSetImage) &#123;</span><br><span class="line">     dispatch_main_async_safe(callCompletedBlockClojure);</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>图像和图像Data赋值：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UIImage</span> *targetImage = <span class="keyword">nil</span>;</span><br><span class="line"><span class="type">NSData</span> *targetData = <span class="keyword">nil</span>;</span><br><span class="line"><span class="keyword">if</span> (image) &#123;</span><br><span class="line">    // <span class="keyword">case</span> <span class="number">2</span>a: we got an image <span class="keyword">and</span> the <span class="type">SDWebImageAvoidAutoSetImage</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="built_in">set</span></span><br><span class="line">    targetImage = image;</span><br><span class="line">    targetData = data;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (options &amp; <span class="type">SDWebImageDelayPlaceholder</span>) &#123;</span><br><span class="line">    // <span class="keyword">case</span> <span class="number">2</span>b: we got no image <span class="keyword">and</span> the <span class="type">SDWebImageDelayPlaceholder</span> flag <span class="keyword">is</span> <span class="built_in">set</span></span><br><span class="line">    targetImage = placeholder;</span><br><span class="line">    targetData = <span class="keyword">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果系统类型为：<code>iOS_tvOS_MAC</code>，图像过渡动画赋值<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#if SD_UIKIT || SD_MAC</span></span><br><span class="line">    //<span class="built_in"> check </span>whether we should use the image transition</span><br><span class="line">    SDWebImageTransition *transition = nil;</span><br><span class="line">   <span class="built_in"> if </span>(finished &amp;&amp; (options &amp; SDWebImageForceTransition || cacheType == SDImageCacheTypeNone)) &#123;</span><br><span class="line">        transition = sself.sd_imageTransition;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">#endif</span></span><br></pre></td></tr></table></figure></p><p>执行异步安全加载，根据不同的系统执行不同的方法。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">dispatch_main_async_safe(^&#123;</span></span><br><span class="line"><span class="comment">#if SD_UIKIT || SD_MAC</span></span><br><span class="line">                <span class="string">[sself</span> <span class="attr">sd_setImage:targetImage</span> <span class="attr">imageData:targetData</span> <span class="attr">basedOnClassOrViaCustomSetImageBlock:setImageBlock</span> <span class="attr">transition:transition</span> <span class="attr">cacheType:cacheType</span> <span class="attr">imageURL:imageURL];</span></span><br><span class="line"><span class="comment">#else</span></span><br><span class="line">                <span class="string">[sself</span> <span class="attr">sd_setImage:targetImage</span> <span class="attr">imageData:targetData</span> <span class="attr">basedOnClassOrViaCustomSetImageBlock:setImageBlock];</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">                <span class="string">callCompletedBlockClojure();</span></span><br><span class="line">            <span class="string">&#125;);</span></span><br><span class="line">        <span class="string">&#125;];</span></span><br></pre></td></tr></table></figure></p><p>以上就是大体加载图像所展示的流程</p><p>接下来看一下需要动画翻转过渡的代码（可以使用动画过渡的是<code>iOS_tvOS_MAC</code>）<br>其实就是多加了一个转换动画的执行代码。其他的就是UIImageView和UIButton 的图像设置。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#if SD_UIKIT || SD_MAC</span></span><br><span class="line">- (<span class="keyword">void</span>)sd_setImage:(<span class="built_in">UIImage</span> *)image imageData:(<span class="built_in">NSData</span> *)imageData basedOnClassOrViaCustomSetImageBlock:(SDSetImageBlock)setImageBlock transition:(SDWebImageTransition *)transition cacheType:(SDImageCacheType)cacheType imageURL:(<span class="built_in">NSURL</span> *)imageURL &#123;</span><br><span class="line">    <span class="built_in">UIView</span> *view = <span class="keyword">self</span>;</span><br><span class="line">    <span class="comment">//最终的图像设置block</span></span><br><span class="line">    SDSetImageBlock finalSetImageBlock;</span><br><span class="line">    <span class="comment">//若setImageBlock，说明是Button需要自定义图像。</span></span><br><span class="line">    <span class="keyword">if</span> (setImageBlock) &#123;</span><br><span class="line">        finalSetImageBlock = setImageBlock;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([view isKindOfClass:[<span class="built_in">UIImageView</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">    <span class="comment">//若View为ImageView，执行block回调，为imageView赋值</span></span><br><span class="line">        <span class="built_in">UIImageView</span> *imageView = (<span class="built_in">UIImageView</span> *)view;</span><br><span class="line">        finalSetImageBlock = ^(<span class="built_in">UIImage</span> *setImage, <span class="built_in">NSData</span> *setImageData) &#123;</span><br><span class="line">            imageView.image = setImage;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#if SD_UIKIT</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([view isKindOfClass:[<span class="built_in">UIButton</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">     <span class="comment">//若View为button，执行block回调，为button赋值</span></span><br><span class="line">        <span class="built_in">UIButton</span> *button = (<span class="built_in">UIButton</span> *)view;</span><br><span class="line">        finalSetImageBlock = ^(<span class="built_in">UIImage</span> *setImage, <span class="built_in">NSData</span> *setImageData)&#123;</span><br><span class="line">            [button setImage:setImage forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//动画过渡执行代码</span></span><br><span class="line">    <span class="keyword">if</span> (transition) &#123;</span><br><span class="line"><span class="meta">#if SD_UIKIT</span></span><br><span class="line">        [<span class="built_in">UIView</span> transitionWithView:view duration:<span class="number">0</span> options:<span class="number">0</span> animations:^&#123;</span><br><span class="line">            <span class="comment">// 0 duration to let UIKit render placeholder and prepares block</span></span><br><span class="line">            <span class="keyword">if</span> (transition.prepares) &#123;</span><br><span class="line">                transition.prepares(view, image, imageData, cacheType, imageURL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">            [<span class="built_in">UIView</span> transitionWithView:view duration:transition.duration options:transition.animationOptions animations:^&#123;</span><br><span class="line">                <span class="keyword">if</span> (finalSetImageBlock &amp;&amp; !transition.avoidAutoSetImage) &#123;</span><br><span class="line">                    finalSetImageBlock(image, imageData);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (transition.animations) &#123;</span><br><span class="line">                    transition.animations(view, image);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; completion:transition.completion];</span><br><span class="line">        &#125;];</span><br><span class="line"><span class="meta">#elif SD_MAC</span></span><br><span class="line">        [<span class="built_in">NSAnimationContext</span> runAnimationGroup:^(<span class="built_in">NSAnimationContext</span> * _Nonnull prepareContext) &#123;</span><br><span class="line">            <span class="comment">// 0 duration to let AppKit render placeholder and prepares block</span></span><br><span class="line">            prepareContext.duration = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (transition.prepares) &#123;</span><br><span class="line">                transition.prepares(view, image, imageData, cacheType, imageURL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; completionHandler:^&#123;</span><br><span class="line">            [<span class="built_in">NSAnimationContext</span> runAnimationGroup:^(<span class="built_in">NSAnimationContext</span> * _Nonnull context) &#123;</span><br><span class="line">                context.duration = transition.duration;</span><br><span class="line">                context.timingFunction = transition.timingFunction;</span><br><span class="line">                context.allowsImplicitAnimation = (transition.animationOptions &amp; SDWebImageAnimationOptionAllowsImplicitAnimation);</span><br><span class="line">                <span class="keyword">if</span> (finalSetImageBlock &amp;&amp; !transition.avoidAutoSetImage) &#123;</span><br><span class="line">                    finalSetImageBlock(image, imageData);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (transition.animations) &#123;</span><br><span class="line">                    transition.animations(view, image);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; completionHandler:^&#123;</span><br><span class="line">                <span class="keyword">if</span> (transition.completion) &#123;</span><br><span class="line">                    transition.completion(<span class="literal">YES</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;];</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (finalSetImageBlock) &#123;</span><br><span class="line">            finalSetImageBlock(image, imageData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><p>以上就是 <code>SDWebImage</code> 设置图片的整个流程，但只是过了一遍代码而已，内部的实现并没有深入，例如：<code>SDWebImage</code> 的下载、缓存机制。这些都没有深入去了解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SDWebImage整体的框架：&lt;/p&gt;
&lt;figure class=&quot;highlight gherkin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;lin
      
    
    </summary>
    
      <category term="iOS" scheme="http://guohuaden.com/categories/iOS/"/>
    
    
      <category term="SDWebImage" scheme="http://guohuaden.com/tags/SDWebImage/"/>
    
  </entry>
  
  <entry>
    <title>copy 和 mutableCopy</title>
    <link href="http://guohuaden.com/2018/06/30/copyAndMutableCopy/"/>
    <id>http://guohuaden.com/2018/06/30/copyAndMutableCopy/</id>
    <published>2018-06-30T06:16:37.000Z</published>
    <updated>2018-10-24T11:01:54.936Z</updated>
    
    <content type="html"><![CDATA[<p>今天来谈下深浅拷贝【copy 和 mutableCopy】</p><p>想写这篇文章，是因为看到了一个有意思的文章，对于其中的一些观点不太认同，所以想简单分析一下深浅拷贝</p><p>先看一段代码，稍后会对代码进行分析</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)testOne</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *test = @[@<span class="number">1</span>,@<span class="number">2</span>,@<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"test-&gt;%p\n"</span>,test);</span><br><span class="line">    <span class="built_in">NSArray</span> *testCopy = [test <span class="keyword">copy</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"testCopy-&gt;%p\n"</span>,testCopy);</span><br><span class="line">    <span class="built_in">NSArray</span> *testMutableCopy = [test mutableCopy];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"testMutableCopy-&gt;%p\n"</span>,testMutableCopy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>很简单的创建一个数组，对其进行copy和mutableCopy操作，打印其内存地址。结果看图会知道：<br>test和testCopy 内存地址是一样的，而testMutableCopy的内存地址是和test不同的。</p><p><strong>小总结：</strong></p><ol><li><code>copy</code> 只是拷贝指向对象的指针，并没有出现新的内存地址，我们称之为<strong>浅拷贝</strong>：</li><li><code>mutableCopy</code> 拷贝整个对象内存到另一块内存中，是产生了新的内存地址。</li></ol><p><img src="http://obzx0h1re.bkt.clouddn.com/copyAndMutableCopy_one.png" alt="copy和mutableCopy操作1"></p><hr><p>再看下面的一段代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)testTwo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"\n"</span>);</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *test2 = [<span class="built_in">NSMutableArray</span> arrayWithObjects:<span class="string">@"1"</span>,<span class="string">@"2"</span>,<span class="string">@"3"</span>, <span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"test2-&gt;%p\n"</span>,test2);</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *testCopy2 = [test2 <span class="keyword">copy</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"testCopy2-&gt;%p\n"</span>,testCopy2);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableArray</span> *testMutableCopy2 = [test2 mutableCopy];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"testMutableCopy2-&gt;%p\n"</span>,testMutableCopy2);</span><br><span class="line">    </span><br><span class="line">    [test2 addObject:<span class="string">@"A"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里不能对数组做操作， 可变数组的copy属于深拷贝，和mutableCopy一样都是将数组拷贝一份存入新的内存中，但通过mutableCopy得到的可变数组可以再操作，而copy出来的是不可变数组。</span></span><br><span class="line"><span class="comment">//    [testCopy2 removeObject:@"1"];</span></span><br><span class="line"><span class="comment">//    [testCopy2 addObject:@"B"]; </span></span><br><span class="line">    </span><br><span class="line">    [testMutableCopy2 addObject:<span class="string">@"C"</span>];</span><br><span class="line">    [testMutableCopy2 removeObject:<span class="string">@"3"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"test2 = %@, testCopy2 =%@,testMutableCopy2 = %@"</span>,test2,testCopy2,testMutableCopy2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//打印结果： test2 = @[1,2,3,A]   testCopy2 = @[1,2,3]   testMutableCopy2 = @[1,2,3,C]</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析：</strong><br>上面这段代码会和之前的不一样，我们这里创建的是一个可变数组，然后对可变数组进行<code>copy</code>和<code>mutableCopy</code>操作。发现打印其内存地址都不一样，<br>这说明对可变数组进行<code>copy</code>和<code>mutableCopy</code>都是深拷贝。<br>但你会发现<code>copy</code>得到的数组不能添加删除操作，这是因为<code>copy</code>得到的是不可变数组。</p><p><strong>小总结：</strong></p><p>可变数组的<code>copy</code>和<code>mutableCopy</code>都是深拷贝</p><p><img src="http://obzx0h1re.bkt.clouddn.com/copyAndMutableCopy_two.png" alt="copy和mutableCopy操作2"></p><p>最后一段代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-(void)testThree</span><br><span class="line">&#123;</span><br><span class="line">    NSMutableArray *test4 = [NSMutableArray arrayWithObjects:<span class="type"></span>@<span class="string">"1"</span>,@<span class="string">"2"</span>,@<span class="string">"3"</span>, nil];</span><br><span class="line">    NSMutableArray *<span class="keyword">new</span><span class="type">Test</span> = [NSMutableArray arrayWithObject:<span class="type">test4</span>];</span><br><span class="line">    NSMutableArray *testMutableCopy4 = [<span class="keyword">new</span><span class="type">Test</span> mutableCopy];<span class="comment">//拷贝出来的是NSMutableArray类型数组</span></span><br><span class="line">    NSLog(@<span class="string">"newTest-&gt;%p,testMutableCopy4-&gt;%p\n"</span>,<span class="keyword">new</span><span class="type">Test</span>,testMutableCopy4);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//copy的先不说， 我们看下mutableCopy得到的数组，你会发现通过mutableCopy得到的数组中的元素地址是不变的</span></span><br><span class="line">    NSLog(@<span class="string">"newTest.first-&gt;%p,testMutableCopy4first-&gt;%p\n"</span>,<span class="keyword">new</span><span class="type">Test</span>.firstObject,testMutableCopy4.firstObject);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//test</span></span><br><span class="line">    [testMutableCopy4.firstObject addObject:<span class="type"></span>@<span class="number">6</span>];</span><br><span class="line">    [<span class="keyword">new</span><span class="type">Test</span>.firstObject addObject:<span class="type"></span>@<span class="string">"12"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//打印出来这里两个数组，会发现结果是一样的，原因就是mutableCopy的深拷贝是容器和其中的元素，但元素的地址并没有改变，修改其中的元素中的内容，结果必然都改变</span></span><br><span class="line">    </span><br><span class="line">    NSLog(@<span class="string">"newTest = %@,testMutableCopy2 = %@"</span>,<span class="keyword">new</span><span class="type">Test</span>,testMutableCopy4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>通过<code>mutableCopy</code>得到的数组，你会发现通过<code>mutableCopy</code>得到的数组中的元素地址是不变的。如果你往数组的元素中添加或删除元素，会发现newTest和testMutableCopy4中的元素都发生了改变。</p><p><strong>小总结：</strong></p><p>集合对象的内容复制（mutableCopy）仅限于对象本身，对象中的元素仍然是指针复制。</p><p><img src="http://obzx0h1re.bkt.clouddn.com/copyAndMutableCopy_four.png" alt="copy和mutableCopy操作4"></p><p>关于这点其实苹果官网文档中<code>CopyFunctions</code>给了解释，看下以下介绍：</p><p><strong>关于复制的介绍：</strong></p><blockquote><p>Copy Functions<br>In general, a standard copy operation, which might also be called simple assignment, occurs when you use the = operator to assign the value of one variable to another. The expression myInt2 = myInt1, for example, causes the integer contents of myInt1 to be copied from the memory used by myInt1 into the memory used by myInt2. Following the copy operation, two separate areas of memory contain the same value. However, if you attempt to copy a Core Foundation object in this way, be aware that you will not duplicate the object itself, only the reference to the object.</p></blockquote><blockquote><p>For example, someone new to Core Foundation might think that to make a copy of a CFString object she would use the expression myCFString2 = myCFString1. Again, this expression does not actually copy the string data. Because both myCFString1 and myCFString2 must have the CFStringRef type, this expression only copies the reference to the object. Following the copy operation, you have two copies of the reference to the CFString. This type of copy is very fast because only the reference is duplicated, but it is important to remember that copying a mutable object in this way is dangerous. As with programs that use global variables, if one part of your application changes an object using a copy of the reference, there is no way for other parts of the program which have copies of that reference to know that the data has changed.</p></blockquote><blockquote><p>If you want to duplicate an object, you must use one of the functions provided by Core Foundation specifically for this purpose. Continuing with the CFString example, you would use CFStringCreateCopy to create an entirely new CFString object containing the same data as the original. Core Foundation types which have “CreateCopy” functions also provide the variant “CreateMutableCopy” which returns a copy of an object that can be modified.</p></blockquote><p><strong>浅拷贝：</strong></p><blockquote><p>Shallow Copy<br>Copying compound objects, objects such as collection objects that can contain other objects, must also be done with care. As you would expect, using the = operator to perform a copy on these objects results in a duplication of the object reference. In contrast to simple objects like CFString and CFData, the “CreateCopy” functions provided for compound objects such as CFArray and CFSet actually perform a shallow copy. In the case of these objects, a shallow copy means that a new collection object is created, but the contents of the original collection are not duplicated—only the object references are copied to the new container. This type of copy is useful if, for example, you have an array that’s immutable and you want to reorder it. In this case, you don’t want to duplicate all of the contained objects because there’s no need to change them—and why use up that extra memory? You just want the set of included objects to be changed. The same risks apply here as with copying object references with simple types.</p></blockquote><p><strong>深拷贝：</strong></p><blockquote><p>Deep Copy<br>When you want to create an entirely new compound object, you must perform a deep copy. A deep copy duplicates the compound object as well as the contents of all of its contained objects. The current release of Core Foundation includes a function that performs deep copying of a property list (see CFPropertyListCreateDeepCopy). If you want to create deep copies of other structures, you could perform the deep copy yourself by recursively descending into the compound object and copying all of its contents one by one. Take care in implementing this functionality as compound objects can be recursive—they may directly or indirectly contain a reference to themselves—which can cause a recursive loop.</p></blockquote><p>引用自：<a href="https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/CopyFunctions.html#//apple_ref/doc/uid/20001149-CJBEJBHH" target="_blank" rel="noopener">苹果官网文档-CopyFunctions</a></p><p><strong>小总结：</strong></p><p>我们通过对集合类对象进行mutableCopy得到的新对象，从某种意义上来说，并不是真正的深层次的复制，严格意义上说：它只是一个单层次的深复制。原因上面已说明：集合对象的内容复制（mutableCopy）仅限于对象本身，对象中的元素仍然是指针复制。</p><p>那如果需要深层次的复制，就需要以递归的形式找到集合中的元素对象，再对元素对象进行mutableCopy，以此来实现深层次的复制。但Apple并不提倡这种方式，因为这可能会导致递归循环。</p><p>最后总结：</p><ol><li>不管是集合类对象还是非集合类对象，copy和mutableCopy时，都遵循以下准则：<ol><li>copy得到的都是不可变对象（imutable），所以对其copy返回的对象做可变对象的操作，都会崩溃。</li><li>mutableCopy返回的是可变对象（mutable）</li></ol></li><li>在非集合类对象中：<ol><li>对不可变对象进行copy操作，是指针复制，其内存地址不变。</li><li>对不可变对象进行mutableCopy操作，是内容复制，其内存地址改变。</li><li>对可变对象进行copy和mutableCopy操作，都是内容复制，其内存地址改变。</li></ol></li><li>在集合类对象中：<ol><li>对不可变对象进行copy操作，是指针复制，其内存地址不变。</li><li>对不可变对象进行mutableCopy操作，是内容复制，其内存地址改变。</li><li>对可变对象进行copy和mutableCopy操作，都是内容复制，其内存地址改变。但集合对象的内容复制仅限于对象本身，对象中的元素仍然是指针复制。</li></ol></li></ol><p>最后可以看下这个Apple的官方文档《<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Collections/Articles/Copying.html#//apple_ref/doc/uid/TP40010162-SW1" target="_blank" rel="noopener">苹果官网文档-Copying</a>》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天来谈下深浅拷贝【copy 和 mutableCopy】&lt;/p&gt;
&lt;p&gt;想写这篇文章，是因为看到了一个有意思的文章，对于其中的一些观点不太认同，所以想简单分析一下深浅拷贝&lt;/p&gt;
&lt;p&gt;先看一段代码，稍后会对代码进行分析&lt;/p&gt;
&lt;figure class=&quot;highli
      
    
    </summary>
    
      <category term="iOS" scheme="http://guohuaden.com/categories/iOS/"/>
    
    
      <category term="copy, mutableCopy" scheme="http://guohuaden.com/tags/copy-mutableCopy/"/>
    
  </entry>
  
  <entry>
    <title>项目总结四</title>
    <link href="http://guohuaden.com/2018/06/03/Project-summary-Four/"/>
    <id>http://guohuaden.com/2018/06/03/Project-summary-Four/</id>
    <published>2018-06-03T04:01:57.000Z</published>
    <updated>2018-10-24T11:03:47.552Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>最近都一直在忙新项目的事，真是倍感身心疲别啊。目前项目终于成型，也算时间宽松渐缓吧，就把项目中遇到的一些问题做个总结。</p><h4 id="1、textField限制输入的位数以及小数点的位数"><a href="#1、textField限制输入的位数以及小数点的位数" class="headerlink" title="1、textField限制输入的位数以及小数点的位数"></a>1、textField限制输入的位数以及小数点的位数</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)textField:(<span class="built_in">UITextField</span> *)textField shouldChangeCharactersInRange:(<span class="built_in">NSRange</span>)range replacementString:(<span class="built_in">NSString</span> *)string;</span><br><span class="line">&#123; </span><br><span class="line"> <span class="comment">//string就是此时输入的那个字符textField就是此时正在输入的那个输入框返回YES就是可以改变输入框的值NO相反</span></span><br><span class="line">    <span class="built_in">NSString</span> * toBeString = [textField.text     stringByReplacingCharactersInRange:range withString:string]; </span><br><span class="line">    <span class="comment">// 判断是否输入内容，或者用户点击的是键盘的删除按钮</span></span><br><span class="line">    <span class="keyword">if</span> (![string isEqualToString:<span class="string">@""</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([textField isEqual:<span class="keyword">self</span>.textField]) &#123;</span><br><span class="line">            <span class="comment">// 小数点在字符串中的位置 第一个数字从0位置开始</span></span><br><span class="line">            <span class="built_in">NSInteger</span> dotLocation = [textField.text rangeOfString:<span class="string">@"."</span>].location;</span><br><span class="line">            <span class="keyword">if</span> (dotLocation == <span class="built_in">NSNotFound</span> &amp;&amp; range.location != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//没有小数点,最大数值</span></span><br><span class="line">                <span class="keyword">if</span> (range.location &gt;= <span class="number">9</span>)&#123;</span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@"单笔金额不能超过亿位"</span>);</span><br><span class="line">                    <span class="keyword">if</span> ([string isEqualToString:<span class="string">@"."</span>] &amp;&amp; range.location == <span class="number">9</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断输入多个小数点,禁止输入多个小数点</span></span><br><span class="line">            <span class="keyword">if</span> (dotLocation != <span class="built_in">NSNotFound</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> ([string isEqualToString:<span class="string">@"."</span>])<span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断小数点后最多两位</span></span><br><span class="line">            <span class="keyword">if</span> (dotLocation != <span class="built_in">NSNotFound</span> &amp;&amp; range.location &gt; dotLocation + <span class="number">2</span>) &#123; <span class="keyword">return</span> <span class="literal">NO</span>; &#125;</span><br><span class="line">            <span class="comment">//判断总长度</span></span><br><span class="line">            <span class="keyword">if</span> (textField.text.length &gt; <span class="number">11</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、禁用第三方键盘"><a href="#2、禁用第三方键盘" class="headerlink" title="2、禁用第三方键盘"></a>2、禁用第三方键盘</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application shouldAllowExtensionPointIdentifier:(<span class="built_in">NSString</span> *)extensionPointIdentifier</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、延迟执行"><a href="#3、延迟执行" class="headerlink" title="3、延迟执行"></a>3、延迟执行</h4><p>取消延迟执行函<code>cancelPreviousPerformRequestsWithTarget</code></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">延迟执行函数</span><br><span class="line">[self <span class="string">performSelector:</span><span class="meta">@selector</span>(scrollDone) <span class="string">withObject:</span>nil <span class="string">afterDelay:</span><span class="number">0.5</span>];</span><br><span class="line"></span><br><span class="line">在<span class="number">0.5</span>秒内取消执行函数，带的参数必须一样，才能取消成功</span><br><span class="line">[NSObject <span class="string">cancelPreviousPerformRequestsWithTarget:</span>self <span class="string">selector:</span><span class="meta">@selector</span>(scrollDone) <span class="string">object:</span>nil];</span><br></pre></td></tr></table></figure><h4 id="4、关于浮点数精度问题"><a href="#4、关于浮点数精度问题" class="headerlink" title="4、关于浮点数精度问题"></a>4、关于浮点数精度问题</h4><p>大部分开发是不需要关心浮点数精度问题，但在股票等软件开发中，浮点数精度问题会显得很重要，这时就需要用到十进制数字类<code>NSDecimalNumber</code>，这个类继承自NSNumber，苹果针对浮点类型计算精度问题提供出来的计算类，基于十进制的科学计数法来计算，同时可以指定舍入模式，一般用于货币计算。</p><h4 id="5、判断是否为单页-是就执行js"><a href="#5、判断是否为单页-是就执行js" class="headerlink" title="5、判断是否为单页,是就执行js"></a>5、判断是否为单页,是就执行js</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *jsStr=<span class="string">@"if(window.historyBack)historyBack();else window.inject.finish();"</span>;</span><br><span class="line">[_webView evaluateJavaScript:jsStr completionHandler:^(<span class="keyword">id</span> _Nullable response, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"No error"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        [<span class="keyword">super</span> leftAction];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><hr><p><strong>注</strong>：先写到这里，其他以后补充。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h3&gt;&lt;p&gt;最近都一直在忙新项目的事，真是倍感身心疲别啊。目前项目终于成型，也算时间宽松渐缓吧，就把项目中遇到的一些问题做个总结。&lt;/p&gt;
&lt;h
      
    
    </summary>
    
      <category term="项目总结" scheme="http://guohuaden.com/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="iOS" scheme="http://guohuaden.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS之项目总结三：项目开发中遇到的一些问题及解决方案</title>
    <link href="http://guohuaden.com/2017/10/05/project-summary-Three/"/>
    <id>http://guohuaden.com/2017/10/05/project-summary-Three/</id>
    <published>2017-10-05T03:19:10.000Z</published>
    <updated>2018-10-24T11:04:06.739Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>两年多以来，基本上都是独立开发或者维护项目，不得不自嘲的说挺锻炼人的。最近的一家公司是涉足金融行列的，算是第一次踏足金融吧，过程怎样不说，确实学到了不少东西。</p><p><strong><em>下面就开发第一款金融类项目遇到的问题做一下总结：</em></strong></p><h4 id="1、中文显示标题之类"><a href="#1、中文显示标题之类" class="headerlink" title="1、中文显示标题之类"></a>1、中文显示标题之类</h4><p>我们在项目中调用相册、相机等往往默认的是显示英文，但有时候开发的项目是针对国内的，所以需要中文配合显示，这就需要我们做一下配置。<br>其实很简单：就是在<code>info.plist</code>中允许应用程序获取框架内语言即可。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Localizedresources can be mixed  YES</span><br><span class="line">Localization <span class="keyword">native</span> development region  China <span class="comment">//en</span></span><br></pre></td></tr></table></figure><p>图片显示：</p><p><img src="http://obzx0h1re.bkt.clouddn.com/project_summary_lauguageSet.png" alt="允许应用程序获取框架内语言图片"></p><h4 id="2、运行报错问题"><a href="#2、运行报错问题" class="headerlink" title="2、运行报错问题"></a>2、运行报错问题</h4><p>报错信息：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld: <span class="number">4</span> duplicate symbols <span class="keyword">for</span> architecture arm64 clang: error: linker command failed with <span class="keyword">exit</span></span><br></pre></td></tr></table></figure><p>这个是粗心大意而差生的报错，最可能的情况是：引入【.h】文件重复。<br>我们知道iOS不允许在A类中重复引入相同的B类的，使用<code>improt</code>关键字引入头文件时，它会判断是否已经引入，如果引入了一次就不在引入。但并不能直接提示报错，所以在运行时会提示上面的报错信息。所以首先要做的是排查是否重复引入【.h】文件。</p><h4 id="3、在使用jsonModel做项目的数据解析时，出现一个属性名字不确定是否存在的情况"><a href="#3、在使用jsonModel做项目的数据解析时，出现一个属性名字不确定是否存在的情况" class="headerlink" title="3、在使用jsonModel做项目的数据解析时，出现一个属性名字不确定是否存在的情况"></a>3、在使用jsonModel做项目的数据解析时，出现一个属性名字不确定是否存在的情况</h4><p>这个问题是没有技术含量的，遇到了解决就行，方法如下：<br>在【.m】文件中添加下面的方法即可</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+(<span class="built_in">BOOL</span>)propertyIsOptional:(<span class="built_in">NSString</span>*)propertyName</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、AES加密遇到的和android统一加密模式问题"><a href="#4、AES加密遇到的和android统一加密模式问题" class="headerlink" title="4、AES加密遇到的和android统一加密模式问题"></a>4、AES加密遇到的和<em>android</em>统一加密模式问题</h4><p>这种情况我以前在《<a href="http://guohuaden.com/2016/10/06/DES-encryption/">Base64加密和DES加密、以及JAVA和iOS中DES加密统一性问题</a>》这篇文章中有提到多，主要是iOS这边SDK中只提供了两种模式：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@constant   kCCOptionPKCS7Padding   Perform PKCS7 padding.</span><br><span class="line">@constant   kCCOptionECBMode        Electronic Code Book Mode.</span><br><span class="line">                                    Default is CBC.</span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    / options <span class="keyword">for</span> block ciphers /</span><br><span class="line">    kCCOptionPKCS7Padding   = <span class="number">0x0001</span>,</span><br><span class="line">    kCCOptionECBMode        = <span class="number">0x0002</span></span><br><span class="line">    / stream ciphers currently have no options /</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但安卓的不一样，有十几种左右，所以在开发中一定要和安卓、服务器端做好统一。</p><ol><li>如果使用CBC模式，那直接用：<code>kCCOptionPKCS7Padding</code>即可。</li><li>但如果是ECB模式，就需要做下转变 <code>kCCOptionECBMode | kCCOptionPKCS7Padding</code></li></ol><h4 id="5、服务器端小数显示问题（如：1e-05）"><a href="#5、服务器端小数显示问题（如：1e-05）" class="headerlink" title="5、服务器端小数显示问题（如：1e-05）"></a>5、服务器端小数显示问题（如：1e-05）</h4><p>这个做下处理即可：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDecimalNumber</span> *decNumber = [<span class="built_in">NSDecimalNumber</span> decimalNumberWithString:leastWaveStr];</span><br><span class="line"><span class="built_in">NSString</span> *numberStr = [decNumber stringValue];</span><br></pre></td></tr></table></figure><p>金融类项目中常用到这个<code>NSDecimalNumber</code> ,用于货币处理 。<br>通过<code>NSDecimalNumber</code>提供的计算方式，可以很好的计算出准确的精度的数据，同时不需要使用格式化输出等。</p><h4 id="6、自定义导航栏按钮不靠左／右问题"><a href="#6、自定义导航栏按钮不靠左／右问题" class="headerlink" title="6、自定义导航栏按钮不靠左／右问题"></a>6、自定义导航栏按钮不靠左／右问题</h4><p>很简单，解决方法，添加一个空的按钮进去</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIButton</span> *leftButton = [[<span class="built_in">UIButton</span> alloc]init];</span><br><span class="line">leftButton.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line">[leftButton setBackgroundImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"back.png"</span>] forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">[leftButton addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(popToLastVC:) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line"><span class="built_in">UIBarButtonItem</span> *leftBarButtonItems = [[<span class="built_in">UIBarButtonItem</span> alloc]initWithCustomView:leftButton];</span><br><span class="line"><span class="comment">//解决按钮不靠左 靠右的问题.</span></span><br><span class="line"><span class="built_in">UIBarButtonItem</span> *nagetiveSpacer = [[<span class="built_in">UIBarButtonItemalloc</span>]initWithBarButtonSystemItem:<span class="built_in">UIBarButtonSystemItemFixedSpace</span></span><br><span class="line">target:<span class="literal">nil</span> action:<span class="literal">nil</span>];</span><br><span class="line">nagetiveSpacer.width = <span class="number">-15</span>;<span class="comment">//这个值可以根据自己需要自己调整</span></span><br><span class="line"><span class="keyword">self</span>.navigationItem.leftBarButtonItems = @[nagetiveSpacer, leftBarButtonItems];</span><br></pre></td></tr></table></figure><h4 id="7、不同屏幕尺寸字体显示字体大小问题"><a href="#7、不同屏幕尺寸字体显示字体大小问题" class="headerlink" title="7、不同屏幕尺寸字体显示字体大小问题"></a>7、不同屏幕尺寸字体显示字体大小问题</h4><p>我们应该清楚，UI设计图大多数是以iPhone6 为模版设计的，但开发中腰考虑不同的屏幕尺寸显示字体大小不同的情况。<br>网上给出的大多数是针对<code>Xib</code>和<code>storyboard</code>做的处理，下面我说一下针对纯代码开发的处理方法。<br>其实很简单，在pch文件中设置宏定义，针对不同的机型做一下简单判断，在开发中使用宏定义字体大小就可以了。<br>例如：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">kDevice_Is_iPhone4</span> ([UIScreen <span class="attribute">instancesRespondToSelector</span>:<span class="variable">@selector</span>(currentMode)] ? CGSizeEqualToSize(CGSizeMake(<span class="number">640</span>, <span class="number">960</span>), [[UIScreen mainScreen] currentMode].size) : NO)</span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">kDevice_Is_iPhone5</span> ([UIScreen <span class="attribute">instancesRespondToSelector</span>:<span class="variable">@selector</span>(currentMode)] ? CGSizeEqualToSize(CGSizeMake(<span class="number">640</span>, <span class="number">1136</span>), [[UIScreen mainScreen] currentMode].size) : NO)</span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">kDevice_Is_iPhone6</span> ([UIScreen <span class="attribute">instancesRespondToSelector</span>:<span class="variable">@selector</span>(currentMode)] ? CGSizeEqualToSize(CGSizeMake(<span class="number">750</span>, <span class="number">1334</span>), [[UIScreen mainScreen] currentMode].size) : NO)</span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">kDevice_Is_iPhone6Plus</span> ([UIScreen <span class="attribute">instancesRespondToSelector</span>:<span class="variable">@selector</span>(currentMode)] ? CGSizeEqualToSize(CGSizeMake(<span class="number">1242</span>, <span class="number">2208</span>), [[UIScreen mainScreen] currentMode].size) : NO)</span><br><span class="line"><span class="comment">//字体大小（以6s为基准,以6p为判断）</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">kFontSize10</span>  <span class="selector-tag">kDevice_Is_iPhone6Plus</span> ? <span class="selector-tag">12</span><span class="selector-pseudo">:10</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">kFontSize11</span>  <span class="selector-tag">kDevice_Is_iPhone6Plus</span> ? <span class="selector-tag">13</span><span class="selector-pseudo">:11</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">kFontSize12</span>  <span class="selector-tag">kDevice_Is_iPhone6Plus</span> ? <span class="selector-tag">14</span><span class="selector-pseudo">:12</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">kFontSize13</span>  <span class="selector-tag">kDevice_Is_iPhone6Plus</span> ? <span class="selector-tag">15</span><span class="selector-pseudo">:13</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">kFontSize14</span>  <span class="selector-tag">kDevice_Is_iPhone6Plus</span> ? <span class="selector-tag">16</span><span class="selector-pseudo">:14</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">kFontSize15</span>  <span class="selector-tag">kDevice_Is_iPhone6Plus</span> ? <span class="selector-tag">17</span><span class="selector-pseudo">:15</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">kFontSize16</span>  <span class="selector-tag">kDevice_Is_iPhone6Plus</span> ? <span class="selector-tag">18</span><span class="selector-pseudo">:16</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">kFontSize17</span>  <span class="selector-tag">kDevice_Is_iPhone6Plus</span> ? <span class="selector-tag">19</span><span class="selector-pseudo">:17</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">kFontSize18</span>  <span class="selector-tag">kDevice_Is_iPhone6Plus</span> ? <span class="selector-tag">20</span><span class="selector-pseudo">:18</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">kFontSize19</span>  <span class="selector-tag">kDevice_Is_iPhone6Plus</span> ? <span class="selector-tag">21</span><span class="selector-pseudo">:19</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">kFontSize20</span>  <span class="selector-tag">kDevice_Is_iPhone6Plus</span> ? <span class="selector-tag">22</span><span class="selector-pseudo">:20</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">kFontSize21</span>  <span class="selector-tag">kDevice_Is_iPhone6Plus</span> ? <span class="selector-tag">23</span><span class="selector-pseudo">:21</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">kFontSize22</span>  <span class="selector-tag">kDevice_Is_iPhone6Plus</span> ? <span class="selector-tag">24</span><span class="selector-pseudo">:22</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">kFontSize23</span>  <span class="selector-tag">kDevice_Is_iPhone6Plus</span> ? <span class="selector-tag">25</span><span class="selector-pseudo">:23</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">kFontSize24</span>  <span class="selector-tag">kDevice_Is_iPhone6Plus</span> ? <span class="selector-tag">26</span><span class="selector-pseudo">:24</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">kFontSize25</span>  <span class="selector-tag">kDevice_Is_iPhone6Plus</span> ? <span class="selector-tag">27</span><span class="selector-pseudo">:25</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">kFontSize34</span>  <span class="selector-tag">kDevice_Is_iPhone6Plus</span> ? <span class="selector-tag">35</span><span class="selector-pseudo">:34</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">kFontSize36</span>  <span class="selector-tag">kDevice_Is_iPhone6Plus</span> ? <span class="selector-tag">38</span><span class="selector-pseudo">:36</span></span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UILabel *<span class="keyword">label</span><span class="bash"> = [UILabel new];</span></span><br><span class="line"><span class="bash">label.text = @<span class="string">""</span>;</span></span><br><span class="line"><span class="bash">label.textColor = [UIColor darkGrayColor];</span></span><br><span class="line"><span class="bash">label.textAlignment = NSTextAlignmentCenter;</span></span><br><span class="line"><span class="bash">label.font = [UIFont systemFontOfSize:kFontSize16];</span></span><br><span class="line"><span class="bash">[self addSubview:label];</span></span><br></pre></td></tr></table></figure><p>这样就不需要每次使用字体都判断不同屏幕尺寸了。</p><h4 id="8、view上有tableView，view添加手势后与tableView手势冲突问题"><a href="#8、view上有tableView，view添加手势后与tableView手势冲突问题" class="headerlink" title="8、view上有tableView，view添加手势后与tableView手势冲突问题"></a>8、view上有tableView，view添加手势后与tableView手势冲突问题</h4><p> 解决这个问题，我们需要利用系统的方法做个判断：如果点击了tableView，就不接收Touch点击事件。</p> <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="built_in">BOOL</span>)gestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer shouldReceiveTouch:(<span class="built_in">UITouch</span> *)touch &#123;</span><br><span class="line">    <span class="comment">// 点击的view的类名</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromClass</span>([touch.view <span class="keyword">class</span>]));</span><br><span class="line">    <span class="comment">// 点击了tableViewCell，view的类名为UITableViewCellContentView，则不接收Touch点击事件</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">NSStringFromClass</span>([touch.view <span class="keyword">class</span>]) isEqualToString:<span class="string">@"UITableViewCellContentView"</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法用来执行点击View的操作：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark - UIGestureRecognizerDelegate methods</span></span><br><span class="line">-(<span class="keyword">void</span>)viewtapClicked:(<span class="built_in">UITapGestureRecognizer</span> *)tap</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGPoint</span> point = [tap locationInView:<span class="keyword">self</span>];</span><br><span class="line">    <span class="built_in">BOOL</span> isTouch = <span class="built_in">CGRectContainsPoint</span>(<span class="keyword">self</span>.baseView.frame, point);</span><br><span class="line">    <span class="keyword">if</span> (isTouch) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"点击tableView"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        [<span class="built_in">UIView</span> animateWithDuration:<span class="number">1.0</span> animations:^&#123;</span><br><span class="line">            [<span class="keyword">self</span> removeFromSuperview];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9、断网重连后更新界面"><a href="#9、断网重连后更新界面" class="headerlink" title="9、断网重连后更新界面"></a>9、断网重连后更新界面</h4><p>我们在开发项目中，网络状态的监听基本设置在<code>appDelegate</code>中。所以需要在这里针对网络状态做一个广播通知，在需要网络重连后更新界面的地方注册该广播进行界面的刷新</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册网络监控通知</span></span><br><span class="line"><span class="selector-attr">[[NSNotificationCenter defaultCenter]</span> <span class="selector-tag">addObserver</span><span class="selector-pseudo">:self</span> <span class="selector-tag">selector</span>:@<span class="selector-tag">selector</span>(<span class="attribute">notificationHandler</span>:) <span class="selector-tag">name</span><span class="selector-pseudo">:kIsNetWork</span> <span class="selector-tag">object</span><span class="selector-pseudo">:nil</span>];</span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">notificationHandler</span><span class="selector-pseudo">:(NSNotification</span> *) <span class="selector-tag">notification</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="selector-tag">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="selector-attr">[self requestHomeInfoData]</span>;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h3&gt;&lt;p&gt;两年多以来，基本上都是独立开发或者维护项目，不得不自嘲的说挺锻炼人的。最近的一家公司是涉足金融行列的，算是第一次踏足金融吧，过程怎样
      
    
    </summary>
    
      <category term="项目总结" scheme="http://guohuaden.com/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="iOS" scheme="http://guohuaden.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>WKWebView使用遇到的问题</title>
    <link href="http://guohuaden.com/2017/10/03/WKWebView-issue/"/>
    <id>http://guohuaden.com/2017/10/03/WKWebView-issue/</id>
    <published>2017-10-03T02:30:40.000Z</published>
    <updated>2018-10-24T11:06:00.688Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p><code>WKWebView</code>在iOS8之后正式替代<code>UIWebView</code>，速度方面确实提升了不少。关于<code>WKWebView</code>的简单使用，在《<a href="http://guohuaden.com/2017/02/11/WKWebView/">聊一聊WKWebView</a>》中我已经介绍过了，这里就不再絮叨，本篇主要记录s三个开发中遇到的问题。</p><h4 id="1、去缓存问题"><a href="#1、去缓存问题" class="headerlink" title="1、去缓存问题"></a>1、去缓存问题</h4><p>我们在第一次打开webView后，移动端为了使用的便捷，会在本地做一个缓存，服务器端也有类似的缓存。但有时服务器端更改信息或者web端更改界面信息。我们往往打开移动端的webView界面，仍然是原来的界面状态，这就是缓存机制造成的现象。<br>解决方法：如果不考虑流量，则需要在请求时忽略本地和远程的缓存即可,使用<code>NSURLRequestReloadIgnoringLocalAndRemoteCacheData</code></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSURLRequest *request = [[NSURLRequest alloc]<span class="string">initWithURL:</span>[NSURL <span class="string">URLWithString:</span>url] <span class="string">cachePolicy:</span>NSURLRequestReloadIgnoringLocalAndRemoteCacheData <span class="string">timeoutInterval:</span><span class="number">20</span>];</span><br><span class="line">[self.webView <span class="string">loadRequest:</span>request];</span><br></pre></td></tr></table></figure><p>这里附上iOS提供的请求缓存类型:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, <span class="built_in">NSURLRequestCachePolicy</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSURLRequestUseProtocolCachePolicy</span> = <span class="number">0</span>,</span><br><span class="line">    <span class="built_in">NSURLRequestReloadIgnoringLocalCacheData</span> = <span class="number">1</span>,</span><br><span class="line">    <span class="built_in">NSURLRequestReloadIgnoringLocalAndRemoteCacheData</span> = <span class="number">4</span>, <span class="comment">// Unimplemented</span></span><br><span class="line">    <span class="built_in">NSURLRequestReloadIgnoringCacheData</span> = <span class="built_in">NSURLRequestReloadIgnoringLocalCacheData</span>,</span><br><span class="line">    <span class="built_in">NSURLRequestReturnCacheDataElseLoad</span> = <span class="number">2</span>,</span><br><span class="line">    <span class="built_in">NSURLRequestReturnCacheDataDontLoad</span> = <span class="number">3</span>,</span><br><span class="line">    <span class="built_in">NSURLRequestReloadRevalidatingCacheData</span> = <span class="number">5</span>, <span class="comment">// Unimplemented</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也可以看看这篇文章：《<a href="http://www.cnblogs.com/lolDragon/p/6774509.html" target="_blank" rel="noopener">iOS webview加载时序和缓存问题总结</a>》</p><h4 id="2、拦截WKWebView中界面的URL，自己进行处理跳转（例如跳转到appstore、支付宝等）"><a href="#2、拦截WKWebView中界面的URL，自己进行处理跳转（例如跳转到appstore、支付宝等）" class="headerlink" title="2、拦截WKWebView中界面的URL，自己进行处理跳转（例如跳转到appstore、支付宝等）"></a>2、拦截WKWebView中界面的URL，自己进行处理跳转（例如跳转到appstore、支付宝等）</h4><p>如果在<code>webView</code>界面中有跳转<code>appstore</code>、支付宝等调手机中app的点击按钮时，如果iOS端不做处理的话，是调不起来手机中的app的。<br>我们需要做的就是在代理方法中截取<code>webView</code>的<code>url</code>，再使用iOS的代码进行跳转。<br>例如打开<code>appstore</code></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView decidePolicyForNavigationAction:(<span class="built_in">WKNavigationAction</span> *)navigationAction decisionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">WKNavigationActionPolicy</span>))decisionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *url = navigationAction.request.URL;</span><br><span class="line">    <span class="built_in">UIApplication</span> *app = [<span class="built_in">UIApplication</span> sharedApplication];</span><br><span class="line">    <span class="comment">// 打开appstore</span></span><br><span class="line">    <span class="keyword">if</span> ([url.absoluteString containsString:<span class="string">@"https://itunes.apple.com/"</span>])&#123;</span><br><span class="line">        <span class="keyword">if</span> ([app canOpenURL:url])&#123;</span><br><span class="line">            [[<span class="built_in">UIApplication</span> sharedApplication] openURL:url];</span><br><span class="line">            decisionHandler(<span class="built_in">WKNavigationActionPolicyCancel</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    decisionHandler(<span class="built_in">WKNavigationActionPolicyAllow</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、在WKWebView中点击事件需要上传cookie中的数据，但cookie数据有问题"><a href="#4、在WKWebView中点击事件需要上传cookie中的数据，但cookie数据有问题" class="headerlink" title="4、在WKWebView中点击事件需要上传cookie中的数据，但cookie数据有问题"></a>4、在WKWebView中点击事件需要上传cookie中的数据，但cookie数据有问题</h4><p>开发中发现，在WKWebView中点击获取验证码等失败（抓包工具查看，发现需要和请求一块上传cookie中的数据，实际并没有上传或者数据丢失一部分）</p><p>在WKWebView中，cookie的是需要我们自己去设置的，这一点和UIWebView不同。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)setUIWebviewcookie&#123;</span><br><span class="line">    <span class="built_in">NSHTTPCookieStorage</span> *cs = [<span class="built_in">NSHTTPCookieStorage</span> sharedHTTPCookieStorage];</span><br><span class="line">    [cs setCookieAcceptPolicy:<span class="built_in">NSHTTPCookieAcceptPolicyAlways</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在webView响应请求的代理方法中，查看cookie</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView decidePolicyForNavigationResponse:(<span class="built_in">WKNavigationResponse</span> *)navigationResponse decisionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">WKNavigationResponsePolicy</span>))decisionHandler&#123;</span><br><span class="line">    <span class="built_in">NSHTTPURLResponse</span> *response = (<span class="built_in">NSHTTPURLResponse</span> *)navigationResponse.response;</span><br><span class="line">    <span class="built_in">NSArray</span> *cookies =[<span class="built_in">NSHTTPCookie</span> cookiesWithResponseHeaderFields:[response allHeaderFields] forURL:response.URL];</span><br><span class="line">    <span class="comment">//读取wkwebview中的cookie 方法1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSHTTPCookie</span> *cookie <span class="keyword">in</span> cookies) &#123;</span><br><span class="line">        <span class="comment">//[[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookie:cookie];</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"wkwebview中的cookie:%@"</span>, cookie);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读取wkwebview中的cookie 方法2 读取Set-Cookie字段</span></span><br><span class="line">    <span class="built_in">NSString</span> *cookieString = [[response allHeaderFields] valueForKey:<span class="string">@"Set-Cookie"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"wkwebview中的cookie:%@"</span>, cookieString);</span><br><span class="line">    <span class="comment">//看看存入到了NSHTTPCookieStorage了没有</span></span><br><span class="line">    <span class="built_in">NSHTTPCookieStorage</span> *cookieJar2 = [<span class="built_in">NSHTTPCookieStorage</span> sharedHTTPCookieStorage];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSHTTPCookie</span> *cookie <span class="keyword">in</span> cookieJar2.cookies) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"NSHTTPCookieStorage中的cookie%@"</span>, cookie);</span><br><span class="line">    &#125;</span><br><span class="line">    decisionHandler(<span class="built_in">WKNavigationResponsePolicyAllow</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h3&gt;&lt;p&gt;&lt;code&gt;WKWebView&lt;/code&gt;在iOS8之后正式替代&lt;code&gt;UIWebView&lt;/code&gt;，速度方面确实提升了不
      
    
    </summary>
    
      <category term="iOS" scheme="http://guohuaden.com/categories/iOS/"/>
    
    
      <category term="WKWebView" scheme="http://guohuaden.com/tags/WKWebView/"/>
    
  </entry>
  
  <entry>
    <title>一个自定义的搜索框：GH_SearchView</title>
    <link href="http://guohuaden.com/2017/05/20/GH-SearchView/"/>
    <id>http://guohuaden.com/2017/05/20/GH-SearchView/</id>
    <published>2017-05-20T05:46:13.000Z</published>
    <updated>2018-10-24T11:02:49.318Z</updated>
    
    <content type="html"><![CDATA[<p>对于iOS自带的搜索框，其实我用着也挺好的，但低版本的使用：  高版本的使用:UISearchController，两个难有个统一。很多项目中都是将着两套代码都写入项目中去，这样做难免显得代码冗余。所以就简单的自定义个搜索框。</p><p><a href="https://github.com/Wheat-Qin/GH_SearchView" target="_blank" rel="noopener">下载地址：https://github.com/Wheat-Qin/GH_SearchView  【支持pods】</a></p><p>怎样使用<code>&#39;GH_SearchView&#39;:</code></p><p>安装CocoaPods：<code>pod &#39;GH_SearchView&#39;</code></p><p>手动倒入：<br>拖动<code>GH_SearchView</code>文件夹中的所有文件到工程项目中</p><p>引入主要文件：<code>#import &quot;GH_SearchView.h&quot;</code></p><p>使用时实现起来也很简单，一句代码创建：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GH_SearchView *searchView_1 = [[GH_SearchView alloc]<span class="string">initWithFrame:</span>CGRectMake(<span class="number">10</span>, <span class="number">80</span>, IPHONE_WIDTH<span class="number">-20</span>, <span class="number">44.</span>f) <span class="string">withTarget:</span>self <span class="string">backgroundColor:</span>[UIColor redColor] <span class="string">placeholderContent:</span>@<span class="string">"请输入搜索内容"</span> <span class="string">searchImage:</span>@<span class="string">"GH_search"</span> <span class="string">withTableView:</span>nil];</span><br><span class="line"> </span><br><span class="line"><span class="comment">//自定制取消按钮字体颜色</span></span><br><span class="line">[searchView_1  <span class="string">setCancelButtonTitleColor:</span>[UIColor blueColor]];</span><br><span class="line"><span class="comment">//设置背景色透明度</span></span><br><span class="line">[searchView_1 <span class="string">setBackgroundColorWithAlphaComponent:</span><span class="number">0.5</span>];</span><br><span class="line"><span class="comment">//设置激活状态</span></span><br><span class="line">[searchView_1 <span class="string">setSearchActiveState:</span>YES];</span><br><span class="line">    </span><br><span class="line">[self.view <span class="string">addSubview:</span>searchView_1];</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="comment">//self.tableView.tableHeaderView = self.searchView;</span></span><br></pre></td></tr></table></figure><p>使用时需遵守<code>GH_searchDelegate</code>协议。<br>其中必需实现的协议方法有一种:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 搜索按钮</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> content 搜索的内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">-(<span class="keyword">void</span>)<span class="string">searchClickedWithContent:</span>(NSString *)content;</span><br></pre></td></tr></table></figure><p>可选的协议方法有三种:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 实时搜索协议方法</span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> content 搜索的内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">-(<span class="keyword">void</span>)<span class="string">searchBoxContentDidChange:</span>(NSString *)content;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 搜索框开始输入</span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> content 搜索的内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">-(<span class="keyword">void</span>)<span class="string">searchDidBeginEditing:</span>(NSString *)content;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 搜索框输入结束</span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> content 搜索的内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">-(<span class="keyword">void</span>)<span class="string">searchDidEndEditing:</span>(NSString *)content;</span><br></pre></td></tr></table></figure><p>效果图如下：<br>无tableView情况下：<br><img src="http://obzx0h1re.bkt.clouddn.com/GH_searchView_1.png" alt="GH_searchView_1"></p><p>有tableView情况下：<br><img src="http://obzx0h1re.bkt.clouddn.com/GH_searchView_2.png" alt="GH_searchView_2"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于iOS自带的搜索框，其实我用着也挺好的，但低版本的使用：  高版本的使用:UISearchController，两个难有个统一。很多项目中都是将着两套代码都写入项目中去，这样做难免显得代码冗余。所以就简单的自定义个搜索框。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https:/
      
    
    </summary>
    
      <category term="iOS" scheme="http://guohuaden.com/categories/iOS/"/>
    
    
      <category term="自定义的搜索框" scheme="http://guohuaden.com/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E6%90%9C%E7%B4%A2%E6%A1%86/"/>
    
  </entry>
  
  <entry>
    <title>利用通知(`NSNotificationCenter`)获取键盘的高度,以及显示和隐藏键盘时修改界面的注意事项</title>
    <link href="http://guohuaden.com/2017/04/30/get-keyboard-height/"/>
    <id>http://guohuaden.com/2017/04/30/get-keyboard-height/</id>
    <published>2017-04-30T02:42:19.000Z</published>
    <updated>2018-10-24T06:08:38.320Z</updated>
    
    <content type="html"><![CDATA[<p>我们在开发中会遇到这样的情况：调用键盘时需要界面有一个调整，避免键盘遮掩输入框。</p><p>但实现时你会发现，在不同的手机上键盘的高度是不同的。这里列举一下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取键盘的高度</span></span><br><span class="line"> <span class="selector-tag">iphone</span> <span class="selector-tag">6</span>:</span><br><span class="line"> 中文</span><br><span class="line"> <span class="selector-tag">2014-12-31</span> <span class="selector-tag">11</span><span class="selector-pseudo">:16</span><span class="selector-pseudo">:23.643</span> <span class="selector-tag">Demo</span><span class="selector-attr">[686:41289]</span> 键盘高度是  <span class="selector-tag">258</span></span><br><span class="line"> <span class="selector-tag">2014-12-31</span> <span class="selector-tag">11</span><span class="selector-pseudo">:16</span><span class="selector-pseudo">:23.644</span> <span class="selector-tag">Demo</span><span class="selector-attr">[686:41289]</span> 键盘宽度是  <span class="selector-tag">375</span></span><br><span class="line"> 英文</span><br><span class="line"> <span class="selector-tag">2014-12-31</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:21.417</span> <span class="selector-tag">Demo</span><span class="selector-attr">[1102:58972]</span> 键盘高度是  <span class="selector-tag">216</span></span><br><span class="line"> <span class="selector-tag">2014-12-31</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:21.417</span> <span class="selector-tag">Demo</span><span class="selector-attr">[1102:58972]</span> 键盘宽度是  <span class="selector-tag">375</span></span><br><span class="line"> </span><br><span class="line"> <span class="selector-tag">iphone</span>  <span class="selector-tag">6</span> <span class="selector-tag">plus</span>：</span><br><span class="line"> 英文：</span><br><span class="line"> <span class="selector-tag">2014-12-31</span> <span class="selector-tag">11</span><span class="selector-pseudo">:31</span><span class="selector-pseudo">:14.669</span> <span class="selector-tag">Demo</span><span class="selector-attr">[928:50593]</span> 键盘高度是  <span class="selector-tag">226</span></span><br><span class="line"> <span class="selector-tag">2014-12-31</span> <span class="selector-tag">11</span><span class="selector-pseudo">:31</span><span class="selector-pseudo">:14.669</span> <span class="selector-tag">Demo</span><span class="selector-attr">[928:50593]</span> 键盘宽度是  <span class="selector-tag">414</span></span><br><span class="line"> 中文：</span><br><span class="line"> <span class="selector-tag">2015-01-07</span> <span class="selector-tag">09</span><span class="selector-pseudo">:22</span><span class="selector-pseudo">:49.438</span> <span class="selector-tag">Demo</span><span class="selector-attr">[622:14908]</span> 键盘高度是  <span class="selector-tag">271</span></span><br><span class="line"> <span class="selector-tag">2015-01-07</span> <span class="selector-tag">09</span><span class="selector-pseudo">:22</span><span class="selector-pseudo">:49.439</span> <span class="selector-tag">Demo</span><span class="selector-attr">[622:14908]</span> 键盘宽度是  <span class="selector-tag">414</span></span><br><span class="line"> </span><br><span class="line"> <span class="selector-tag">iPhone</span> <span class="selector-tag">7</span></span><br><span class="line"> <span class="selector-tag">2016-11-13</span> <span class="selector-tag">17</span><span class="selector-pseudo">:44</span><span class="selector-pseudo">:48.315</span> <span class="selector-tag">LoginDemo</span><span class="selector-attr">[2431:120937]</span> 键盘高度是  <span class="selector-tag">258</span></span><br><span class="line"> <span class="selector-tag">2016-11-13</span> <span class="selector-tag">17</span><span class="selector-pseudo">:44</span><span class="selector-pseudo">:48.316</span> <span class="selector-tag">LoginDemo</span><span class="selector-attr">[2431:120937]</span> 键盘宽度是  <span class="selector-tag">375</span></span><br><span class="line"> </span><br><span class="line"> <span class="selector-tag">iPhone</span> <span class="selector-tag">7</span> <span class="selector-tag">Plus</span></span><br><span class="line"> <span class="selector-tag">2016-11-13</span> <span class="selector-tag">17</span><span class="selector-pseudo">:43</span><span class="selector-pseudo">:20.683</span> <span class="selector-tag">LoginDemo</span><span class="selector-attr">[2322:119257]</span> 键盘高度是  <span class="selector-tag">271</span></span><br><span class="line"> <span class="selector-tag">2016-11-13</span> <span class="selector-tag">17</span><span class="selector-pseudo">:43</span><span class="selector-pseudo">:20.683</span> <span class="selector-tag">LoginDemo</span><span class="selector-attr">[2322:119257]</span> 键盘宽度是  <span class="selector-tag">414</span></span><br><span class="line"> </span><br><span class="line"> <span class="selector-tag">iphone</span> <span class="selector-tag">5</span> :</span><br><span class="line"> <span class="selector-tag">2014-12-31</span> <span class="selector-tag">11</span><span class="selector-pseudo">:19</span><span class="selector-pseudo">:36.452</span> <span class="selector-tag">Demo</span><span class="selector-attr">[755:43233]</span> 键盘高度是  <span class="selector-tag">216</span></span><br><span class="line"> <span class="selector-tag">2014-12-31</span> <span class="selector-tag">11</span><span class="selector-pseudo">:19</span><span class="selector-pseudo">:36.452</span> <span class="selector-tag">Demo</span><span class="selector-attr">[755:43233]</span> 键盘宽度是  <span class="selector-tag">320</span></span><br><span class="line"> </span><br><span class="line"> <span class="selector-tag">ipad</span> <span class="selector-tag">Air</span>：</span><br><span class="line"> <span class="selector-tag">2014-12-31</span> <span class="selector-tag">11</span><span class="selector-pseudo">:28</span><span class="selector-pseudo">:32.178</span> <span class="selector-tag">Demo</span><span class="selector-attr">[851:48085]</span> 键盘高度是  <span class="selector-tag">264</span></span><br><span class="line"> <span class="selector-tag">2014-12-31</span> <span class="selector-tag">11</span><span class="selector-pseudo">:28</span><span class="selector-pseudo">:32.178</span> <span class="selector-tag">Demo</span><span class="selector-attr">[851:48085]</span> 键盘宽度是  <span class="selector-tag">768</span></span><br><span class="line"> </span><br><span class="line"> <span class="selector-tag">ipad2</span> ：</span><br><span class="line"> <span class="selector-tag">2014-12-31</span> <span class="selector-tag">11</span><span class="selector-pseudo">:33</span><span class="selector-pseudo">:57.258</span> <span class="selector-tag">Demo</span><span class="selector-attr">[1014:53043]</span> 键盘高度是  <span class="selector-tag">264</span></span><br><span class="line"> <span class="selector-tag">2014-12-31</span> <span class="selector-tag">11</span><span class="selector-pseudo">:33</span><span class="selector-pseudo">:57.258</span> <span class="selector-tag">Demo</span><span class="selector-attr">[1014:53043]</span> 键盘宽度是  <span class="selector-tag">768</span></span><br></pre></td></tr></table></figure><p> 我们看出不同的手机设备键盘的高度是不同的，而且英文和中文键盘的高度也是不一样的。</p><p> 下面我们说一下利用通知来获取键盘的高度：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增加监听，当键盘出现或改变时收出消息</span></span><br><span class="line"><span class="selector-attr">[[NSNotificationCenter defaultCenter]</span> <span class="selector-tag">addObserver</span><span class="selector-pseudo">:self</span></span><br><span class="line">                                      <span class="selector-tag">selector</span>:@<span class="selector-tag">selector</span>(<span class="attribute">keyboardWillShow</span>:)</span><br><span class="line">                                      <span class="selector-tag">name</span><span class="selector-pseudo">:UIKeyboardWillShowNotification</span></span><br><span class="line">                                      <span class="selector-tag">object</span><span class="selector-pseudo">:nil</span>];</span><br><span class="line"> </span><br><span class="line"><span class="comment">//增加监听，当键退出时收出消息</span></span><br><span class="line"><span class="selector-attr">[[NSNotificationCenter defaultCenter]</span> <span class="selector-tag">addObserver</span><span class="selector-pseudo">:self</span></span><br><span class="line">                                      <span class="selector-tag">selector</span>:@<span class="selector-tag">selector</span>(<span class="attribute">keyboardWillHide</span>:)</span><br><span class="line">                                      <span class="selector-tag">name</span><span class="selector-pseudo">:UIKeyboardWillHideNotification</span></span><br><span class="line">                                      <span class="selector-tag">object</span><span class="selector-pseudo">:nil</span>];</span><br></pre></td></tr></table></figure><p>显示键盘的代码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)keyboardWillShow:(NSNotification *)aNotification</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取键盘的高度</span></span><br><span class="line">    NSDictionary *userInfo = [aNotification userInfo];</span><br><span class="line">    NSValue *aValue = [userInfo objectForKey:UIKeyboardFrameEndUserInfoKey];</span><br><span class="line">    CGRect keyboardRect = [aValue CGRectValue];</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span> = keyboardRect.<span class="built_in">size</span>.<span class="built_in">height</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">width</span> = keyboardRect.<span class="built_in">size</span>.<span class="built_in">width</span>;</span><br><span class="line">    NSLog(@<span class="string">"键盘高度是  %d"</span>,<span class="built_in">height</span>);</span><br><span class="line">    NSLog(@<span class="string">"键盘宽度是  %d"</span>,<span class="built_in">width</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>隐藏键盘的高度：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当键盘隐藏的时候</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">keyboardWillBeHidden:</span>(NSNotification*)aNotification</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 当然在注册通知(<code>NSNotificationCenter</code>)后，记得最后的注销通知：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-</span>(void)<span class="selector-tag">viewWillDisappear</span><span class="selector-pseudo">:(BOOL)animated</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="selector-attr">[[NSNotificationCenter defaultCenter]</span> <span class="selector-tag">removeObserver</span><span class="selector-pseudo">:self</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⚠️：切换键盘时也会产生 <code>UIKeyboardWillShowNotification</code> ，所以很可能方法被调用多次。最好在 <code>keyboardWillShow</code> 中不要写与调用次数有关的代码。在键盘第一次产生时，如果不是默认的英文键盘也会调用多次方法。</p><p> 比如：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark -  ******************打开键盘********</span></span><br><span class="line">- (<span class="keyword">void</span>) keyboardWillShowOfFeedBackVC:(<span class="built_in">NSNotification</span> *)notify &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这样写是不正确的：因为切换中英文键盘时都会调用该方法。</span></span><br><span class="line"><span class="comment">//    CGRect frame = self.view.frame;</span></span><br><span class="line"><span class="comment">//    frame.origin.y = self.view.frame.origin.y - 64;</span></span><br><span class="line"><span class="comment">//    self.view.frame = frame;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.view.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">-40</span>, IPHONE_WIDTH, IPHONE_HEIGHT);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们在开发中会遇到这样的情况：调用键盘时需要界面有一个调整，避免键盘遮掩输入框。&lt;/p&gt;
&lt;p&gt;但实现时你会发现，在不同的手机上键盘的高度是不同的。这里列举一下：&lt;/p&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class
      
    
    </summary>
    
      <category term="iOS" scheme="http://guohuaden.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://guohuaden.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>统计项目代码量</title>
    <link href="http://guohuaden.com/2017/04/29/Project-code-number/"/>
    <id>http://guohuaden.com/2017/04/29/Project-code-number/</id>
    <published>2017-04-29T01:48:46.000Z</published>
    <updated>2018-10-24T10:59:46.059Z</updated>
    
    <content type="html"><![CDATA[<p>有遇到过这样的情况，项目经理在写文档时会要求开发人员提供项目的代码量。下面就说一下代码量的统计问题。</p><h4 id="1、统计总的代码量（代码的行数）"><a href="#1、统计总的代码量（代码的行数）" class="headerlink" title="1、统计总的代码量（代码的行数）"></a>1、统计总的代码量（代码的行数）</h4><p>在终端中，cd 到项目文件夹；输入下面的指令。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span> . -<span class="built_in">name</span> <span class="string">"*.m"</span> -<span class="built_in">or</span> -<span class="built_in">name</span> <span class="string">"*.h"</span> -<span class="built_in">or</span> -<span class="built_in">name</span> <span class="string">"*.xib"</span> -<span class="built_in">or</span> -<span class="built_in">name</span> <span class="string">"*.c"</span> |xargs grep -v <span class="string">"^$"</span>|wc -l</span><br></pre></td></tr></table></figure><p>该指令是统计总共的代码量，并不统计具体的文件代码<br>其中<code>grep -v “^$”</code>：去除空行</p><p>注释是包含在代码量中的，这一点要注意。</p><p>统计效果图：<br><img src="http://obzx0h1re.bkt.clouddn.com/ProjectCodeTotal.png" alt="统计总的代码量"></p><h4 id="2、统计每个文件的代码量（代码的行数）"><a href="#2、统计每个文件的代码量（代码的行数）" class="headerlink" title="2、统计每个文件的代码量（代码的行数）"></a>2、统计每个文件的代码量（代码的行数）</h4><p>在终端中，cd 到项目文件夹；输入下面的指令。<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span> . -<span class="built_in">name</span> <span class="string">"*.m"</span> -<span class="built_in">or</span> -<span class="built_in">name</span> <span class="string">"*.h"</span> -<span class="built_in">or</span> -<span class="built_in">name</span> <span class="string">"*.xib"</span> -<span class="built_in">or</span> -<span class="built_in">name</span> <span class="string">"*.c"</span> |xargs wc -l</span><br></pre></td></tr></table></figure></p><p>该指令会统计具体的文件代码行数。</p><p>统计效果图：<br><img src="http://obzx0h1re.bkt.clouddn.com/ProjectCodeNumber1.png" alt="统计每个文件的代码量1"></p><p><img src="http://obzx0h1re.bkt.clouddn.com/ProjectCodeNumber2.png" alt="统计每个文件的代码量2"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有遇到过这样的情况，项目经理在写文档时会要求开发人员提供项目的代码量。下面就说一下代码量的统计问题。&lt;/p&gt;
&lt;h4 id=&quot;1、统计总的代码量（代码的行数）&quot;&gt;&lt;a href=&quot;#1、统计总的代码量（代码的行数）&quot; class=&quot;headerlink&quot; title=&quot;1、
      
    
    </summary>
    
      <category term="iOS" scheme="http://guohuaden.com/categories/iOS/"/>
    
    
      <category term="统计代码量" scheme="http://guohuaden.com/tags/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>iOS中关于图片、PDF等文件加密</title>
    <link href="http://guohuaden.com/2017/04/27/fileEncryptionAndDecryption/"/>
    <id>http://guohuaden.com/2017/04/27/fileEncryptionAndDecryption/</id>
    <published>2017-04-27T03:20:25.000Z</published>
    <updated>2018-10-24T11:02:22.304Z</updated>
    
    <content type="html"><![CDATA[<p>这里加密使用的是三方库：<code>RNCryptor</code>,它是一个跨语言AES加密/解密库。</p><p>主要目标是<code>Swift</code>和<code>Objective-C</code>，但<code>C</code>,<code>C ++</code>,<code>C＃</code>,<code>Erlang</code>,<code>Go</code>,<code>Haskell</code>,<code>Java</code>,<code>PHP</code>,<code>Python</code>,<code>Javascript</code>和<code>Ruby</code>中都有实现。</p><p>RNCryptor地址：</p><p><a href="https://github.com/RNCryptor/RNCryptor" target="_blank" rel="noopener">RNCryptor ：https://github.com/RNCryptor/RNCryptor</a></p><p>以及OC专用的地址:</p><p><a href="https://github.com/RNCryptor/RNCryptor-objc" target="_blank" rel="noopener">RNCryptor-objc ：https://github.com/RNCryptor/RNCryptor-objc</a></p><p>下面就用到的图片和PDF文件加密做一下简单的介绍。</p><h4 id="1、图片加解密"><a href="#1、图片加解密" class="headerlink" title="1、图片加解密"></a>1、图片加解密</h4><p>这个没有什么思想可言，直接看下代码</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma  mark --Image加解密</span></span><br><span class="line">-(<span class="keyword">void</span>)imageEncryptionAndDecryption</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfFile:[[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"default.jpg"</span> ofType:<span class="literal">nil</span>]];</span><br><span class="line">    <span class="built_in">NSError</span> *error;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//加密</span></span><br><span class="line">    <span class="built_in">NSData</span> *encryptedData = [RNEncryptor encryptData:data withSettings:kRNCryptorAES256Settings password:aPassword error:&amp;error ];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"^_^ 加密成功 ……——(^_^)\n"</span>);</span><br><span class="line"><span class="comment">//        NSLog(@"encryptedData==%@",encryptedData);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//解密</span></span><br><span class="line">    <span class="built_in">NSData</span> *decryptedData = [RNDecryptor decryptData:encryptedData withPassword:aPassword error:&amp;error];</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"^_^ 解密成功 ……——(^_^)\n"</span>);</span><br><span class="line"><span class="comment">//        NSLog(@"decryptedData==%@",decryptedData);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.imageView.image = [<span class="built_in">UIImage</span> imageWithData:decryptedData];</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、PDF加解密"><a href="#2、PDF加解密" class="headerlink" title="2、PDF加解密"></a>2、PDF加解密</h4><p>考虑到PDF文件可能较大的原因，这里在加解密时使用了子线程，以避免加解密过程耗时。</p><p>另：PDF查看需要提供路径，而这也是关键。</p><p>思路：</p><ol><li>将网络请求下来的数据流（NSData）直接进行加密，加密成功后存入沙盒目录中。</li><li>在查看PDF时,先对加密的PDF进行解密，再将解密的PDF存入沙盒目录中（区分加解密PDF文件）。</li><li>获取解密的PDF文件路径，查看PDF文件。</li><li>退出查看当前的PDF文件时，删除解密后的PDF文件缓存，保留加密的PDF缓存。</li></ol><p>查看代码：</p><p><strong>加密</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark --PDF加密</span></span><br><span class="line">-(<span class="keyword">void</span>)PDFEncryption</span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="built_in">NSData</span> *encryptedData;</span><br><span class="line">    __block <span class="built_in">NSError</span> *error;</span><br><span class="line">    <span class="built_in">NSString</span> *filePath = [[<span class="built_in">NSBundle</span> mainBundle]pathForResource:<span class="string">@"11.pdf"</span> ofType:<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *fileEncryPath = [<span class="built_in">NSHomeDirectory</span>()stringByAppendingPathComponent:<span class="string">@"/Documents/TKAMC.qgh"</span>];</span><br><span class="line">    <span class="built_in">NSFileManager</span> *fileManager = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">    <span class="comment">//判断是否已存在加密文件，若存在直接执行解密过程。</span></span><br><span class="line">    <span class="keyword">if</span> ([fileManager fileExistsAtPath:fileEncryPath]) &#123;</span><br><span class="line">        </span><br><span class="line">        [<span class="keyword">self</span> PDFDecryptedData:[<span class="built_in">NSData</span> dataWithContentsOfFile:fileEncryPath]];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//异步去加密，防止占用太多内存</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfFile:filePath];</span><br><span class="line">        <span class="comment">//加密</span></span><br><span class="line">        encryptedData = [RNEncryptor encryptData:data withSettings:kRNCryptorAES256Settings password:aPassword error:&amp;error ];</span><br><span class="line">        <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"^_^ PDF加密成功 ……——(^_^)\n"</span>);</span><br><span class="line"><span class="comment">//            NSLog(@"encryptedData==%@",encryptedData);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在主线程上写入文件</span></span><br><span class="line">        <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="built_in">BOOL</span> yes = [encryptedData writeToFile:fileEncryPath atomically:<span class="literal">NO</span>];</span><br><span class="line">            <span class="keyword">if</span> (yes) &#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"加密文件写入成功"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"加密文件写入失败"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"写入PDF路径：%@"</span>,fileEncryPath);</span><br><span class="line">            [<span class="keyword">self</span> PDFDecryptedData:encryptedData];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解密</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark ---PDF解密</span></span><br><span class="line">-(<span class="keyword">void</span>)PDFDecryptedData:(<span class="built_in">NSData</span> *)encryptedData&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSString</span> *fileDecryPath = [<span class="built_in">NSHomeDirectory</span>()stringByAppendingPathComponent:<span class="string">@"/Documents/TKAMC"</span>];</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="comment">//    解密</span></span><br><span class="line">        <span class="built_in">NSError</span> *error;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (encryptedData != <span class="literal">nil</span> || aPassword != <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="built_in">NSData</span> *decryptedData = [RNDecryptor decryptData:encryptedData</span><br><span class="line">                                                withPassword:aPassword</span><br><span class="line">                                                       error:&amp;error];</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                 <span class="built_in">BOOL</span> yes = [decryptedData writeToFile:fileDecryPath atomically:<span class="literal">NO</span>];</span><br><span class="line">                <span class="keyword">if</span> (yes) &#123;</span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@"解密文件写入成功"</span>);</span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@"写入解密PDF路径：%@"</span>,fileDecryPath);</span><br><span class="line">                    <span class="keyword">self</span>.filepath = fileDecryPath;</span><br><span class="line">                    [<span class="keyword">self</span> pushVC];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@"解密文件写入失败"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"加密数据为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="#FF6347"><strong>注：</strong></font>这里加解密时并没有具体实现网络请求模块，只是简单的对本地文件进行了实践，但大体实现过程已经实现。</p><p><strong>退出PDF时，删除解密的PDF文件</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark - ReaderViewControllerDelegate methods</span></span><br><span class="line">- (<span class="keyword">void</span>)dismissReaderViewController:(ReaderViewController *)viewController</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//MARK:退出查看PDF时删除解密存储文件。</span></span><br><span class="line">    <span class="built_in">NSFileManager</span> *fileManager = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">    </span><br><span class="line">    [fileManager removeItemAtPath:<span class="keyword">self</span>.filepath error:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>这里提供一个个人测试使用的一个Demo，仅供参考</p><p><a href="https://github.com/Wheat-Qin/FileEncryption_Demo" target="_blank" rel="noopener">FileEncryption_Demo ：https://github.com/Wheat-Qin/FileEncryption_Demo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里加密使用的是三方库：&lt;code&gt;RNCryptor&lt;/code&gt;,它是一个跨语言AES加密/解密库。&lt;/p&gt;
&lt;p&gt;主要目标是&lt;code&gt;Swift&lt;/code&gt;和&lt;code&gt;Objective-C&lt;/code&gt;，但&lt;code&gt;C&lt;/code&gt;,&lt;code&gt;C ++&lt;/
      
    
    </summary>
    
      <category term="iOS" scheme="http://guohuaden.com/categories/iOS/"/>
    
    
      <category term="文件加密" scheme="http://guohuaden.com/tags/%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Xcode中常用的标记(MARK、TODO、FIXME)</title>
    <link href="http://guohuaden.com/2017/04/22/MARK-TODO-FIXME/"/>
    <id>http://guohuaden.com/2017/04/22/MARK-TODO-FIXME/</id>
    <published>2017-04-22T05:55:39.000Z</published>
    <updated>2018-10-24T11:03:18.102Z</updated>
    
    <content type="html"><![CDATA[<p>在项目中以<code>ViewController</code>界面为例，在创建很多方法的情况下，会导致代码在翻阅时很浪费时间。但我们也是有对应的便捷方法。例如：<code>#pragma mark</code>以及 打断点引起注意的方式都可以达到我们想要的效果。</p><p>但细心的开发者会注意到，苹果提供了三个标记(<code>MARK、TODO、FIXME</code>)来给我们提供便利。至于用法也是很简单，和<code>#pragma mark</code>类似。下面👇做解释：</p><p><strong>MARK:标注</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MARK:视图将要消失（viewWillDisappear）</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">viewWillDisappear:</span>(BOOL)animated&#123;</span><br><span class="line">    [<span class="keyword">super</span> <span class="string">viewWillDisappear:</span>animated];</span><br><span class="line">    [[NSNotificationCenter defaultCenter] <span class="string">removeObserver:</span>self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>TODO:备忘录</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> back super ViewController(返回上级视图)</span></span><br><span class="line">- (<span class="keyword">void</span>)goback:(<span class="keyword">id</span>)sender&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.myBlock) &#123;</span><br><span class="line">        <span class="keyword">self</span>.myBlock(<span class="literal">NO</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">super</span> goback:sender];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>FIXME:通常在bug的位置做该标记</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">FIXME:</span>如果使用点击空白处，取消键盘响应事件，打开下面👇代码</span></span><br><span class="line"><span class="comment">//- (void)tapGestures:(UIGestureRecognizer *)gesture&#123;</span></span><br><span class="line"><span class="comment">//    [self.view endEditing:YES];</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><p><strong>#pragma mark:</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark UIImagePickerControllerDelegate图片选择代理方法</span></span><br><span class="line">- (<span class="keyword">void</span>)imagePickerControllerDidCancel:(UIImagePickerController *)picker</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">self.IPCView disappear</span>];</span><br><span class="line">    [<span class="meta">picker dismissViewControllerAnimated:YES completion:Nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下效果：<br><img src="http://obzx0h1re.bkt.clouddn.com/TODO_sign.png" alt="MARK-TODO-FIXME"><br>下面是关于写警告的方法，这个警告是我们在项目中自己制造的，旨在引起注意</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> message <span class="meta-string">"warn one"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">warning</span> <span class="meta-string">"warn two"</span></span></span><br></pre></td></tr></table></figure><p>警告效果：<br><img src="http://obzx0h1re.bkt.clouddn.com/warn_sign.png" alt="warning"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在项目中以&lt;code&gt;ViewController&lt;/code&gt;界面为例，在创建很多方法的情况下，会导致代码在翻阅时很浪费时间。但我们也是有对应的便捷方法。例如：&lt;code&gt;#pragma mark&lt;/code&gt;以及 打断点引起注意的方式都可以达到我们想要的效果。&lt;/p&gt;

      
    
    </summary>
    
      <category term="iOS" scheme="http://guohuaden.com/categories/iOS/"/>
    
    
      <category term="常用的标记" scheme="http://guohuaden.com/tags/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%A0%87%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>借我</title>
    <link href="http://guohuaden.com/2017/04/21/borrow-me/"/>
    <id>http://guohuaden.com/2017/04/21/borrow-me/</id>
    <published>2017-04-21T01:44:16.000Z</published>
    <updated>2018-08-21T04:58:00.724Z</updated>
    
    <content type="html"><![CDATA[<p><strong>借我一个暮年，</strong></p><p><strong>借我碎片，</strong></p><p><strong>借我瞻前与顾后，</strong></p><p><strong>借我执拗如少年。</strong></p><p><strong>借我后天长成的先天，</strong></p><p><strong>借我变如不曾改变。</strong></p><p><strong>借我素淡的世故和明白的愚，</strong></p><p><strong>借我可预知的险。</strong></p><p><strong>借我悲怆的磊落，</strong></p><p><strong>借我温软的鲁莽和玩笑的庄严。</strong></p><p><strong>借我最初与最终的不敢，借我不言而喻的不见。</strong></p><p><strong>借我一场秋啊，可你说这已是冬天。</strong><br><br> </p><p><font color="#DC143C"><strong>注：</strong></font>这首诗感觉很特别，初次读到时是在一个好朋友发表的说说中，那时的感觉很是欢喜，也有一些自责。欢喜是因为很喜欢，而且最终还是看到了这首诗；自责是因为，这么好的一首诗，我却迟迟未曾发现，如果不是因为这个好朋友发的说说，我也许就会错过。<br><br></p><p><font color="#DC143C"><strong>另注：</strong></font>有人说这首诗是樊小纯写给木心的，也有人说是木心写的。我不确定，所以没有注明作者。但这并不影响我对这首诗的喜欢，我喜欢的始终是诗，跟作者的是谁关系并不太大，但写出这首诗的作者，我是很佩服的。  <br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;借我一个暮年，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;借我碎片，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;借我瞻前与顾后，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;借我执拗如少年。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;借
      
    
    </summary>
    
      <category term="欠下的时光" scheme="http://guohuaden.com/categories/%E6%AC%A0%E4%B8%8B%E7%9A%84%E6%97%B6%E5%85%89/"/>
    
    
      <category term="欠下的时光" scheme="http://guohuaden.com/tags/%E6%AC%A0%E4%B8%8B%E7%9A%84%E6%97%B6%E5%85%89/"/>
    
  </entry>
  
  <entry>
    <title>__bridge 和 Core Foundation</title>
    <link href="http://guohuaden.com/2017/03/14/bridge-understand/"/>
    <id>http://guohuaden.com/2017/03/14/bridge-understand/</id>
    <published>2017-03-14T02:25:36.000Z</published>
    <updated>2018-10-24T11:07:10.329Z</updated>
    
    <content type="html"><![CDATA[<p>这篇知识比较偏，是偏低层一些的。</p><p><strong>一：__birdge</strong></p><p>由于<code>__bridge</code>很少接触，所以专门去查找了一下。其实它的作用很简单，就是：实现<code>id</code>类型与<code>void*</code> 类型的相互转换。</p><p>看下代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc]init];</span><br><span class="line"><span class="keyword">void</span> *c = (__bridge <span class="keyword">void</span> *)(obj); </span><br><span class="line"><span class="keyword">id</span> d = (__bridge <span class="keyword">id</span>)(c);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"\n obj=%@,\n c=%@,\n d=%@\n"</span>,obj,c,d);</span><br></pre></td></tr></table></figure><p>这里我们就用到了<code>__bridge</code>。<br>打印结果如下：</p><p><img src="http://obzx0h1re.bkt.clouddn.com/__bridgePrint.png" alt="__bridgePrint"></p><p>下面看下使用和不使用<code>__bridge</code>的对比</p><p><img src="http://obzx0h1re.bkt.clouddn.com/__bridgeError.png" alt="__bridgeError"></p><p><img src="http://obzx0h1re.bkt.clouddn.com/__bridge.png" alt="__bridge"></p><p><br></p><p><strong>二：Core Foundation</strong></p><p><strong>1、什么是Core Foundation</strong></p><p><code>Core Foundation</code>框架 (<code>CoreFoundation.framework</code>) 是一组C语言接口，它们为iOS应用程序提供基本数据管理和服务功能。</p><p><strong>注：</strong><code>Core Foundation</code>是底层框架，它的对象并不在ARC管理下，所以需要开发者自己去维护这些对象的引用计数。</p><p><strong>2、Core Foundaton 的作用</strong><br>至于它的作用，这里有一段英文解释：</p><blockquote></blockquote><p>The programming interfaces of Core Foundation objects have been designed for ease of use and reuse. At a general level, Core Foundation:<br>    Enables sharing of code and data among various frameworks and libraries.<br>    Makes some degree of operating-system independence possible .<br>    Supports internationalization with Unicode strings.<br>    Provides common API and other useful capabilities, including a plug-in architecture, XML property lists, and preferences.<br>Core Foundation makes it possible for the different frameworks and libraries on OS X to share code and data. Applications, libraries, and frameworks can define C routines that incorporate Core Foundation types in their external interfaces; they can thus communicate data—as Core Foundation objects—to each other through these interfaces.</p><p>翻译后，大致意思是这样的：</p><blockquote></blockquote><p><code>Core Foundation</code>对象的编程接口已设计为易于使用和重用。 在一般的意义，<code>Core Foundation</code>：<br>     1、支持在各种框架和库之间共享代码和数据<br>     2、使某种程度的操作系统独立性成为可能<br>     3、支持使用<code>Unicode</code>字符串进行国际化<br>     4、提供通用API和其他有用的功能，包括插件架构，XML属性列表和首选项<br><code>Core Foundation</code>使得OS X上的不同框架和库可以共享代码和数据。 应用程序，库和框架可以定义在其外部接口中并入<code>Core Foundation</code>类型的C例程; 它们因此可以通过这些接口将数据作为<code>Core Foundation</code>对象传递到彼此。</p><p><strong>三、Objective-C 和 Core Foundation 对象之间转换</strong></p><p>iOS允许<code>Objective-C</code> 和 <code>Core Foundation</code> 对象之间可以轻松的转换。</p><p>在《iOS开发进阶》一书中，唐巧提到：在ARC下，有时候需要将一个<code>Core Foundation</code>对象转换成一个<code>Object-C</code>对象，这个时候我们需要告诉编译器，转换过程中引用计数需要如何调整，这时也会用到<code>bridge</code>这个关键字。</p><ul><li><code>__bridge</code>: 只做类型转换，不修改相关对象的引用计数，原来的Core Foundation对象在不用时，需要调用CFRelease方法。</li><li><code>__bridge_retained</code>: 类型转换后将相关对象的引用计数加1，原来的<code>Core Foundation</code>对象在不用时，需要调用<code>CFRelease</code>方法。</li><li><code>__bridge_transfer</code>: 类型转换后，将该对象的引用计数交给ARC管理，<code>Core Foundation</code>对象在不用时，不再需要调用<code>CFRelease</code>方法。</li></ul><hr><p><strong><code>__bridge</code>:</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc]init];</span><br><span class="line"><span class="comment">//    void *a = obj;</span></span><br><span class="line"><span class="comment">//    id b = a;</span></span><br><span class="line">    <span class="keyword">void</span> *c = (__bridge <span class="keyword">void</span> *)(obj);<span class="comment">//只做类型转换，不修改相关对象的引用计数</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"obj-c count is %ld"</span>, <span class="built_in">CFGetRetainCount</span>(c));<span class="comment">//输出结果： obj-c count is 1</span></span><br><span class="line">    <span class="keyword">id</span> d = (__bridge <span class="keyword">id</span>)(c); </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"obj-d retainCount %ld"</span>,<span class="built_in">CFGetRetainCount</span>((__bridge <span class="built_in">CFTypeRef</span>)(d)));<span class="comment">//输出结果：obj-d retainCount 2</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"\n obj=%@,\n c=%@,\n d=%@\n"</span>,obj,c,d);</span><br><span class="line">    <span class="comment">//__bridge</span></span><br><span class="line">    <span class="built_in">CFStringRef</span> <span class="built_in">CFString</span> = <span class="built_in">CFStringCreateWithCString</span>(kCFAllocatorDefault, <span class="string">"hello Core Foundation"</span>, kCFStringEncodingASCII);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"CFString retainCount= %ld"</span>,<span class="built_in">CFGetRetainCount</span>(<span class="built_in">CFString</span>));<span class="comment">//CFString retainCount= 1</span></span><br><span class="line">    <span class="built_in">NSString</span> *string = (__bridge <span class="built_in">NSString</span> *)<span class="built_in">CFString</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"CFstring==%@,\nstring==%@\n"</span>,<span class="built_in">CFString</span>,string);</span><br><span class="line">    <span class="built_in">NSString</span> *qStr = <span class="string">@"qgh"</span>;</span><br><span class="line">    <span class="built_in">CFStringRef</span> qCFStr = (__bridge <span class="built_in">CFStringRef</span>)qStr;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"qStr==%@,qCFStr==%@\n"</span>,qStr,qCFStr);</span><br><span class="line">    <span class="built_in">NSArray</span> *array = @[<span class="string">@"a"</span>,<span class="string">@"b"</span>,<span class="string">@"c"</span>,<span class="string">@"d"</span>,<span class="string">@"e"</span>,<span class="string">@"f"</span>,<span class="string">@"g"</span>,<span class="string">@"h"</span>];</span><br><span class="line">    <span class="built_in">CFArrayRef</span> <span class="built_in">CFArray</span> = (__bridge <span class="built_in">CFArrayRef</span>)(array);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"CFArray retainCount= %ld"</span>,<span class="built_in">CFGetRetainCount</span>(<span class="built_in">CFArray</span>));<span class="comment">//CFArray retainCount= 1</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"array==%@"</span>,<span class="built_in">CFArray</span>);</span><br></pre></td></tr></table></figure><hr><p><strong><code>__bridge_transfer</code>:</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//__bridge_transfer:类型转换后，将该对象的引用计数交给ARC管理.</span></span><br><span class="line"><span class="built_in">NSString</span> *transferString = [[<span class="built_in">NSString</span> alloc]initWithFormat:<span class="string">@"test:::__bridge_transfer"</span>];</span><br><span class="line"><span class="built_in">CFStringRef</span> <span class="built_in">CFTransferString</span> = (__bridge_retained <span class="built_in">CFStringRef</span>)(transferString);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"CFTransferString count is %ld"</span>, <span class="built_in">CFGetRetainCount</span>(<span class="built_in">CFTransferString</span>));<span class="comment">//CFTransferString count is 2</span></span><br><span class="line">transferString = (__bridge_transfer <span class="built_in">NSString</span> *)(<span class="built_in">CFTransferString</span>);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"transferString count is %ld"</span>, <span class="built_in">CFGetRetainCount</span>((__bridge <span class="built_in">CFTypeRef</span>)(transferString)));<span class="comment">//transferString count is 1</span></span><br></pre></td></tr></table></figure><hr><p><strong><code>__bridge_retained</code>:</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//__bridge_retained: 类型被转换时，其对象的所有权也将被变换后变量所持有</span></span><br><span class="line"><span class="keyword">void</span> *y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">id</span> object = [[<span class="built_in">NSObject</span> alloc]init];</span><br><span class="line">y = (__bridge_retained <span class="keyword">void</span>*)(object);<span class="comment">//类型转换后将相关对象的引用计数加1</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"object-y count is %ld"</span>, <span class="built_in">CFGetRetainCount</span>(y));<span class="comment">//object-y count is 2</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"class=%@"</span>,[(__bridge <span class="keyword">id</span>)(y) <span class="keyword">class</span>]);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇知识比较偏，是偏低层一些的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一：__birdge&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于&lt;code&gt;__bridge&lt;/code&gt;很少接触，所以专门去查找了一下。其实它的作用很简单，就是：实现&lt;code&gt;id&lt;/code&gt;类型与&lt;code&gt;
      
    
    </summary>
    
      <category term="iOS" scheme="http://guohuaden.com/categories/iOS/"/>
    
    
      <category term="bridge和Core Foundation" scheme="http://guohuaden.com/tags/bridge%E5%92%8CCore-Foundation/"/>
    
  </entry>
  
  <entry>
    <title>我和这个世界不熟 --北岛</title>
    <link href="http://guohuaden.com/2017/03/12/I-am-not-familiar-with-this-world/"/>
    <id>http://guohuaden.com/2017/03/12/I-am-not-familiar-with-this-world/</id>
    <published>2017-03-12T01:04:32.000Z</published>
    <updated>2018-08-21T04:57:46.902Z</updated>
    
    <content type="html"><![CDATA[<p>　　我和这个世界不熟。 </p><p>　　这并非是我安静的原因。 </p><p>　　我依旧有很多问题， </p><p>　　问南方，问故里，问希望，问距离。  <br>　　 </p><p>　　我和这个世界不熟。 </p><p>　　这并非是我绝望的原因。 </p><p>　　我依旧有很多热情， </p><p>　　给分开，给死亡，给昨天，给安寂。  <br>　　 </p><p>　　我和这个世界不熟。 </p><p>　　这并非是我虚假的原因。 </p><p>　　我依旧有很多真诚， </p><p>　　离不开，放不下，活下去，爱得起。  <br>　　 </p><p>　　我和这个世界不熟。 </p><p>　　这并非是我孤寂的原因。 </p><p>　　我依旧有很多诉求， </p><p>　　需慰藉，待分享，惹心烦，告诉你。  <br>　　 </p><p>　　我和这个世界不熟。 </p><p>　　这并非是我冷漠的原因。 </p><p>　　我依旧有很多动情， </p><p>　　为时间，为白云，为天黑，畏天命。  <br>　　 </p><p>　　我和这个世界不熟。 </p><p>　　这并非是我逃避的原因。 </p><p>　　我依旧有很多憧憬， </p><p>　　对梦想，对记忆，对失败，对希冀。  <br>　　 </p><p>　　我和这个世界不熟。 </p><p>　　这并非是我卑微的原因。 </p><p>　　我依旧有很多勇敢， </p><p>　　不信输，不信神，不信天，不信地。  <br>　　 </p><p>　　我和这个世界不熟。 </p><p>　　这并非是我失落的原因。 </p><p>　　我依旧有很多高昂， </p><p>　　有存在，有价值，有独特，有意义。  <br>　　 </p><p>　　我和这个世界不熟。 </p><p>　　这并非是我迷茫的原因。 </p><p>　　我依旧有很多方向， </p><p>　　往前走，回头望，会跳跃，会停息。  <br>　　 </p><p>　　我和这个世界不熟。 </p><p>　　这并非是我撕裂的原因。 </p><p>　　我依旧有很多完整， </p><p>　　至少我要成全我自己。  <br>　　 </p><p>　　我和这个世界不熟。 </p><p>　　这并非是我选择死亡或者生存的原因。 </p><p>　　我依旧有很多选择， </p><p>　　刚巧，这两者，都不是选项之一。  <br>　　</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　我和这个世界不熟。 &lt;/p&gt;
&lt;p&gt;　　这并非是我安静的原因。 &lt;/p&gt;
&lt;p&gt;　　我依旧有很多问题， &lt;/p&gt;
&lt;p&gt;　　问南方，问故里，问希望，问距离。  &lt;br&gt;
　　 &lt;/p&gt;
&lt;p&gt;　　我和这个世界不熟。 &lt;/p&gt;
&lt;p&gt;　　这并非是我绝望的原因。 &lt;/p&gt;

      
    
    </summary>
    
      <category term="欠下的时光" scheme="http://guohuaden.com/categories/%E6%AC%A0%E4%B8%8B%E7%9A%84%E6%97%B6%E5%85%89/"/>
    
    
      <category term="欠下的时光" scheme="http://guohuaden.com/tags/%E6%AC%A0%E4%B8%8B%E7%9A%84%E6%97%B6%E5%85%89/"/>
    
  </entry>
  
  <entry>
    <title>iOS之防止用户重复点击Button（按钮）问题</title>
    <link href="http://guohuaden.com/2017/03/10/Repeat-ButtonClick/"/>
    <id>http://guohuaden.com/2017/03/10/Repeat-ButtonClick/</id>
    <published>2017-03-10T06:46:31.000Z</published>
    <updated>2018-08-21T04:58:27.565Z</updated>
    
    <content type="html"><![CDATA[<p>在项目中，我们往往会遇到这样的问题：因为网络较慢的原因，用户会不耐烦的一直去点击按钮，这样导致的结果时：相关代码一遍一遍的被重复执行，如果按钮的事件是网络请求的话，这样又导致一种网络请求的循环。所以我们解决的方法是在执行按钮点击事件时，为<code>Button</code>加上防止重复点击的方法。</p><p>具体的有以下几种方法：</p><font color="#0B1746"><strong>1、使用<code>performSelector</code>方法</strong></font><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>performSelector:<span class="params">(SEL)</span>aSelector withObject:<span class="params">(nullable id)</span>anArgument afterDelay:<span class="params">(NSTimeInterval)</span>delay;</span><br></pre></td></tr></table></figure><p>我们在点击事件中添加延迟执行事件，在延迟的这个期间，该按钮的<code>enabled</code>设置为NO，即不能点击。过了延迟时间后再设置为<code>YES</code>。以这种方式防止用户重复点击按钮。</p><p>代码如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)<span class="string">buttonClicked:</span>(id)sender</span><br><span class="line">&#123;</span><br><span class="line">   sender.enabled = NO;</span><br><span class="line">  <span class="comment">//防止用户重复点击</span></span><br><span class="line">  [self <span class="string">performSelector:</span><span class="meta">@selector</span>(<span class="string">changeButtonStatus:</span>) <span class="string">withObject:</span>nil <span class="string">afterDelay:</span><span class="number">1.0</span>f];</span><br><span class="line">&#125;</span><br><span class="line">-(<span class="keyword">void</span>)<span class="string">changeButtonStatus:</span>(id)sender</span><br><span class="line">&#123;</span><br><span class="line">    sender.enabled = YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的方法可以很好的解决我们重复点击按钮的问题，但更推荐的却是下面的这种方法：</p><font color="#0B1746"><strong>2、使用<code>cancelPreviousPerformRequestsWithTarget</code> 和  <code>performSelector</code> 结合的方法（推荐使用</strong>）</font><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)<span class="string">cancelPreviousPerformRequestsWithTarget:</span>(id)aTarget <span class="string">selector:</span>(SEL)aSelector <span class="string">object:</span>(nullable id)anArgument;</span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">performSelector:</span>(SEL)aSelector <span class="string">withObject:</span>(nullable id)anArgument <span class="string">afterDelay:</span>(NSTimeInterval)delay;</span><br></pre></td></tr></table></figure><p>原理是：我们每次点击按钮时，先执行取消之前的按钮点击执行事件，然后再去执行一个延迟执行方法（方法中执行的是按钮执行的事件）。代码如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">buttonClicked</span><span class="selector-pseudo">:(id)sender</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在这里做按钮的想做的事情。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">starButtonClicked</span><span class="selector-pseudo">:(id)sender</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//先将未到时间执行前的任务取消。</span></span><br><span class="line">    <span class="selector-attr">[[self class]</span> <span class="selector-tag">cancelPreviousPerformRequestsWithTarget</span><span class="selector-pseudo">:self</span> <span class="selector-tag">selector</span>:@<span class="selector-tag">selector</span>(<span class="attribute">buttonClicked</span>:)<span class="selector-tag">object</span><span class="selector-pseudo">:sender</span>];</span><br><span class="line">    <span class="selector-attr">[self performSelector:@selector(buttonClicked:)withObject:sender afterDelay:0.2f]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种是我们比较推荐的方法，但这两种方法都可以解决按钮被重复点击的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在项目中，我们往往会遇到这样的问题：因为网络较慢的原因，用户会不耐烦的一直去点击按钮，这样导致的结果时：相关代码一遍一遍的被重复执行，如果按钮的事件是网络请求的话，这样又导致一种网络请求的循环。所以我们解决的方法是在执行按钮点击事件时，为&lt;code&gt;Button&lt;/code
      
    
    </summary>
    
      <category term="iOS" scheme="http://guohuaden.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://guohuaden.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>服务器返回的json数据中含有null的处理方法</title>
    <link href="http://guohuaden.com/2017/03/06/json-dataNull/"/>
    <id>http://guohuaden.com/2017/03/06/json-dataNull/</id>
    <published>2017-03-06T05:33:53.000Z</published>
    <updated>2018-10-24T06:54:05.558Z</updated>
    
    <content type="html"><![CDATA[<p>因为有遇到过类似情况，所以就想到了一些解决方法，并且实践了一下，这里简单的做个记录。</p><p><strong>注：</strong>有看到不少的评价，有说后台责任，也有说怪移动端没有做容错处理。我这里就事论事的说下，移动端从服务器得到的数据中确实是不应该包含<code>null</code>的，因为这本身就是不合理的。（当然，我的就事论事是站在iOS立场上说的，这个无可厚非）。</p><p>下面说一下想到的几种方法：</p><p><strong>一、 对于所有使用到的json中的对象做判断（当然这是最笨的方法）</strong></p><pre><code>NSString *msg ;if ([str isKindOfClass: [NSNull class]]){    NSLog(@&quot;str 为空！&quot;);}//或者使用[str isEqual:[NSNull null]]</code></pre><p>为什么首先说这种方法呢，大抵是因为这个方法的工作量比较大吧。但有时候你是完全不能避免这种情况的，尤其是在老旧的项目中，当你看到项目中所有的解析都是<code>KVO</code>模式时，你就知道一个个去判断是多么让人纠结的事情了。</p><hr><p><strong>二、使用<code>JSONModel</code>等第三方json解析库</strong>  </p><p><code>JSONModel</code>有专门针对对象为<code>null</code>的处理，使其返回<code>&lt;null&gt;</code>。iOS移动端赋值为<code>nil</code>。</p><hr><p><strong>三、有一个专门针对数据为<code>null</code>的处理库，<code>NullSafe</code></strong></p><p>这个库是专门处理对象为<code>null</code>的。只有一个<code>.m</code>文件。使用也简单，因为你只需要添加到项目中就可以了，不再需要引入头文件等其他任意操作。</p><p>这里放一个我测试是使用的简单demo</p><p><a href="https://github.com/Wheat-Qin/Data_null_test" target="_blank" rel="noopener">github:data_nullDemo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为有遇到过类似情况，所以就想到了一些解决方法，并且实践了一下，这里简单的做个记录。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;有看到不少的评价，有说后台责任，也有说怪移动端没有做容错处理。我这里就事论事的说下，移动端从服务器得到的数据中确实是不应该包含&lt;code
      
    
    </summary>
    
      <category term="iOS" scheme="http://guohuaden.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://guohuaden.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>WebView 打不开问题 (转码问题)</title>
    <link href="http://guohuaden.com/2017/02/27/WebView-ErrorOpen/"/>
    <id>http://guohuaden.com/2017/02/27/WebView-ErrorOpen/</id>
    <published>2017-02-27T01:56:54.000Z</published>
    <updated>2018-10-24T11:05:51.969Z</updated>
    
    <content type="html"><![CDATA[<p>无意中遇到一个问题，项目中使用<code>UIWebView</code>打不开<code>web</code>界面，检查过<code>URL</code>和代码，发现并没有问题。随考虑到一点：<strong>URL中包含汉字</strong>。</p><p>处理如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *URLString = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@id=%@&amp;email=%@"</span>,ProviderOrder,<span class="keyword">self</span>.orderID,emailStr];</span><br><span class="line"><span class="comment">//方法是用来进行转码的，即将汉字转码</span></span><br><span class="line"><span class="built_in">NSString</span> *encodedString1 = [URLString stringByAddingPercentEncodingWithAllowedCharacters:[<span class="built_in">NSCharacterSet</span> URLQueryAllowedCharacterSet]];</span><br><span class="line"><span class="comment">//该方法用来进行转码的，即将汉字转码（在Xcode7中，iOS9）</span></span><br><span class="line"><span class="comment">//NSString *encodedString = [URLString stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];</span></span><br><span class="line"><span class="built_in">NSURL</span> *url =[<span class="built_in">NSURL</span> URLWithString:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@"</span>,encodedString1]];</span><br><span class="line"><span class="keyword">self</span>.webView = [[<span class="built_in">UIWebView</span> alloc]initWithFrame:<span class="keyword">self</span>.view.bounds];</span><br><span class="line"><span class="keyword">self</span>.webView.delegate = <span class="keyword">self</span>;</span><br><span class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:url ];</span><br><span class="line">[<span class="keyword">self</span>.webView loadRequest:request];</span><br><span class="line">[<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.webView];</span><br></pre></td></tr></table></figure><p>上面为什么推荐使用</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">NSString</span> *)stringByAddingPercentEncodingWithAllowedCharacters:(NSCharacterSet *)allowedCharacters</span><br></pre></td></tr></table></figure><p>这里是文档中给出的解释：</p><p><strong>其一：</strong></p><blockquote></blockquote><p>Use -stringByAddingPercentEncodingWithAllowedCharacters: instead,<br>which always uses the recommended UTF-8 encoding,<br>and which encodes for a specific URL component or subcomponent since each URL component or subcomponent has different rules for what characters are valid.</p><p>翻译如下：</p><p>使用<code>-stringByAddingPercentEncodingWithAllowedCharacters：</code>改为，<br>它总是使用推荐的<code>UTF-8</code>编码，<br>并且其对特定的URL组件或子组件进行编码，因为每个URL组件或子组件对于什么字符是有效的具有不同的规则。</p><p><strong>其二：</strong></p><blockquote></blockquote><p>Returns a new string made from the receiver by replacing all characters not in the allowedCharacters set with percent encoded characters.<br>UTF-8 encoding is used to determine the correct percent encoded characters.<br>Entire URL strings cannot be percent-encoded.<br>This method is intended to percent-encode an URL component or subcomponent string, NOT the entire URL string.<br>Any characters in allowedCharacters outside of the 7-bit ASCII range are ignored.</p><p>翻译如下：</p><p>通过替换不在allowedCharacters中的所有字符，使用百分比编码字符返回从接收器创建的新字符串。 UTF-8编码用于确定正确的百分比编码字符。 整个URL字符串不能进行百分号编码。 此方法旨在对URL组件或子组件字符串（而不是整个URL字符串）进行百分比编码。 将忽略7位ASCII范围之外的allowedCharacters中的任何字符。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;无意中遇到一个问题，项目中使用&lt;code&gt;UIWebView&lt;/code&gt;打不开&lt;code&gt;web&lt;/code&gt;界面，检查过&lt;code&gt;URL&lt;/code&gt;和代码，发现并没有问题。随考虑到一点：&lt;strong&gt;URL中包含汉字&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;处理如下：&lt;
      
    
    </summary>
    
      <category term="iOS" scheme="http://guohuaden.com/categories/iOS/"/>
    
    
      <category term="WebView" scheme="http://guohuaden.com/tags/WebView/"/>
    
  </entry>
  
</feed>
